{
  "objectId": "0x25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d",
  "version": "1",
  "digest": "9db2aJHE2Aa973xwxZFQCcBYdS3Q4qGix5KJ1TKWSkk2",
  "type": "package",
  "owner": "Immutable",
  "previousTransaction": "FMZohDAuHr9XBq1nFLmcoLDhrg6HwNYcQ38S5NicCi75",
  "storageRebate": "365088800",
  "content": {
    "dataType": "package",
    "disassembled": {
      "admin_cap": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.admin_cap {\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct AdminCap has store, key {\n\tid: UID\n}\n\ninit(Arg0: &mut TxContext) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: Pack[0](AdminCap)\n\t3: MoveLoc[0](Arg0: &mut TxContext)\n\t4: FreezeRef\n\t5: Call tx_context::sender(&TxContext): address\n\t6: Call transfer::transfer<AdminCap>(AdminCap, address)\n\t7: Ret\n}\n\n}\n",
      "bit_math": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.bit_math {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::constants;\n\npublic get_most_significant_bit(Arg0: u256): u8 {\nL1:\tloc0: u8\nB0:\n\t0: CopyLoc[0](Arg0: u256)\n\t1: LdU256(0)\n\t2: Gt\n\t3: BrFalse(5)\nB1:\n\t4: Branch(7)\nB2:\n\t5: LdConst[0](u64: 0)\n\t6: Abort\nB3:\n\t7: LdU8(0)\n\t8: StLoc[1](loc0: u8)\n\t9: CopyLoc[0](Arg0: u256)\n\t10: LdU256(340282366920938463463374607431768211456)\n\t11: Ge\n\t12: BrFalse(21)\nB4:\n\t13: MoveLoc[0](Arg0: u256)\n\t14: LdU8(128)\n\t15: Shr\n\t16: StLoc[0](Arg0: u256)\n\t17: MoveLoc[1](loc0: u8)\n\t18: LdU8(128)\n\t19: Add\n\t20: StLoc[1](loc0: u8)\nB5:\n\t21: CopyLoc[0](Arg0: u256)\n\t22: LdU256(18446744073709551616)\n\t23: Ge\n\t24: BrFalse(33)\nB6:\n\t25: MoveLoc[0](Arg0: u256)\n\t26: LdU8(64)\n\t27: Shr\n\t28: StLoc[0](Arg0: u256)\n\t29: MoveLoc[1](loc0: u8)\n\t30: LdU8(64)\n\t31: Add\n\t32: StLoc[1](loc0: u8)\nB7:\n\t33: CopyLoc[0](Arg0: u256)\n\t34: LdU256(4294967296)\n\t35: Ge\n\t36: BrFalse(45)\nB8:\n\t37: MoveLoc[0](Arg0: u256)\n\t38: LdU8(32)\n\t39: Shr\n\t40: StLoc[0](Arg0: u256)\n\t41: MoveLoc[1](loc0: u8)\n\t42: LdU8(32)\n\t43: Add\n\t44: StLoc[1](loc0: u8)\nB9:\n\t45: CopyLoc[0](Arg0: u256)\n\t46: LdU256(65536)\n\t47: Ge\n\t48: BrFalse(57)\nB10:\n\t49: MoveLoc[0](Arg0: u256)\n\t50: LdU8(16)\n\t51: Shr\n\t52: StLoc[0](Arg0: u256)\n\t53: MoveLoc[1](loc0: u8)\n\t54: LdU8(16)\n\t55: Add\n\t56: StLoc[1](loc0: u8)\nB11:\n\t57: CopyLoc[0](Arg0: u256)\n\t58: LdU256(256)\n\t59: Ge\n\t60: BrFalse(69)\nB12:\n\t61: MoveLoc[0](Arg0: u256)\n\t62: LdU8(8)\n\t63: Shr\n\t64: StLoc[0](Arg0: u256)\n\t65: MoveLoc[1](loc0: u8)\n\t66: LdU8(8)\n\t67: Add\n\t68: StLoc[1](loc0: u8)\nB13:\n\t69: CopyLoc[0](Arg0: u256)\n\t70: LdU256(16)\n\t71: Ge\n\t72: BrFalse(81)\nB14:\n\t73: MoveLoc[0](Arg0: u256)\n\t74: LdU8(4)\n\t75: Shr\n\t76: StLoc[0](Arg0: u256)\n\t77: MoveLoc[1](loc0: u8)\n\t78: LdU8(4)\n\t79: Add\n\t80: StLoc[1](loc0: u8)\nB15:\n\t81: CopyLoc[0](Arg0: u256)\n\t82: LdU256(4)\n\t83: Ge\n\t84: BrFalse(93)\nB16:\n\t85: MoveLoc[0](Arg0: u256)\n\t86: LdU8(2)\n\t87: Shr\n\t88: StLoc[0](Arg0: u256)\n\t89: MoveLoc[1](loc0: u8)\n\t90: LdU8(2)\n\t91: Add\n\t92: StLoc[1](loc0: u8)\nB17:\n\t93: MoveLoc[0](Arg0: u256)\n\t94: LdU256(2)\n\t95: Ge\n\t96: BrFalse(101)\nB18:\n\t97: MoveLoc[1](loc0: u8)\n\t98: LdU8(1)\n\t99: Add\n\t100: StLoc[1](loc0: u8)\nB19:\n\t101: MoveLoc[1](loc0: u8)\n\t102: Ret\n}\n\npublic get_least_significant_bit(Arg0: u256): u8 {\nL1:\tloc0: u8\nB0:\n\t0: CopyLoc[0](Arg0: u256)\n\t1: LdU256(0)\n\t2: Gt\n\t3: BrFalse(5)\nB1:\n\t4: Branch(7)\nB2:\n\t5: LdConst[0](u64: 0)\n\t6: Abort\nB3:\n\t7: LdU8(255)\n\t8: StLoc[1](loc0: u8)\n\t9: CopyLoc[0](Arg0: u256)\n\t10: Call constants::get_max_u128(): u128\n\t11: CastU256\n\t12: BitAnd\n\t13: LdU256(0)\n\t14: Gt\n\t15: BrFalse(21)\nB4:\n\t16: MoveLoc[1](loc0: u8)\n\t17: LdU8(128)\n\t18: Sub\n\t19: StLoc[1](loc0: u8)\n\t20: Branch(25)\nB5:\n\t21: MoveLoc[0](Arg0: u256)\n\t22: LdU8(128)\n\t23: Shr\n\t24: StLoc[0](Arg0: u256)\nB6:\n\t25: CopyLoc[0](Arg0: u256)\n\t26: Call constants::get_max_u64(): u64\n\t27: CastU256\n\t28: BitAnd\n\t29: LdU256(0)\n\t30: Gt\n\t31: BrFalse(37)\nB7:\n\t32: MoveLoc[1](loc0: u8)\n\t33: LdU8(64)\n\t34: Sub\n\t35: StLoc[1](loc0: u8)\n\t36: Branch(41)\nB8:\n\t37: MoveLoc[0](Arg0: u256)\n\t38: LdU8(64)\n\t39: Shr\n\t40: StLoc[0](Arg0: u256)\nB9:\n\t41: CopyLoc[0](Arg0: u256)\n\t42: Call constants::get_max_u32(): u32\n\t43: CastU256\n\t44: BitAnd\n\t45: LdU256(0)\n\t46: Gt\n\t47: BrFalse(53)\nB10:\n\t48: MoveLoc[1](loc0: u8)\n\t49: LdU8(32)\n\t50: Sub\n\t51: StLoc[1](loc0: u8)\n\t52: Branch(57)\nB11:\n\t53: MoveLoc[0](Arg0: u256)\n\t54: LdU8(32)\n\t55: Shr\n\t56: StLoc[0](Arg0: u256)\nB12:\n\t57: CopyLoc[0](Arg0: u256)\n\t58: Call constants::get_max_u16(): u16\n\t59: CastU256\n\t60: BitAnd\n\t61: LdU256(0)\n\t62: Gt\n\t63: BrFalse(69)\nB13:\n\t64: MoveLoc[1](loc0: u8)\n\t65: LdU8(16)\n\t66: Sub\n\t67: StLoc[1](loc0: u8)\n\t68: Branch(73)\nB14:\n\t69: MoveLoc[0](Arg0: u256)\n\t70: LdU8(16)\n\t71: Shr\n\t72: StLoc[0](Arg0: u256)\nB15:\n\t73: CopyLoc[0](Arg0: u256)\n\t74: Call constants::get_max_u8(): u8\n\t75: CastU256\n\t76: BitAnd\n\t77: LdU256(0)\n\t78: Gt\n\t79: BrFalse(85)\nB16:\n\t80: MoveLoc[1](loc0: u8)\n\t81: LdU8(8)\n\t82: Sub\n\t83: StLoc[1](loc0: u8)\n\t84: Branch(89)\nB17:\n\t85: MoveLoc[0](Arg0: u256)\n\t86: LdU8(8)\n\t87: Shr\n\t88: StLoc[0](Arg0: u256)\nB18:\n\t89: CopyLoc[0](Arg0: u256)\n\t90: LdU256(15)\n\t91: BitAnd\n\t92: LdU256(0)\n\t93: Gt\n\t94: BrFalse(100)\nB19:\n\t95: MoveLoc[1](loc0: u8)\n\t96: LdU8(4)\n\t97: Sub\n\t98: StLoc[1](loc0: u8)\n\t99: Branch(104)\nB20:\n\t100: MoveLoc[0](Arg0: u256)\n\t101: LdU8(4)\n\t102: Shr\n\t103: StLoc[0](Arg0: u256)\nB21:\n\t104: CopyLoc[0](Arg0: u256)\n\t105: LdU256(3)\n\t106: BitAnd\n\t107: LdU256(0)\n\t108: Gt\n\t109: BrFalse(115)\nB22:\n\t110: MoveLoc[1](loc0: u8)\n\t111: LdU8(2)\n\t112: Sub\n\t113: StLoc[1](loc0: u8)\n\t114: Branch(119)\nB23:\n\t115: MoveLoc[0](Arg0: u256)\n\t116: LdU8(2)\n\t117: Shr\n\t118: StLoc[0](Arg0: u256)\nB24:\n\t119: MoveLoc[0](Arg0: u256)\n\t120: LdU256(1)\n\t121: BitAnd\n\t122: LdU256(0)\n\t123: Gt\n\t124: BrFalse(129)\nB25:\n\t125: MoveLoc[1](loc0: u8)\n\t126: LdU8(1)\n\t127: Sub\n\t128: StLoc[1](loc0: u8)\nB26:\n\t129: MoveLoc[1](loc0: u8)\n\t130: Ret\n}\n\nConstants [\n\t0 => u64: 0\n]\n}\n",
      "caster": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.caster {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i32;\n\npublic cast_to_u8(Arg0: I32): u8 {\nB0:\n\t0: CopyLoc[0](Arg0: I32)\n\t1: Call i32::abs_u32(I32): u32\n\t2: LdU32(256)\n\t3: Lt\n\t4: BrFalse(6)\nB1:\n\t5: Branch(8)\nB2:\n\t6: LdConst[0](u64: 0)\n\t7: Abort\nB3:\n\t8: MoveLoc[0](Arg0: I32)\n\t9: LdU32(256)\n\t10: Call i32::from(u32): I32\n\t11: Call i32::add(I32, I32): I32\n\t12: Call i32::abs_u32(I32): u32\n\t13: LdU32(255)\n\t14: BitAnd\n\t15: CastU8\n\t16: Ret\n}\n\nConstants [\n\t0 => u64: 0\n]\n}\n",
      "comparator": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.comparator {\nuse 0000000000000000000000000000000000000000000000000000000000000001::bcs;\n\nstruct Result has drop {\n\tinner: u8\n}\n\npublic is_equal(Arg0: &Result): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Result)\n\t1: ImmBorrowField[0](Result.inner: u8)\n\t2: ReadRef\n\t3: LdConst[0](u8: 0)\n\t4: Eq\n\t5: Ret\n}\n\npublic is_smaller_than(Arg0: &Result): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Result)\n\t1: ImmBorrowField[0](Result.inner: u8)\n\t2: ReadRef\n\t3: LdConst[1](u8: 1)\n\t4: Eq\n\t5: Ret\n}\n\npublic is_greater_than(Arg0: &Result): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Result)\n\t1: ImmBorrowField[0](Result.inner: u8)\n\t2: ReadRef\n\t3: LdConst[2](u8: 2)\n\t4: Eq\n\t5: Ret\n}\n\npublic compare<Ty0>(Arg0: &Ty0, Arg1: &Ty0): Result {\nL2:\tloc0: vector<u8>\nL3:\tloc1: vector<u8>\nB0:\n\t0: MoveLoc[0](Arg0: &Ty0)\n\t1: Call bcs::to_bytes<Ty0>(&Ty0): vector<u8>\n\t2: StLoc[2](loc0: vector<u8>)\n\t3: MoveLoc[1](Arg1: &Ty0)\n\t4: Call bcs::to_bytes<Ty0>(&Ty0): vector<u8>\n\t5: StLoc[3](loc1: vector<u8>)\n\t6: MoveLoc[2](loc0: vector<u8>)\n\t7: MoveLoc[3](loc1: vector<u8>)\n\t8: Call compare_u8_vector(vector<u8>, vector<u8>): Result\n\t9: Ret\n}\n\npublic compare_u8_vector(Arg0: vector<u8>, Arg1: vector<u8>): Result {\nL2:\tloc0: bool\nL3:\tloc1: Result\nL4:\tloc2: Result\nL5:\tloc3: u64\nL6:\tloc4: u8\nL7:\tloc5: u64\nL8:\tloc6: u8\nL9:\tloc7: u64\nB0:\n\t0: ImmBorrowLoc[0](Arg0: vector<u8>)\n\t1: VecLen(10)\n\t2: StLoc[7](loc5: u64)\n\t3: ImmBorrowLoc[1](Arg1: vector<u8>)\n\t4: VecLen(10)\n\t5: StLoc[9](loc7: u64)\n\t6: LdU64(0)\n\t7: StLoc[5](loc3: u64)\nB1:\n\t8: CopyLoc[5](loc3: u64)\n\t9: CopyLoc[7](loc5: u64)\n\t10: Lt\n\t11: BrFalse(18)\nB2:\n\t12: Branch(13)\nB3:\n\t13: CopyLoc[5](loc3: u64)\n\t14: CopyLoc[9](loc7: u64)\n\t15: Lt\n\t16: StLoc[2](loc0: bool)\n\t17: Branch(20)\nB4:\n\t18: LdFalse\n\t19: StLoc[2](loc0: bool)\nB5:\n\t20: MoveLoc[2](loc0: bool)\n\t21: BrFalse(51)\nB6:\n\t22: ImmBorrowLoc[0](Arg0: vector<u8>)\n\t23: CopyLoc[5](loc3: u64)\n\t24: VecImmBorrow(10)\n\t25: ReadRef\n\t26: StLoc[6](loc4: u8)\n\t27: ImmBorrowLoc[1](Arg1: vector<u8>)\n\t28: CopyLoc[5](loc3: u64)\n\t29: VecImmBorrow(10)\n\t30: ReadRef\n\t31: StLoc[8](loc6: u8)\n\t32: CopyLoc[6](loc4: u8)\n\t33: CopyLoc[8](loc6: u8)\n\t34: Lt\n\t35: BrFalse(39)\nB7:\n\t36: LdConst[1](u8: 1)\n\t37: Pack[0](Result)\n\t38: Ret\nB8:\n\t39: MoveLoc[6](loc4: u8)\n\t40: MoveLoc[8](loc6: u8)\n\t41: Gt\n\t42: BrFalse(46)\nB9:\n\t43: LdConst[2](u8: 2)\n\t44: Pack[0](Result)\n\t45: Ret\nB10:\n\t46: MoveLoc[5](loc3: u64)\n\t47: LdU64(1)\n\t48: Add\n\t49: StLoc[5](loc3: u64)\n\t50: Branch(8)\nB11:\n\t51: CopyLoc[7](loc5: u64)\n\t52: CopyLoc[9](loc7: u64)\n\t53: Lt\n\t54: BrFalse(59)\nB12:\n\t55: LdConst[1](u8: 1)\n\t56: Pack[0](Result)\n\t57: StLoc[4](loc2: Result)\n\t58: Branch(72)\nB13:\n\t59: MoveLoc[7](loc5: u64)\n\t60: MoveLoc[9](loc7: u64)\n\t61: Gt\n\t62: BrFalse(67)\nB14:\n\t63: LdConst[2](u8: 2)\n\t64: Pack[0](Result)\n\t65: StLoc[3](loc1: Result)\n\t66: Branch(70)\nB15:\n\t67: LdConst[0](u8: 0)\n\t68: Pack[0](Result)\n\t69: StLoc[3](loc1: Result)\nB16:\n\t70: MoveLoc[3](loc1: Result)\n\t71: StLoc[4](loc2: Result)\nB17:\n\t72: MoveLoc[4](loc2: Result)\n\t73: Ret\n}\n\nConstants [\n\t0 => u8: 0\n\t1 => u8: 1\n\t2 => u8: 2\n]\n}\n",
      "constants": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.constants {\n\npublic get_max_u8(): u8 {\nB0:\n\t0: LdConst[0](u8: 255)\n\t1: Ret\n}\n\npublic get_max_u16(): u16 {\nB0:\n\t0: LdConst[1](u16: 65535)\n\t1: Ret\n}\n\npublic get_max_u32(): u32 {\nB0:\n\t0: LdConst[2](u32: 4294..)\n\t1: Ret\n}\n\npublic get_max_u64(): u64 {\nB0:\n\t0: LdConst[3](u64: 1844..)\n\t1: Ret\n}\n\npublic get_max_u128(): u128 {\nB0:\n\t0: LdConst[4](u128: 3402..)\n\t1: Ret\n}\n\npublic get_max_u256(): u256 {\nB0:\n\t0: LdConst[5](u256: 1157..)\n\t1: Ret\n}\n\npublic get_q64(): u128 {\nB0:\n\t0: LdConst[6](u128: 1844..)\n\t1: Ret\n}\n\npublic get_fee_rate_denominator_value(): u64 {\nB0:\n\t0: LdConst[7](u64: 1000..)\n\t1: Ret\n}\n\nConstants [\n\t0 => u8: 255\n\t1 => u16: 65535\n\t2 => u32: 4294967295\n\t3 => u64: 18446744073709551615\n\t4 => u128: 340282366920938463463374607431768211455\n\t5 => u256: 115792089237316195423570985008687907853269984665640564039457584007913129639935\n\t6 => u128: 18446744073709551616\n\t7 => u64: 1000000\n]\n}\n",
      "full_math_u128": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.full_math_u128 {\n\npublic mul_div_floor(Arg0: u128, Arg1: u128, Arg2: u128): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: MoveLoc[1](Arg1: u128)\n\t2: Call full_mul(u128, u128): u256\n\t3: MoveLoc[2](Arg2: u128)\n\t4: CastU256\n\t5: Div\n\t6: CastU128\n\t7: Ret\n}\n\npublic mul_div_round(Arg0: u128, Arg1: u128, Arg2: u128): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: MoveLoc[1](Arg1: u128)\n\t2: Call full_mul(u128, u128): u256\n\t3: CopyLoc[2](Arg2: u128)\n\t4: CastU256\n\t5: LdU8(1)\n\t6: Shr\n\t7: Add\n\t8: MoveLoc[2](Arg2: u128)\n\t9: CastU256\n\t10: Div\n\t11: CastU128\n\t12: Ret\n}\n\npublic mul_div_ceil(Arg0: u128, Arg1: u128, Arg2: u128): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: MoveLoc[1](Arg1: u128)\n\t2: Call full_mul(u128, u128): u256\n\t3: CopyLoc[2](Arg2: u128)\n\t4: CastU256\n\t5: LdU256(1)\n\t6: Sub\n\t7: Add\n\t8: MoveLoc[2](Arg2: u128)\n\t9: CastU256\n\t10: Div\n\t11: CastU128\n\t12: Ret\n}\n\npublic mul_shr(Arg0: u128, Arg1: u128, Arg2: u8): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: MoveLoc[1](Arg1: u128)\n\t2: Call full_mul(u128, u128): u256\n\t3: MoveLoc[2](Arg2: u8)\n\t4: Shr\n\t5: CastU128\n\t6: Ret\n}\n\npublic mul_shl(Arg0: u128, Arg1: u128, Arg2: u8): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: MoveLoc[1](Arg1: u128)\n\t2: Call full_mul(u128, u128): u256\n\t3: MoveLoc[2](Arg2: u8)\n\t4: Shl\n\t5: CastU128\n\t6: Ret\n}\n\npublic full_mul(Arg0: u128, Arg1: u128): u256 {\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: CastU256\n\t2: MoveLoc[1](Arg1: u128)\n\t3: CastU256\n\t4: Mul\n\t5: Ret\n}\n\npublic max(Arg0: u128, Arg1: u128): u128 {\nL2:\tloc0: u128\nB0:\n\t0: CopyLoc[0](Arg0: u128)\n\t1: CopyLoc[1](Arg1: u128)\n\t2: Gt\n\t3: BrFalse(7)\nB1:\n\t4: MoveLoc[0](Arg0: u128)\n\t5: StLoc[2](loc0: u128)\n\t6: Branch(9)\nB2:\n\t7: MoveLoc[1](Arg1: u128)\n\t8: StLoc[2](loc0: u128)\nB3:\n\t9: MoveLoc[2](loc0: u128)\n\t10: Ret\n}\n\npublic min(Arg0: u128, Arg1: u128): u128 {\nL2:\tloc0: u128\nB0:\n\t0: CopyLoc[0](Arg0: u128)\n\t1: CopyLoc[1](Arg1: u128)\n\t2: Lt\n\t3: BrFalse(7)\nB1:\n\t4: MoveLoc[0](Arg0: u128)\n\t5: StLoc[2](loc0: u128)\n\t6: Branch(9)\nB2:\n\t7: MoveLoc[1](Arg1: u128)\n\t8: StLoc[2](loc0: u128)\nB3:\n\t9: MoveLoc[2](loc0: u128)\n\t10: Ret\n}\n\npublic wrapping_add(Arg0: u128, Arg1: u128): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: MoveLoc[1](Arg1: u128)\n\t2: Call overflowing_add(u128, u128): u128 * bool\n\t3: Pop\n\t4: Ret\n}\n\npublic overflowing_add(Arg0: u128, Arg1: u128): u128 * bool {\nL2:\tloc0: u128\nL3:\tloc1: bool\nL4:\tloc2: u256\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: CastU256\n\t2: MoveLoc[1](Arg1: u128)\n\t3: CastU256\n\t4: Add\n\t5: StLoc[4](loc2: u256)\n\t6: CopyLoc[4](loc2: u256)\n\t7: LdConst[0](u128: 3402..)\n\t8: CastU256\n\t9: Gt\n\t10: BrFalse(19)\nB1:\n\t11: MoveLoc[4](loc2: u256)\n\t12: LdConst[1](u256: 3402..)\n\t13: BitAnd\n\t14: CastU128\n\t15: LdTrue\n\t16: StLoc[3](loc1: bool)\n\t17: StLoc[2](loc0: u128)\n\t18: Branch(24)\nB2:\n\t19: MoveLoc[4](loc2: u256)\n\t20: CastU128\n\t21: LdFalse\n\t22: StLoc[3](loc1: bool)\n\t23: StLoc[2](loc0: u128)\nB3:\n\t24: MoveLoc[2](loc0: u128)\n\t25: MoveLoc[3](loc1: bool)\n\t26: Ret\n}\n\npublic wrapping_sub(Arg0: u128, Arg1: u128): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: MoveLoc[1](Arg1: u128)\n\t2: Call overflowing_sub(u128, u128): u128 * bool\n\t3: Pop\n\t4: Ret\n}\n\npublic overflowing_sub(Arg0: u128, Arg1: u128): u128 * bool {\nL2:\tloc0: u128\nL3:\tloc1: bool\nB0:\n\t0: CopyLoc[0](Arg0: u128)\n\t1: CopyLoc[1](Arg1: u128)\n\t2: Ge\n\t3: BrFalse(11)\nB1:\n\t4: MoveLoc[0](Arg0: u128)\n\t5: MoveLoc[1](Arg1: u128)\n\t6: Sub\n\t7: LdFalse\n\t8: StLoc[3](loc1: bool)\n\t9: StLoc[2](loc0: u128)\n\t10: Branch(21)\nB2:\n\t11: LdConst[0](u128: 3402..)\n\t12: MoveLoc[1](Arg1: u128)\n\t13: Sub\n\t14: MoveLoc[0](Arg0: u128)\n\t15: Add\n\t16: LdU128(1)\n\t17: Add\n\t18: LdTrue\n\t19: StLoc[3](loc1: bool)\n\t20: StLoc[2](loc0: u128)\nB3:\n\t21: MoveLoc[2](loc0: u128)\n\t22: MoveLoc[3](loc1: bool)\n\t23: Ret\n}\n\nConstants [\n\t0 => u128: 340282366920938463463374607431768211455\n\t1 => u256: 340282366920938463463374607431768211455\n]\n}\n",
      "full_math_u64": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.full_math_u64 {\n\npublic mul_div_floor(Arg0: u64, Arg1: u64, Arg2: u64): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call full_mul(u64, u64): u128\n\t3: MoveLoc[2](Arg2: u64)\n\t4: CastU128\n\t5: Div\n\t6: CastU64\n\t7: Ret\n}\n\npublic mul_div_round(Arg0: u64, Arg1: u64, Arg2: u64): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call full_mul(u64, u64): u128\n\t3: CopyLoc[2](Arg2: u64)\n\t4: CastU128\n\t5: LdU8(1)\n\t6: Shr\n\t7: Add\n\t8: MoveLoc[2](Arg2: u64)\n\t9: CastU128\n\t10: Div\n\t11: CastU64\n\t12: Ret\n}\n\npublic mul_div_ceil(Arg0: u64, Arg1: u64, Arg2: u64): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call full_mul(u64, u64): u128\n\t3: CopyLoc[2](Arg2: u64)\n\t4: CastU128\n\t5: LdU128(1)\n\t6: Sub\n\t7: Add\n\t8: MoveLoc[2](Arg2: u64)\n\t9: CastU128\n\t10: Div\n\t11: CastU64\n\t12: Ret\n}\n\npublic mul_shr(Arg0: u64, Arg1: u64, Arg2: u8): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call full_mul(u64, u64): u128\n\t3: MoveLoc[2](Arg2: u8)\n\t4: Shr\n\t5: CastU64\n\t6: Ret\n}\n\npublic mul_shl(Arg0: u64, Arg1: u64, Arg2: u8): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call full_mul(u64, u64): u128\n\t3: MoveLoc[2](Arg2: u8)\n\t4: Shl\n\t5: CastU64\n\t6: Ret\n}\n\npublic full_mul(Arg0: u64, Arg1: u64): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: CastU128\n\t2: MoveLoc[1](Arg1: u64)\n\t3: CastU128\n\t4: Mul\n\t5: Ret\n}\n\npublic add_check(Arg0: u64, Arg1: u64): bool {\nB0:\n\t0: LdConst[0](u64: 1844..)\n\t1: MoveLoc[0](Arg0: u64)\n\t2: Sub\n\t3: MoveLoc[1](Arg1: u64)\n\t4: Ge\n\t5: Ret\n}\n\nConstants [\n\t0 => u64: 18446744073709551615\n]\n}\n",
      "i128": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.i128 {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i32;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i64;\n\nstruct I128 has copy, drop, store {\n\tbits: u128\n}\n\npublic zero(): I128 {\nB0:\n\t0: LdU128(0)\n\t1: Pack[0](I128)\n\t2: Ret\n}\n\npublic from(Arg0: u128): I128 {\nB0:\n\t0: CopyLoc[0](Arg0: u128)\n\t1: LdConst[2](u128: 1701..)\n\t2: Le\n\t3: BrFalse(5)\nB1:\n\t4: Branch(7)\nB2:\n\t5: LdConst[0](u64: 0)\n\t6: Abort\nB3:\n\t7: MoveLoc[0](Arg0: u128)\n\t8: Pack[0](I128)\n\t9: Ret\n}\n\npublic neg_from(Arg0: u128): I128 {\nL1:\tloc0: I128\nB0:\n\t0: CopyLoc[0](Arg0: u128)\n\t1: LdConst[1](u128: 1701..)\n\t2: Le\n\t3: BrFalse(5)\nB1:\n\t4: Branch(7)\nB2:\n\t5: LdConst[0](u64: 0)\n\t6: Abort\nB3:\n\t7: CopyLoc[0](Arg0: u128)\n\t8: LdU128(0)\n\t9: Eq\n\t10: BrFalse(15)\nB4:\n\t11: MoveLoc[0](Arg0: u128)\n\t12: Pack[0](I128)\n\t13: StLoc[1](loc0: I128)\n\t14: Branch(23)\nB5:\n\t15: MoveLoc[0](Arg0: u128)\n\t16: Call u128_neg(u128): u128\n\t17: LdU128(1)\n\t18: Add\n\t19: LdU128(170141183460469231731687303715884105728)\n\t20: BitOr\n\t21: Pack[0](I128)\n\t22: StLoc[1](loc0: I128)\nB6:\n\t23: MoveLoc[1](loc0: I128)\n\t24: Ret\n}\n\npublic neg(Arg0: I128): I128 {\nL1:\tloc0: I128\nB0:\n\t0: CopyLoc[0](Arg0: I128)\n\t1: Call is_neg(I128): bool\n\t2: BrFalse(7)\nB1:\n\t3: MoveLoc[0](Arg0: I128)\n\t4: Call abs(I128): I128\n\t5: StLoc[1](loc0: I128)\n\t6: Branch(12)\nB2:\n\t7: ImmBorrowLoc[0](Arg0: I128)\n\t8: ImmBorrowField[0](I128.bits: u128)\n\t9: ReadRef\n\t10: Call neg_from(u128): I128\n\t11: StLoc[1](loc0: I128)\nB3:\n\t12: MoveLoc[1](loc0: I128)\n\t13: Ret\n}\n\npublic wrapping_add(Arg0: I128, Arg1: I128): I128 {\nL2:\tloc0: u128\nL3:\tloc1: u128\nL4:\tloc2: u128\nL5:\tloc3: u128\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I128)\n\t1: ImmBorrowField[0](I128.bits: u128)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I128)\n\t4: ImmBorrowField[0](I128.bits: u128)\n\t5: ReadRef\n\t6: Xor\n\t7: StLoc[5](loc3: u128)\n\t8: ImmBorrowLoc[0](Arg0: I128)\n\t9: ImmBorrowField[0](I128.bits: u128)\n\t10: ReadRef\n\t11: ImmBorrowLoc[1](Arg1: I128)\n\t12: ImmBorrowField[0](I128.bits: u128)\n\t13: ReadRef\n\t14: BitAnd\n\t15: LdU8(1)\n\t16: Shl\n\t17: StLoc[4](loc2: u128)\nB1:\n\t18: CopyLoc[4](loc2: u128)\n\t19: LdU128(0)\n\t20: Neq\n\t21: BrFalse(38)\nB2:\n\t22: Branch(23)\nB3:\n\t23: MoveLoc[5](loc3: u128)\n\t24: StLoc[2](loc0: u128)\n\t25: MoveLoc[4](loc2: u128)\n\t26: StLoc[3](loc1: u128)\n\t27: CopyLoc[2](loc0: u128)\n\t28: CopyLoc[3](loc1: u128)\n\t29: Xor\n\t30: StLoc[5](loc3: u128)\n\t31: MoveLoc[2](loc0: u128)\n\t32: MoveLoc[3](loc1: u128)\n\t33: BitAnd\n\t34: LdU8(1)\n\t35: Shl\n\t36: StLoc[4](loc2: u128)\n\t37: Branch(18)\nB4:\n\t38: MoveLoc[5](loc3: u128)\n\t39: Pack[0](I128)\n\t40: Ret\n}\n\npublic add(Arg0: I128, Arg1: I128): I128 {\nL2:\tloc0: I128\nB0:\n\t0: CopyLoc[0](Arg0: I128)\n\t1: CopyLoc[1](Arg1: I128)\n\t2: Call wrapping_add(I128, I128): I128\n\t3: StLoc[2](loc0: I128)\n\t4: CopyLoc[0](Arg0: I128)\n\t5: Call sign(I128): u8\n\t6: CopyLoc[1](Arg1: I128)\n\t7: Call sign(I128): u8\n\t8: BitAnd\n\t9: CopyLoc[2](loc0: I128)\n\t10: Call sign(I128): u8\n\t11: Call u8_neg(u8): u8\n\t12: BitAnd\n\t13: MoveLoc[0](Arg0: I128)\n\t14: Call sign(I128): u8\n\t15: Call u8_neg(u8): u8\n\t16: MoveLoc[1](Arg1: I128)\n\t17: Call sign(I128): u8\n\t18: Call u8_neg(u8): u8\n\t19: BitAnd\n\t20: CopyLoc[2](loc0: I128)\n\t21: Call sign(I128): u8\n\t22: BitAnd\n\t23: Add\n\t24: LdU8(0)\n\t25: Eq\n\t26: BrFalse(28)\nB1:\n\t27: Branch(30)\nB2:\n\t28: LdConst[0](u64: 0)\n\t29: Abort\nB3:\n\t30: MoveLoc[2](loc0: I128)\n\t31: Ret\n}\n\npublic overflowing_add(Arg0: I128, Arg1: I128): I128 * bool {\nL2:\tloc0: u8\nL3:\tloc1: I128\nB0:\n\t0: CopyLoc[0](Arg0: I128)\n\t1: CopyLoc[1](Arg1: I128)\n\t2: Call wrapping_add(I128, I128): I128\n\t3: StLoc[3](loc1: I128)\n\t4: CopyLoc[0](Arg0: I128)\n\t5: Call sign(I128): u8\n\t6: CopyLoc[1](Arg1: I128)\n\t7: Call sign(I128): u8\n\t8: BitAnd\n\t9: CopyLoc[3](loc1: I128)\n\t10: Call sign(I128): u8\n\t11: Call u8_neg(u8): u8\n\t12: BitAnd\n\t13: MoveLoc[0](Arg0: I128)\n\t14: Call sign(I128): u8\n\t15: Call u8_neg(u8): u8\n\t16: MoveLoc[1](Arg1: I128)\n\t17: Call sign(I128): u8\n\t18: Call u8_neg(u8): u8\n\t19: BitAnd\n\t20: CopyLoc[3](loc1: I128)\n\t21: Call sign(I128): u8\n\t22: BitAnd\n\t23: Add\n\t24: StLoc[2](loc0: u8)\n\t25: MoveLoc[3](loc1: I128)\n\t26: MoveLoc[2](loc0: u8)\n\t27: LdU8(0)\n\t28: Neq\n\t29: Ret\n}\n\npublic wrapping_sub(Arg0: I128, Arg1: I128): I128 {\nL2:\tloc0: I128\nB0:\n\t0: ImmBorrowLoc[1](Arg1: I128)\n\t1: ImmBorrowField[0](I128.bits: u128)\n\t2: ReadRef\n\t3: Call u128_neg(u128): u128\n\t4: Pack[0](I128)\n\t5: LdU128(1)\n\t6: Call from(u128): I128\n\t7: Call wrapping_add(I128, I128): I128\n\t8: StLoc[2](loc0: I128)\n\t9: MoveLoc[0](Arg0: I128)\n\t10: MoveLoc[2](loc0: I128)\n\t11: Call wrapping_add(I128, I128): I128\n\t12: Ret\n}\n\npublic sub(Arg0: I128, Arg1: I128): I128 {\nL2:\tloc0: I128\nB0:\n\t0: ImmBorrowLoc[1](Arg1: I128)\n\t1: ImmBorrowField[0](I128.bits: u128)\n\t2: ReadRef\n\t3: Call u128_neg(u128): u128\n\t4: Pack[0](I128)\n\t5: LdU128(1)\n\t6: Call from(u128): I128\n\t7: Call wrapping_add(I128, I128): I128\n\t8: StLoc[2](loc0: I128)\n\t9: MoveLoc[0](Arg0: I128)\n\t10: MoveLoc[2](loc0: I128)\n\t11: Call add(I128, I128): I128\n\t12: Ret\n}\n\npublic overflowing_sub(Arg0: I128, Arg1: I128): I128 * bool {\nL2:\tloc0: u8\nL3:\tloc1: I128\nL4:\tloc2: I128\nB0:\n\t0: ImmBorrowLoc[1](Arg1: I128)\n\t1: ImmBorrowField[0](I128.bits: u128)\n\t2: ReadRef\n\t3: Call u128_neg(u128): u128\n\t4: Pack[0](I128)\n\t5: LdU128(1)\n\t6: Call from(u128): I128\n\t7: Call wrapping_add(I128, I128): I128\n\t8: StLoc[3](loc1: I128)\n\t9: CopyLoc[0](Arg0: I128)\n\t10: CopyLoc[3](loc1: I128)\n\t11: Call wrapping_add(I128, I128): I128\n\t12: StLoc[4](loc2: I128)\n\t13: CopyLoc[0](Arg0: I128)\n\t14: Call sign(I128): u8\n\t15: CopyLoc[3](loc1: I128)\n\t16: Call sign(I128): u8\n\t17: BitAnd\n\t18: CopyLoc[4](loc2: I128)\n\t19: Call sign(I128): u8\n\t20: Call u8_neg(u8): u8\n\t21: BitAnd\n\t22: MoveLoc[0](Arg0: I128)\n\t23: Call sign(I128): u8\n\t24: Call u8_neg(u8): u8\n\t25: MoveLoc[3](loc1: I128)\n\t26: Call sign(I128): u8\n\t27: Call u8_neg(u8): u8\n\t28: BitAnd\n\t29: CopyLoc[4](loc2: I128)\n\t30: Call sign(I128): u8\n\t31: BitAnd\n\t32: Add\n\t33: StLoc[2](loc0: u8)\n\t34: MoveLoc[4](loc2: I128)\n\t35: MoveLoc[2](loc0: u8)\n\t36: LdU8(0)\n\t37: Neq\n\t38: Ret\n}\n\npublic mul(Arg0: I128, Arg1: I128): I128 {\nL2:\tloc0: u128\nB0:\n\t0: CopyLoc[0](Arg0: I128)\n\t1: Call abs_u128(I128): u128\n\t2: CopyLoc[1](Arg1: I128)\n\t3: Call abs_u128(I128): u128\n\t4: Mul\n\t5: StLoc[2](loc0: u128)\n\t6: MoveLoc[0](Arg0: I128)\n\t7: Call sign(I128): u8\n\t8: MoveLoc[1](Arg1: I128)\n\t9: Call sign(I128): u8\n\t10: Neq\n\t11: BrFalse(15)\nB1:\n\t12: MoveLoc[2](loc0: u128)\n\t13: Call neg_from(u128): I128\n\t14: Ret\nB2:\n\t15: MoveLoc[2](loc0: u128)\n\t16: Call from(u128): I128\n\t17: Ret\n}\n\npublic div(Arg0: I128, Arg1: I128): I128 {\nL2:\tloc0: u128\nB0:\n\t0: CopyLoc[0](Arg0: I128)\n\t1: Call abs_u128(I128): u128\n\t2: CopyLoc[1](Arg1: I128)\n\t3: Call abs_u128(I128): u128\n\t4: Div\n\t5: StLoc[2](loc0: u128)\n\t6: MoveLoc[0](Arg0: I128)\n\t7: Call sign(I128): u8\n\t8: MoveLoc[1](Arg1: I128)\n\t9: Call sign(I128): u8\n\t10: Neq\n\t11: BrFalse(15)\nB1:\n\t12: MoveLoc[2](loc0: u128)\n\t13: Call neg_from(u128): I128\n\t14: Ret\nB2:\n\t15: MoveLoc[2](loc0: u128)\n\t16: Call from(u128): I128\n\t17: Ret\n}\n\npublic abs(Arg0: I128): I128 {\nL1:\tloc0: I128\nB0:\n\t0: CopyLoc[0](Arg0: I128)\n\t1: Call sign(I128): u8\n\t2: LdU8(0)\n\t3: Eq\n\t4: BrFalse(8)\nB1:\n\t5: MoveLoc[0](Arg0: I128)\n\t6: StLoc[1](loc0: I128)\n\t7: Branch(25)\nB2:\n\t8: ImmBorrowLoc[0](Arg0: I128)\n\t9: ImmBorrowField[0](I128.bits: u128)\n\t10: ReadRef\n\t11: LdConst[1](u128: 1701..)\n\t12: Gt\n\t13: BrFalse(15)\nB3:\n\t14: Branch(17)\nB4:\n\t15: LdConst[0](u64: 0)\n\t16: Abort\nB5:\n\t17: ImmBorrowLoc[0](Arg0: I128)\n\t18: ImmBorrowField[0](I128.bits: u128)\n\t19: ReadRef\n\t20: LdU128(1)\n\t21: Sub\n\t22: Call u128_neg(u128): u128\n\t23: Pack[0](I128)\n\t24: StLoc[1](loc0: I128)\nB6:\n\t25: MoveLoc[1](loc0: I128)\n\t26: Ret\n}\n\npublic abs_u128(Arg0: I128): u128 {\nL1:\tloc0: u128\nB0:\n\t0: CopyLoc[0](Arg0: I128)\n\t1: Call sign(I128): u8\n\t2: LdU8(0)\n\t3: Eq\n\t4: BrFalse(10)\nB1:\n\t5: ImmBorrowLoc[0](Arg0: I128)\n\t6: ImmBorrowField[0](I128.bits: u128)\n\t7: ReadRef\n\t8: StLoc[1](loc0: u128)\n\t9: Branch(17)\nB2:\n\t10: ImmBorrowLoc[0](Arg0: I128)\n\t11: ImmBorrowField[0](I128.bits: u128)\n\t12: ReadRef\n\t13: LdU128(1)\n\t14: Sub\n\t15: Call u128_neg(u128): u128\n\t16: StLoc[1](loc0: u128)\nB3:\n\t17: MoveLoc[1](loc0: u128)\n\t18: Ret\n}\n\npublic shl(Arg0: I128, Arg1: u8): I128 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I128)\n\t1: ImmBorrowField[0](I128.bits: u128)\n\t2: ReadRef\n\t3: MoveLoc[1](Arg1: u8)\n\t4: Shl\n\t5: Pack[0](I128)\n\t6: Ret\n}\n\npublic shr(Arg0: I128, Arg1: u8): I128 {\nL2:\tloc0: u128\nB0:\n\t0: CopyLoc[1](Arg1: u8)\n\t1: LdU8(0)\n\t2: Eq\n\t3: BrFalse(6)\nB1:\n\t4: MoveLoc[0](Arg0: I128)\n\t5: Ret\nB2:\n\t6: LdU128(340282366920938463463374607431768211455)\n\t7: LdU8(128)\n\t8: CopyLoc[1](Arg1: u8)\n\t9: Sub\n\t10: Shl\n\t11: StLoc[2](loc0: u128)\n\t12: CopyLoc[0](Arg0: I128)\n\t13: Call sign(I128): u8\n\t14: LdU8(1)\n\t15: Eq\n\t16: BrFalse(26)\nB3:\n\t17: ImmBorrowLoc[0](Arg0: I128)\n\t18: ImmBorrowField[0](I128.bits: u128)\n\t19: ReadRef\n\t20: MoveLoc[1](Arg1: u8)\n\t21: Shr\n\t22: MoveLoc[2](loc0: u128)\n\t23: BitOr\n\t24: Pack[0](I128)\n\t25: Ret\nB4:\n\t26: ImmBorrowLoc[0](Arg0: I128)\n\t27: ImmBorrowField[0](I128.bits: u128)\n\t28: ReadRef\n\t29: MoveLoc[1](Arg1: u8)\n\t30: Shr\n\t31: Pack[0](I128)\n\t32: Ret\n}\n\npublic as_u128(Arg0: I128): u128 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I128)\n\t1: ImmBorrowField[0](I128.bits: u128)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic as_i64(Arg0: I128): I64 {\nB0:\n\t0: CopyLoc[0](Arg0: I128)\n\t1: Call is_neg(I128): bool\n\t2: BrFalse(8)\nB1:\n\t3: MoveLoc[0](Arg0: I128)\n\t4: Call abs_u128(I128): u128\n\t5: CastU64\n\t6: Call i64::neg_from(u64): I64\n\t7: Ret\nB2:\n\t8: MoveLoc[0](Arg0: I128)\n\t9: Call abs_u128(I128): u128\n\t10: CastU64\n\t11: Call i64::from(u64): I64\n\t12: Ret\n}\n\npublic as_i32(Arg0: I128): I32 {\nB0:\n\t0: CopyLoc[0](Arg0: I128)\n\t1: Call is_neg(I128): bool\n\t2: BrFalse(8)\nB1:\n\t3: MoveLoc[0](Arg0: I128)\n\t4: Call abs_u128(I128): u128\n\t5: CastU32\n\t6: Call i32::neg_from(u32): I32\n\t7: Ret\nB2:\n\t8: MoveLoc[0](Arg0: I128)\n\t9: Call abs_u128(I128): u128\n\t10: CastU32\n\t11: Call i32::from(u32): I32\n\t12: Ret\n}\n\npublic sign(Arg0: I128): u8 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I128)\n\t1: ImmBorrowField[0](I128.bits: u128)\n\t2: ReadRef\n\t3: LdU8(127)\n\t4: Shr\n\t5: CastU8\n\t6: Ret\n}\n\npublic is_neg(Arg0: I128): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I128)\n\t1: Call sign(I128): u8\n\t2: LdU8(1)\n\t3: Eq\n\t4: Ret\n}\n\npublic cmp(Arg0: I128, Arg1: I128): u8 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I128)\n\t1: ImmBorrowField[0](I128.bits: u128)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I128)\n\t4: ImmBorrowField[0](I128.bits: u128)\n\t5: ReadRef\n\t6: Eq\n\t7: BrFalse(10)\nB1:\n\t8: LdConst[4](u8: 1)\n\t9: Ret\nB2:\n\t10: CopyLoc[0](Arg0: I128)\n\t11: Call sign(I128): u8\n\t12: CopyLoc[1](Arg1: I128)\n\t13: Call sign(I128): u8\n\t14: Gt\n\t15: BrFalse(18)\nB3:\n\t16: LdConst[3](u8: 0)\n\t17: Ret\nB4:\n\t18: CopyLoc[0](Arg0: I128)\n\t19: Call sign(I128): u8\n\t20: CopyLoc[1](Arg1: I128)\n\t21: Call sign(I128): u8\n\t22: Lt\n\t23: BrFalse(26)\nB5:\n\t24: LdConst[5](u8: 2)\n\t25: Ret\nB6:\n\t26: ImmBorrowLoc[0](Arg0: I128)\n\t27: ImmBorrowField[0](I128.bits: u128)\n\t28: ReadRef\n\t29: ImmBorrowLoc[1](Arg1: I128)\n\t30: ImmBorrowField[0](I128.bits: u128)\n\t31: ReadRef\n\t32: Gt\n\t33: BrFalse(36)\nB7:\n\t34: LdConst[5](u8: 2)\n\t35: Ret\nB8:\n\t36: LdConst[3](u8: 0)\n\t37: Ret\n}\n\npublic eq(Arg0: I128, Arg1: I128): bool {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I128)\n\t1: ImmBorrowField[0](I128.bits: u128)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I128)\n\t4: ImmBorrowField[0](I128.bits: u128)\n\t5: ReadRef\n\t6: Eq\n\t7: Ret\n}\n\npublic gt(Arg0: I128, Arg1: I128): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I128)\n\t1: MoveLoc[1](Arg1: I128)\n\t2: Call cmp(I128, I128): u8\n\t3: LdConst[5](u8: 2)\n\t4: Eq\n\t5: Ret\n}\n\npublic gte(Arg0: I128, Arg1: I128): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I128)\n\t1: MoveLoc[1](Arg1: I128)\n\t2: Call cmp(I128, I128): u8\n\t3: LdConst[4](u8: 1)\n\t4: Ge\n\t5: Ret\n}\n\npublic lt(Arg0: I128, Arg1: I128): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I128)\n\t1: MoveLoc[1](Arg1: I128)\n\t2: Call cmp(I128, I128): u8\n\t3: LdConst[3](u8: 0)\n\t4: Eq\n\t5: Ret\n}\n\npublic lte(Arg0: I128, Arg1: I128): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I128)\n\t1: MoveLoc[1](Arg1: I128)\n\t2: Call cmp(I128, I128): u8\n\t3: LdConst[4](u8: 1)\n\t4: Le\n\t5: Ret\n}\n\npublic or(Arg0: I128, Arg1: I128): I128 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I128)\n\t1: ImmBorrowField[0](I128.bits: u128)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I128)\n\t4: ImmBorrowField[0](I128.bits: u128)\n\t5: ReadRef\n\t6: BitOr\n\t7: Pack[0](I128)\n\t8: Ret\n}\n\npublic and(Arg0: I128, Arg1: I128): I128 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I128)\n\t1: ImmBorrowField[0](I128.bits: u128)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I128)\n\t4: ImmBorrowField[0](I128.bits: u128)\n\t5: ReadRef\n\t6: BitAnd\n\t7: Pack[0](I128)\n\t8: Ret\n}\n\nu128_neg(Arg0: u128): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: LdU128(340282366920938463463374607431768211455)\n\t2: Xor\n\t3: Ret\n}\n\nu8_neg(Arg0: u8): u8 {\nB0:\n\t0: MoveLoc[0](Arg0: u8)\n\t1: LdU8(255)\n\t2: Xor\n\t3: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u128: 170141183460469231731687303715884105728\n\t2 => u128: 170141183460469231731687303715884105727\n\t3 => u8: 0\n\t4 => u8: 1\n\t5 => u8: 2\n]\n}\n",
      "i32": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.i32 {\n\nstruct I32 has copy, drop, store {\n\tbits: u32\n}\n\npublic zero(): I32 {\nB0:\n\t0: LdU32(0)\n\t1: Pack[0](I32)\n\t2: Ret\n}\n\npublic from_u32(Arg0: u32): I32 {\nB0:\n\t0: MoveLoc[0](Arg0: u32)\n\t1: Pack[0](I32)\n\t2: Ret\n}\n\npublic from(Arg0: u32): I32 {\nB0:\n\t0: CopyLoc[0](Arg0: u32)\n\t1: LdConst[2](u32: 2147..)\n\t2: Le\n\t3: BrFalse(5)\nB1:\n\t4: Branch(7)\nB2:\n\t5: LdConst[0](u64: 0)\n\t6: Abort\nB3:\n\t7: MoveLoc[0](Arg0: u32)\n\t8: Pack[0](I32)\n\t9: Ret\n}\n\npublic neg_from(Arg0: u32): I32 {\nL1:\tloc0: I32\nB0:\n\t0: CopyLoc[0](Arg0: u32)\n\t1: LdConst[1](u32: 2147..)\n\t2: Le\n\t3: BrFalse(5)\nB1:\n\t4: Branch(7)\nB2:\n\t5: LdConst[0](u64: 0)\n\t6: Abort\nB3:\n\t7: CopyLoc[0](Arg0: u32)\n\t8: LdU32(0)\n\t9: Eq\n\t10: BrFalse(15)\nB4:\n\t11: MoveLoc[0](Arg0: u32)\n\t12: Pack[0](I32)\n\t13: StLoc[1](loc0: I32)\n\t14: Branch(23)\nB5:\n\t15: MoveLoc[0](Arg0: u32)\n\t16: Call u32_neg(u32): u32\n\t17: LdU32(1)\n\t18: Add\n\t19: LdU32(2147483648)\n\t20: BitOr\n\t21: Pack[0](I32)\n\t22: StLoc[1](loc0: I32)\nB6:\n\t23: MoveLoc[1](loc0: I32)\n\t24: Ret\n}\n\npublic wrapping_add(Arg0: I32, Arg1: I32): I32 {\nL2:\tloc0: u32\nL3:\tloc1: u32\nL4:\tloc2: u32\nL5:\tloc3: u32\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I32)\n\t1: ImmBorrowField[0](I32.bits: u32)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I32)\n\t4: ImmBorrowField[0](I32.bits: u32)\n\t5: ReadRef\n\t6: Xor\n\t7: StLoc[5](loc3: u32)\n\t8: ImmBorrowLoc[0](Arg0: I32)\n\t9: ImmBorrowField[0](I32.bits: u32)\n\t10: ReadRef\n\t11: ImmBorrowLoc[1](Arg1: I32)\n\t12: ImmBorrowField[0](I32.bits: u32)\n\t13: ReadRef\n\t14: BitAnd\n\t15: LdU8(1)\n\t16: Shl\n\t17: StLoc[4](loc2: u32)\nB1:\n\t18: CopyLoc[4](loc2: u32)\n\t19: LdU32(0)\n\t20: Neq\n\t21: BrFalse(38)\nB2:\n\t22: Branch(23)\nB3:\n\t23: MoveLoc[5](loc3: u32)\n\t24: StLoc[2](loc0: u32)\n\t25: MoveLoc[4](loc2: u32)\n\t26: StLoc[3](loc1: u32)\n\t27: CopyLoc[2](loc0: u32)\n\t28: CopyLoc[3](loc1: u32)\n\t29: Xor\n\t30: StLoc[5](loc3: u32)\n\t31: MoveLoc[2](loc0: u32)\n\t32: MoveLoc[3](loc1: u32)\n\t33: BitAnd\n\t34: LdU8(1)\n\t35: Shl\n\t36: StLoc[4](loc2: u32)\n\t37: Branch(18)\nB4:\n\t38: MoveLoc[5](loc3: u32)\n\t39: Pack[0](I32)\n\t40: Ret\n}\n\npublic add(Arg0: I32, Arg1: I32): I32 {\nL2:\tloc0: I32\nB0:\n\t0: CopyLoc[0](Arg0: I32)\n\t1: CopyLoc[1](Arg1: I32)\n\t2: Call wrapping_add(I32, I32): I32\n\t3: StLoc[2](loc0: I32)\n\t4: CopyLoc[0](Arg0: I32)\n\t5: Call sign(I32): u8\n\t6: CopyLoc[1](Arg1: I32)\n\t7: Call sign(I32): u8\n\t8: BitAnd\n\t9: CopyLoc[2](loc0: I32)\n\t10: Call sign(I32): u8\n\t11: Call u8_neg(u8): u8\n\t12: BitAnd\n\t13: MoveLoc[0](Arg0: I32)\n\t14: Call sign(I32): u8\n\t15: Call u8_neg(u8): u8\n\t16: MoveLoc[1](Arg1: I32)\n\t17: Call sign(I32): u8\n\t18: Call u8_neg(u8): u8\n\t19: BitAnd\n\t20: CopyLoc[2](loc0: I32)\n\t21: Call sign(I32): u8\n\t22: BitAnd\n\t23: Add\n\t24: LdU8(0)\n\t25: Eq\n\t26: BrFalse(28)\nB1:\n\t27: Branch(30)\nB2:\n\t28: LdConst[0](u64: 0)\n\t29: Abort\nB3:\n\t30: MoveLoc[2](loc0: I32)\n\t31: Ret\n}\n\npublic wrapping_sub(Arg0: I32, Arg1: I32): I32 {\nL2:\tloc0: I32\nB0:\n\t0: ImmBorrowLoc[1](Arg1: I32)\n\t1: ImmBorrowField[0](I32.bits: u32)\n\t2: ReadRef\n\t3: Call u32_neg(u32): u32\n\t4: Pack[0](I32)\n\t5: LdU32(1)\n\t6: Call from(u32): I32\n\t7: Call wrapping_add(I32, I32): I32\n\t8: StLoc[2](loc0: I32)\n\t9: MoveLoc[0](Arg0: I32)\n\t10: MoveLoc[2](loc0: I32)\n\t11: Call wrapping_add(I32, I32): I32\n\t12: Ret\n}\n\npublic sub(Arg0: I32, Arg1: I32): I32 {\nL2:\tloc0: I32\nB0:\n\t0: ImmBorrowLoc[1](Arg1: I32)\n\t1: ImmBorrowField[0](I32.bits: u32)\n\t2: ReadRef\n\t3: Call u32_neg(u32): u32\n\t4: Pack[0](I32)\n\t5: LdU32(1)\n\t6: Call from(u32): I32\n\t7: Call wrapping_add(I32, I32): I32\n\t8: StLoc[2](loc0: I32)\n\t9: MoveLoc[0](Arg0: I32)\n\t10: MoveLoc[2](loc0: I32)\n\t11: Call add(I32, I32): I32\n\t12: Ret\n}\n\npublic mul(Arg0: I32, Arg1: I32): I32 {\nL2:\tloc0: u32\nB0:\n\t0: CopyLoc[0](Arg0: I32)\n\t1: Call abs_u32(I32): u32\n\t2: CopyLoc[1](Arg1: I32)\n\t3: Call abs_u32(I32): u32\n\t4: Mul\n\t5: StLoc[2](loc0: u32)\n\t6: MoveLoc[0](Arg0: I32)\n\t7: Call sign(I32): u8\n\t8: MoveLoc[1](Arg1: I32)\n\t9: Call sign(I32): u8\n\t10: Neq\n\t11: BrFalse(15)\nB1:\n\t12: MoveLoc[2](loc0: u32)\n\t13: Call neg_from(u32): I32\n\t14: Ret\nB2:\n\t15: MoveLoc[2](loc0: u32)\n\t16: Call from(u32): I32\n\t17: Ret\n}\n\npublic div(Arg0: I32, Arg1: I32): I32 {\nL2:\tloc0: u32\nB0:\n\t0: CopyLoc[0](Arg0: I32)\n\t1: Call abs_u32(I32): u32\n\t2: CopyLoc[1](Arg1: I32)\n\t3: Call abs_u32(I32): u32\n\t4: Div\n\t5: StLoc[2](loc0: u32)\n\t6: MoveLoc[0](Arg0: I32)\n\t7: Call sign(I32): u8\n\t8: MoveLoc[1](Arg1: I32)\n\t9: Call sign(I32): u8\n\t10: Neq\n\t11: BrFalse(15)\nB1:\n\t12: MoveLoc[2](loc0: u32)\n\t13: Call neg_from(u32): I32\n\t14: Ret\nB2:\n\t15: MoveLoc[2](loc0: u32)\n\t16: Call from(u32): I32\n\t17: Ret\n}\n\npublic abs(Arg0: I32): I32 {\nL1:\tloc0: I32\nB0:\n\t0: CopyLoc[0](Arg0: I32)\n\t1: Call sign(I32): u8\n\t2: LdU8(0)\n\t3: Eq\n\t4: BrFalse(8)\nB1:\n\t5: MoveLoc[0](Arg0: I32)\n\t6: StLoc[1](loc0: I32)\n\t7: Branch(25)\nB2:\n\t8: ImmBorrowLoc[0](Arg0: I32)\n\t9: ImmBorrowField[0](I32.bits: u32)\n\t10: ReadRef\n\t11: LdConst[1](u32: 2147..)\n\t12: Gt\n\t13: BrFalse(15)\nB3:\n\t14: Branch(17)\nB4:\n\t15: LdConst[0](u64: 0)\n\t16: Abort\nB5:\n\t17: ImmBorrowLoc[0](Arg0: I32)\n\t18: ImmBorrowField[0](I32.bits: u32)\n\t19: ReadRef\n\t20: LdU32(1)\n\t21: Sub\n\t22: Call u32_neg(u32): u32\n\t23: Pack[0](I32)\n\t24: StLoc[1](loc0: I32)\nB6:\n\t25: MoveLoc[1](loc0: I32)\n\t26: Ret\n}\n\npublic abs_u32(Arg0: I32): u32 {\nL1:\tloc0: u32\nB0:\n\t0: CopyLoc[0](Arg0: I32)\n\t1: Call sign(I32): u8\n\t2: LdU8(0)\n\t3: Eq\n\t4: BrFalse(10)\nB1:\n\t5: ImmBorrowLoc[0](Arg0: I32)\n\t6: ImmBorrowField[0](I32.bits: u32)\n\t7: ReadRef\n\t8: StLoc[1](loc0: u32)\n\t9: Branch(17)\nB2:\n\t10: ImmBorrowLoc[0](Arg0: I32)\n\t11: ImmBorrowField[0](I32.bits: u32)\n\t12: ReadRef\n\t13: LdU32(1)\n\t14: Sub\n\t15: Call u32_neg(u32): u32\n\t16: StLoc[1](loc0: u32)\nB3:\n\t17: MoveLoc[1](loc0: u32)\n\t18: Ret\n}\n\npublic shl(Arg0: I32, Arg1: u8): I32 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I32)\n\t1: ImmBorrowField[0](I32.bits: u32)\n\t2: ReadRef\n\t3: MoveLoc[1](Arg1: u8)\n\t4: Shl\n\t5: Pack[0](I32)\n\t6: Ret\n}\n\npublic shr(Arg0: I32, Arg1: u8): I32 {\nL2:\tloc0: u32\nB0:\n\t0: CopyLoc[1](Arg1: u8)\n\t1: LdU8(0)\n\t2: Eq\n\t3: BrFalse(6)\nB1:\n\t4: MoveLoc[0](Arg0: I32)\n\t5: Ret\nB2:\n\t6: LdU32(4294967295)\n\t7: LdU8(32)\n\t8: CopyLoc[1](Arg1: u8)\n\t9: Sub\n\t10: Shl\n\t11: StLoc[2](loc0: u32)\n\t12: CopyLoc[0](Arg0: I32)\n\t13: Call sign(I32): u8\n\t14: LdU8(1)\n\t15: Eq\n\t16: BrFalse(26)\nB3:\n\t17: ImmBorrowLoc[0](Arg0: I32)\n\t18: ImmBorrowField[0](I32.bits: u32)\n\t19: ReadRef\n\t20: MoveLoc[1](Arg1: u8)\n\t21: Shr\n\t22: MoveLoc[2](loc0: u32)\n\t23: BitOr\n\t24: Pack[0](I32)\n\t25: Ret\nB4:\n\t26: ImmBorrowLoc[0](Arg0: I32)\n\t27: ImmBorrowField[0](I32.bits: u32)\n\t28: ReadRef\n\t29: MoveLoc[1](Arg1: u8)\n\t30: Shr\n\t31: Pack[0](I32)\n\t32: Ret\n}\n\npublic mod(Arg0: I32, Arg1: I32): I32 {\nL2:\tloc0: I32\nB0:\n\t0: CopyLoc[0](Arg0: I32)\n\t1: Call sign(I32): u8\n\t2: LdU8(1)\n\t3: Eq\n\t4: BrFalse(13)\nB1:\n\t5: MoveLoc[0](Arg0: I32)\n\t6: Call abs_u32(I32): u32\n\t7: MoveLoc[1](Arg1: I32)\n\t8: Call abs_u32(I32): u32\n\t9: Mod\n\t10: Call neg_from(u32): I32\n\t11: StLoc[2](loc0: I32)\n\t12: Branch(20)\nB2:\n\t13: MoveLoc[0](Arg0: I32)\n\t14: Call as_u32(I32): u32\n\t15: MoveLoc[1](Arg1: I32)\n\t16: Call abs_u32(I32): u32\n\t17: Mod\n\t18: Call from(u32): I32\n\t19: StLoc[2](loc0: I32)\nB3:\n\t20: MoveLoc[2](loc0: I32)\n\t21: Ret\n}\n\npublic as_u32(Arg0: I32): u32 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I32)\n\t1: ImmBorrowField[0](I32.bits: u32)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic sign(Arg0: I32): u8 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I32)\n\t1: ImmBorrowField[0](I32.bits: u32)\n\t2: ReadRef\n\t3: LdU8(31)\n\t4: Shr\n\t5: CastU8\n\t6: Ret\n}\n\npublic is_neg(Arg0: I32): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I32)\n\t1: Call sign(I32): u8\n\t2: LdU8(1)\n\t3: Eq\n\t4: Ret\n}\n\npublic cmp(Arg0: I32, Arg1: I32): u8 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I32)\n\t1: ImmBorrowField[0](I32.bits: u32)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I32)\n\t4: ImmBorrowField[0](I32.bits: u32)\n\t5: ReadRef\n\t6: Eq\n\t7: BrFalse(10)\nB1:\n\t8: LdConst[4](u8: 1)\n\t9: Ret\nB2:\n\t10: CopyLoc[0](Arg0: I32)\n\t11: Call sign(I32): u8\n\t12: CopyLoc[1](Arg1: I32)\n\t13: Call sign(I32): u8\n\t14: Gt\n\t15: BrFalse(18)\nB3:\n\t16: LdConst[3](u8: 0)\n\t17: Ret\nB4:\n\t18: CopyLoc[0](Arg0: I32)\n\t19: Call sign(I32): u8\n\t20: CopyLoc[1](Arg1: I32)\n\t21: Call sign(I32): u8\n\t22: Lt\n\t23: BrFalse(26)\nB5:\n\t24: LdConst[5](u8: 2)\n\t25: Ret\nB6:\n\t26: ImmBorrowLoc[0](Arg0: I32)\n\t27: ImmBorrowField[0](I32.bits: u32)\n\t28: ReadRef\n\t29: ImmBorrowLoc[1](Arg1: I32)\n\t30: ImmBorrowField[0](I32.bits: u32)\n\t31: ReadRef\n\t32: Gt\n\t33: BrFalse(36)\nB7:\n\t34: LdConst[5](u8: 2)\n\t35: Ret\nB8:\n\t36: LdConst[3](u8: 0)\n\t37: Ret\n}\n\npublic eq(Arg0: I32, Arg1: I32): bool {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I32)\n\t1: ImmBorrowField[0](I32.bits: u32)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I32)\n\t4: ImmBorrowField[0](I32.bits: u32)\n\t5: ReadRef\n\t6: Eq\n\t7: Ret\n}\n\npublic gt(Arg0: I32, Arg1: I32): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I32)\n\t1: MoveLoc[1](Arg1: I32)\n\t2: Call cmp(I32, I32): u8\n\t3: LdConst[5](u8: 2)\n\t4: Eq\n\t5: Ret\n}\n\npublic gte(Arg0: I32, Arg1: I32): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I32)\n\t1: MoveLoc[1](Arg1: I32)\n\t2: Call cmp(I32, I32): u8\n\t3: LdConst[4](u8: 1)\n\t4: Ge\n\t5: Ret\n}\n\npublic lt(Arg0: I32, Arg1: I32): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I32)\n\t1: MoveLoc[1](Arg1: I32)\n\t2: Call cmp(I32, I32): u8\n\t3: LdConst[3](u8: 0)\n\t4: Eq\n\t5: Ret\n}\n\npublic lte(Arg0: I32, Arg1: I32): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I32)\n\t1: MoveLoc[1](Arg1: I32)\n\t2: Call cmp(I32, I32): u8\n\t3: LdConst[4](u8: 1)\n\t4: Le\n\t5: Ret\n}\n\npublic or(Arg0: I32, Arg1: I32): I32 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I32)\n\t1: ImmBorrowField[0](I32.bits: u32)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I32)\n\t4: ImmBorrowField[0](I32.bits: u32)\n\t5: ReadRef\n\t6: BitOr\n\t7: Pack[0](I32)\n\t8: Ret\n}\n\npublic and(Arg0: I32, Arg1: I32): I32 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I32)\n\t1: ImmBorrowField[0](I32.bits: u32)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I32)\n\t4: ImmBorrowField[0](I32.bits: u32)\n\t5: ReadRef\n\t6: BitAnd\n\t7: Pack[0](I32)\n\t8: Ret\n}\n\nu32_neg(Arg0: u32): u32 {\nB0:\n\t0: MoveLoc[0](Arg0: u32)\n\t1: LdU32(4294967295)\n\t2: Xor\n\t3: Ret\n}\n\nu8_neg(Arg0: u8): u8 {\nB0:\n\t0: MoveLoc[0](Arg0: u8)\n\t1: LdU8(255)\n\t2: Xor\n\t3: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u32: 2147483648\n\t2 => u32: 2147483647\n\t3 => u8: 0\n\t4 => u8: 1\n\t5 => u8: 2\n]\n}\n",
      "i64": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.i64 {\n\nstruct I64 has copy, drop, store {\n\tbits: u64\n}\n\npublic zero(): I64 {\nB0:\n\t0: LdU64(0)\n\t1: Pack[0](I64)\n\t2: Ret\n}\n\npublic from_u64(Arg0: u64): I64 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: Pack[0](I64)\n\t2: Ret\n}\n\npublic from(Arg0: u64): I64 {\nB0:\n\t0: CopyLoc[0](Arg0: u64)\n\t1: LdConst[2](u64: 9223..)\n\t2: Le\n\t3: BrFalse(5)\nB1:\n\t4: Branch(7)\nB2:\n\t5: LdConst[0](u64: 0)\n\t6: Abort\nB3:\n\t7: MoveLoc[0](Arg0: u64)\n\t8: Pack[0](I64)\n\t9: Ret\n}\n\npublic neg_from(Arg0: u64): I64 {\nL1:\tloc0: I64\nB0:\n\t0: CopyLoc[0](Arg0: u64)\n\t1: LdConst[1](u64: 9223..)\n\t2: Le\n\t3: BrFalse(5)\nB1:\n\t4: Branch(7)\nB2:\n\t5: LdConst[0](u64: 0)\n\t6: Abort\nB3:\n\t7: CopyLoc[0](Arg0: u64)\n\t8: LdU64(0)\n\t9: Eq\n\t10: BrFalse(15)\nB4:\n\t11: MoveLoc[0](Arg0: u64)\n\t12: Pack[0](I64)\n\t13: StLoc[1](loc0: I64)\n\t14: Branch(23)\nB5:\n\t15: MoveLoc[0](Arg0: u64)\n\t16: Call u64_neg(u64): u64\n\t17: LdU64(1)\n\t18: Add\n\t19: LdU64(9223372036854775808)\n\t20: BitOr\n\t21: Pack[0](I64)\n\t22: StLoc[1](loc0: I64)\nB6:\n\t23: MoveLoc[1](loc0: I64)\n\t24: Ret\n}\n\npublic wrapping_add(Arg0: I64, Arg1: I64): I64 {\nL2:\tloc0: u64\nL3:\tloc1: u64\nL4:\tloc2: u64\nL5:\tloc3: u64\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I64)\n\t1: ImmBorrowField[0](I64.bits: u64)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I64)\n\t4: ImmBorrowField[0](I64.bits: u64)\n\t5: ReadRef\n\t6: Xor\n\t7: StLoc[5](loc3: u64)\n\t8: ImmBorrowLoc[0](Arg0: I64)\n\t9: ImmBorrowField[0](I64.bits: u64)\n\t10: ReadRef\n\t11: ImmBorrowLoc[1](Arg1: I64)\n\t12: ImmBorrowField[0](I64.bits: u64)\n\t13: ReadRef\n\t14: BitAnd\n\t15: LdU8(1)\n\t16: Shl\n\t17: StLoc[4](loc2: u64)\nB1:\n\t18: CopyLoc[4](loc2: u64)\n\t19: LdU64(0)\n\t20: Neq\n\t21: BrFalse(38)\nB2:\n\t22: Branch(23)\nB3:\n\t23: MoveLoc[5](loc3: u64)\n\t24: StLoc[2](loc0: u64)\n\t25: MoveLoc[4](loc2: u64)\n\t26: StLoc[3](loc1: u64)\n\t27: CopyLoc[2](loc0: u64)\n\t28: CopyLoc[3](loc1: u64)\n\t29: Xor\n\t30: StLoc[5](loc3: u64)\n\t31: MoveLoc[2](loc0: u64)\n\t32: MoveLoc[3](loc1: u64)\n\t33: BitAnd\n\t34: LdU8(1)\n\t35: Shl\n\t36: StLoc[4](loc2: u64)\n\t37: Branch(18)\nB4:\n\t38: MoveLoc[5](loc3: u64)\n\t39: Pack[0](I64)\n\t40: Ret\n}\n\npublic add(Arg0: I64, Arg1: I64): I64 {\nL2:\tloc0: I64\nB0:\n\t0: CopyLoc[0](Arg0: I64)\n\t1: CopyLoc[1](Arg1: I64)\n\t2: Call wrapping_add(I64, I64): I64\n\t3: StLoc[2](loc0: I64)\n\t4: CopyLoc[0](Arg0: I64)\n\t5: Call sign(I64): u8\n\t6: CopyLoc[1](Arg1: I64)\n\t7: Call sign(I64): u8\n\t8: BitAnd\n\t9: CopyLoc[2](loc0: I64)\n\t10: Call sign(I64): u8\n\t11: Call u8_neg(u8): u8\n\t12: BitAnd\n\t13: MoveLoc[0](Arg0: I64)\n\t14: Call sign(I64): u8\n\t15: Call u8_neg(u8): u8\n\t16: MoveLoc[1](Arg1: I64)\n\t17: Call sign(I64): u8\n\t18: Call u8_neg(u8): u8\n\t19: BitAnd\n\t20: CopyLoc[2](loc0: I64)\n\t21: Call sign(I64): u8\n\t22: BitAnd\n\t23: Add\n\t24: LdU8(0)\n\t25: Eq\n\t26: BrFalse(28)\nB1:\n\t27: Branch(30)\nB2:\n\t28: LdConst[0](u64: 0)\n\t29: Abort\nB3:\n\t30: MoveLoc[2](loc0: I64)\n\t31: Ret\n}\n\npublic wrapping_sub(Arg0: I64, Arg1: I64): I64 {\nL2:\tloc0: I64\nB0:\n\t0: ImmBorrowLoc[1](Arg1: I64)\n\t1: ImmBorrowField[0](I64.bits: u64)\n\t2: ReadRef\n\t3: Call u64_neg(u64): u64\n\t4: Pack[0](I64)\n\t5: LdU64(1)\n\t6: Call from(u64): I64\n\t7: Call wrapping_add(I64, I64): I64\n\t8: StLoc[2](loc0: I64)\n\t9: MoveLoc[0](Arg0: I64)\n\t10: MoveLoc[2](loc0: I64)\n\t11: Call wrapping_add(I64, I64): I64\n\t12: Ret\n}\n\npublic sub(Arg0: I64, Arg1: I64): I64 {\nL2:\tloc0: I64\nB0:\n\t0: ImmBorrowLoc[1](Arg1: I64)\n\t1: ImmBorrowField[0](I64.bits: u64)\n\t2: ReadRef\n\t3: Call u64_neg(u64): u64\n\t4: Pack[0](I64)\n\t5: LdU64(1)\n\t6: Call from(u64): I64\n\t7: Call wrapping_add(I64, I64): I64\n\t8: StLoc[2](loc0: I64)\n\t9: MoveLoc[0](Arg0: I64)\n\t10: MoveLoc[2](loc0: I64)\n\t11: Call add(I64, I64): I64\n\t12: Ret\n}\n\npublic mul(Arg0: I64, Arg1: I64): I64 {\nL2:\tloc0: u64\nB0:\n\t0: CopyLoc[0](Arg0: I64)\n\t1: Call abs_u64(I64): u64\n\t2: CopyLoc[1](Arg1: I64)\n\t3: Call abs_u64(I64): u64\n\t4: Mul\n\t5: StLoc[2](loc0: u64)\n\t6: MoveLoc[0](Arg0: I64)\n\t7: Call sign(I64): u8\n\t8: MoveLoc[1](Arg1: I64)\n\t9: Call sign(I64): u8\n\t10: Neq\n\t11: BrFalse(15)\nB1:\n\t12: MoveLoc[2](loc0: u64)\n\t13: Call neg_from(u64): I64\n\t14: Ret\nB2:\n\t15: MoveLoc[2](loc0: u64)\n\t16: Call from(u64): I64\n\t17: Ret\n}\n\npublic div(Arg0: I64, Arg1: I64): I64 {\nL2:\tloc0: u64\nB0:\n\t0: CopyLoc[0](Arg0: I64)\n\t1: Call abs_u64(I64): u64\n\t2: CopyLoc[1](Arg1: I64)\n\t3: Call abs_u64(I64): u64\n\t4: Div\n\t5: StLoc[2](loc0: u64)\n\t6: MoveLoc[0](Arg0: I64)\n\t7: Call sign(I64): u8\n\t8: MoveLoc[1](Arg1: I64)\n\t9: Call sign(I64): u8\n\t10: Neq\n\t11: BrFalse(15)\nB1:\n\t12: MoveLoc[2](loc0: u64)\n\t13: Call neg_from(u64): I64\n\t14: Ret\nB2:\n\t15: MoveLoc[2](loc0: u64)\n\t16: Call from(u64): I64\n\t17: Ret\n}\n\npublic abs(Arg0: I64): I64 {\nL1:\tloc0: I64\nB0:\n\t0: CopyLoc[0](Arg0: I64)\n\t1: Call sign(I64): u8\n\t2: LdU8(0)\n\t3: Eq\n\t4: BrFalse(8)\nB1:\n\t5: MoveLoc[0](Arg0: I64)\n\t6: StLoc[1](loc0: I64)\n\t7: Branch(25)\nB2:\n\t8: ImmBorrowLoc[0](Arg0: I64)\n\t9: ImmBorrowField[0](I64.bits: u64)\n\t10: ReadRef\n\t11: LdConst[1](u64: 9223..)\n\t12: Gt\n\t13: BrFalse(15)\nB3:\n\t14: Branch(17)\nB4:\n\t15: LdConst[0](u64: 0)\n\t16: Abort\nB5:\n\t17: ImmBorrowLoc[0](Arg0: I64)\n\t18: ImmBorrowField[0](I64.bits: u64)\n\t19: ReadRef\n\t20: LdU64(1)\n\t21: Sub\n\t22: Call u64_neg(u64): u64\n\t23: Pack[0](I64)\n\t24: StLoc[1](loc0: I64)\nB6:\n\t25: MoveLoc[1](loc0: I64)\n\t26: Ret\n}\n\npublic abs_u64(Arg0: I64): u64 {\nL1:\tloc0: u64\nB0:\n\t0: CopyLoc[0](Arg0: I64)\n\t1: Call sign(I64): u8\n\t2: LdU8(0)\n\t3: Eq\n\t4: BrFalse(10)\nB1:\n\t5: ImmBorrowLoc[0](Arg0: I64)\n\t6: ImmBorrowField[0](I64.bits: u64)\n\t7: ReadRef\n\t8: StLoc[1](loc0: u64)\n\t9: Branch(17)\nB2:\n\t10: ImmBorrowLoc[0](Arg0: I64)\n\t11: ImmBorrowField[0](I64.bits: u64)\n\t12: ReadRef\n\t13: LdU64(1)\n\t14: Sub\n\t15: Call u64_neg(u64): u64\n\t16: StLoc[1](loc0: u64)\nB3:\n\t17: MoveLoc[1](loc0: u64)\n\t18: Ret\n}\n\npublic shl(Arg0: I64, Arg1: u8): I64 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I64)\n\t1: ImmBorrowField[0](I64.bits: u64)\n\t2: ReadRef\n\t3: MoveLoc[1](Arg1: u8)\n\t4: Shl\n\t5: Pack[0](I64)\n\t6: Ret\n}\n\npublic shr(Arg0: I64, Arg1: u8): I64 {\nL2:\tloc0: u64\nB0:\n\t0: CopyLoc[1](Arg1: u8)\n\t1: LdU8(0)\n\t2: Eq\n\t3: BrFalse(6)\nB1:\n\t4: MoveLoc[0](Arg0: I64)\n\t5: Ret\nB2:\n\t6: LdU64(18446744073709551615)\n\t7: LdU8(64)\n\t8: CopyLoc[1](Arg1: u8)\n\t9: Sub\n\t10: Shl\n\t11: StLoc[2](loc0: u64)\n\t12: CopyLoc[0](Arg0: I64)\n\t13: Call sign(I64): u8\n\t14: LdU8(1)\n\t15: Eq\n\t16: BrFalse(26)\nB3:\n\t17: ImmBorrowLoc[0](Arg0: I64)\n\t18: ImmBorrowField[0](I64.bits: u64)\n\t19: ReadRef\n\t20: MoveLoc[1](Arg1: u8)\n\t21: Shr\n\t22: MoveLoc[2](loc0: u64)\n\t23: BitOr\n\t24: Pack[0](I64)\n\t25: Ret\nB4:\n\t26: ImmBorrowLoc[0](Arg0: I64)\n\t27: ImmBorrowField[0](I64.bits: u64)\n\t28: ReadRef\n\t29: MoveLoc[1](Arg1: u8)\n\t30: Shr\n\t31: Pack[0](I64)\n\t32: Ret\n}\n\npublic mod(Arg0: I64, Arg1: I64): I64 {\nL2:\tloc0: I64\nB0:\n\t0: CopyLoc[0](Arg0: I64)\n\t1: Call sign(I64): u8\n\t2: LdU8(1)\n\t3: Eq\n\t4: BrFalse(13)\nB1:\n\t5: MoveLoc[0](Arg0: I64)\n\t6: Call abs_u64(I64): u64\n\t7: MoveLoc[1](Arg1: I64)\n\t8: Call abs_u64(I64): u64\n\t9: Mod\n\t10: Call neg_from(u64): I64\n\t11: StLoc[2](loc0: I64)\n\t12: Branch(20)\nB2:\n\t13: MoveLoc[0](Arg0: I64)\n\t14: Call as_u64(I64): u64\n\t15: MoveLoc[1](Arg1: I64)\n\t16: Call abs_u64(I64): u64\n\t17: Mod\n\t18: Call from(u64): I64\n\t19: StLoc[2](loc0: I64)\nB3:\n\t20: MoveLoc[2](loc0: I64)\n\t21: Ret\n}\n\npublic as_u64(Arg0: I64): u64 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I64)\n\t1: ImmBorrowField[0](I64.bits: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic sign(Arg0: I64): u8 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I64)\n\t1: ImmBorrowField[0](I64.bits: u64)\n\t2: ReadRef\n\t3: LdU8(63)\n\t4: Shr\n\t5: CastU8\n\t6: Ret\n}\n\npublic is_neg(Arg0: I64): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I64)\n\t1: Call sign(I64): u8\n\t2: LdU8(1)\n\t3: Eq\n\t4: Ret\n}\n\npublic cmp(Arg0: I64, Arg1: I64): u8 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I64)\n\t1: ImmBorrowField[0](I64.bits: u64)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I64)\n\t4: ImmBorrowField[0](I64.bits: u64)\n\t5: ReadRef\n\t6: Eq\n\t7: BrFalse(10)\nB1:\n\t8: LdConst[4](u8: 1)\n\t9: Ret\nB2:\n\t10: CopyLoc[0](Arg0: I64)\n\t11: Call sign(I64): u8\n\t12: CopyLoc[1](Arg1: I64)\n\t13: Call sign(I64): u8\n\t14: Gt\n\t15: BrFalse(18)\nB3:\n\t16: LdConst[3](u8: 0)\n\t17: Ret\nB4:\n\t18: CopyLoc[0](Arg0: I64)\n\t19: Call sign(I64): u8\n\t20: CopyLoc[1](Arg1: I64)\n\t21: Call sign(I64): u8\n\t22: Lt\n\t23: BrFalse(26)\nB5:\n\t24: LdConst[5](u8: 2)\n\t25: Ret\nB6:\n\t26: ImmBorrowLoc[0](Arg0: I64)\n\t27: ImmBorrowField[0](I64.bits: u64)\n\t28: ReadRef\n\t29: ImmBorrowLoc[1](Arg1: I64)\n\t30: ImmBorrowField[0](I64.bits: u64)\n\t31: ReadRef\n\t32: Gt\n\t33: BrFalse(36)\nB7:\n\t34: LdConst[5](u8: 2)\n\t35: Ret\nB8:\n\t36: LdConst[3](u8: 0)\n\t37: Ret\n}\n\npublic eq(Arg0: I64, Arg1: I64): bool {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I64)\n\t1: ImmBorrowField[0](I64.bits: u64)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I64)\n\t4: ImmBorrowField[0](I64.bits: u64)\n\t5: ReadRef\n\t6: Eq\n\t7: Ret\n}\n\npublic gt(Arg0: I64, Arg1: I64): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I64)\n\t1: MoveLoc[1](Arg1: I64)\n\t2: Call cmp(I64, I64): u8\n\t3: LdConst[5](u8: 2)\n\t4: Eq\n\t5: Ret\n}\n\npublic gte(Arg0: I64, Arg1: I64): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I64)\n\t1: MoveLoc[1](Arg1: I64)\n\t2: Call cmp(I64, I64): u8\n\t3: LdConst[4](u8: 1)\n\t4: Ge\n\t5: Ret\n}\n\npublic lt(Arg0: I64, Arg1: I64): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I64)\n\t1: MoveLoc[1](Arg1: I64)\n\t2: Call cmp(I64, I64): u8\n\t3: LdConst[3](u8: 0)\n\t4: Eq\n\t5: Ret\n}\n\npublic lte(Arg0: I64, Arg1: I64): bool {\nB0:\n\t0: MoveLoc[0](Arg0: I64)\n\t1: MoveLoc[1](Arg1: I64)\n\t2: Call cmp(I64, I64): u8\n\t3: LdConst[4](u8: 1)\n\t4: Le\n\t5: Ret\n}\n\npublic or(Arg0: I64, Arg1: I64): I64 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I64)\n\t1: ImmBorrowField[0](I64.bits: u64)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I64)\n\t4: ImmBorrowField[0](I64.bits: u64)\n\t5: ReadRef\n\t6: BitOr\n\t7: Pack[0](I64)\n\t8: Ret\n}\n\npublic and(Arg0: I64, Arg1: I64): I64 {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: I64)\n\t1: ImmBorrowField[0](I64.bits: u64)\n\t2: ReadRef\n\t3: ImmBorrowLoc[1](Arg1: I64)\n\t4: ImmBorrowField[0](I64.bits: u64)\n\t5: ReadRef\n\t6: BitAnd\n\t7: Pack[0](I64)\n\t8: Ret\n}\n\nu64_neg(Arg0: u64): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: LdU64(18446744073709551615)\n\t2: Xor\n\t3: Ret\n}\n\nu8_neg(Arg0: u8): u8 {\nB0:\n\t0: MoveLoc[0](Arg0: u8)\n\t1: LdU8(255)\n\t2: Xor\n\t3: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 9223372036854775808\n\t2 => u64: 9223372036854775807\n\t3 => u8: 0\n\t4 => u8: 1\n\t5 => u8: 2\n]\n}\n",
      "liquidity_math": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.liquidity_math {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::constants;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::full_math_u128;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i128;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::math_u256;\n\npublic add_delta(Arg0: u128, Arg1: I128): u128 {\nL2:\tloc0: u128\nL3:\tloc1: u128\nB0:\n\t0: CopyLoc[1](Arg1: I128)\n\t1: Call i128::abs_u128(I128): u128\n\t2: StLoc[3](loc1: u128)\n\t3: MoveLoc[1](Arg1: I128)\n\t4: Call i128::is_neg(I128): bool\n\t5: BrFalse(18)\nB1:\n\t6: CopyLoc[0](Arg0: u128)\n\t7: CopyLoc[3](loc1: u128)\n\t8: Ge\n\t9: BrFalse(11)\nB2:\n\t10: Branch(13)\nB3:\n\t11: LdConst[1](u64: 1)\n\t12: Abort\nB4:\n\t13: MoveLoc[0](Arg0: u128)\n\t14: MoveLoc[3](loc1: u128)\n\t15: Sub\n\t16: StLoc[2](loc0: u128)\n\t17: Branch(31)\nB5:\n\t18: CopyLoc[3](loc1: u128)\n\t19: Call constants::get_max_u128(): u128\n\t20: CopyLoc[0](Arg0: u128)\n\t21: Sub\n\t22: Lt\n\t23: BrFalse(25)\nB6:\n\t24: Branch(27)\nB7:\n\t25: LdConst[0](u64: 0)\n\t26: Abort\nB8:\n\t27: MoveLoc[0](Arg0: u128)\n\t28: MoveLoc[3](loc1: u128)\n\t29: Add\n\t30: StLoc[2](loc0: u128)\nB9:\n\t31: MoveLoc[2](loc0: u128)\n\t32: Ret\n}\n\npublic get_liquidity_for_amount_x(Arg0: u128, Arg1: u128, Arg2: u64): u128 {\nL3:\tloc0: u128\nL4:\tloc1: u128\nL5:\tloc2: u128\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: MoveLoc[1](Arg1: u128)\n\t2: Call sort_sqrt_prices(u128, u128): u128 * u128\n\t3: StLoc[5](loc2: u128)\n\t4: StLoc[4](loc1: u128)\n\t5: CopyLoc[4](loc1: u128)\n\t6: CopyLoc[5](loc2: u128)\n\t7: Call constants::get_q64(): u128\n\t8: CastU128\n\t9: Call full_math_u128::mul_div_floor(u128, u128, u128): u128\n\t10: StLoc[3](loc0: u128)\n\t11: MoveLoc[2](Arg2: u64)\n\t12: CastU128\n\t13: MoveLoc[3](loc0: u128)\n\t14: MoveLoc[5](loc2: u128)\n\t15: MoveLoc[4](loc1: u128)\n\t16: Sub\n\t17: Call full_math_u128::mul_div_floor(u128, u128, u128): u128\n\t18: Ret\n}\n\npublic get_liquidity_for_amount_y(Arg0: u128, Arg1: u128, Arg2: u64): u128 {\nL3:\tloc0: u128\nL4:\tloc1: u128\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: MoveLoc[1](Arg1: u128)\n\t2: Call sort_sqrt_prices(u128, u128): u128 * u128\n\t3: StLoc[4](loc1: u128)\n\t4: StLoc[3](loc0: u128)\n\t5: MoveLoc[2](Arg2: u64)\n\t6: CastU128\n\t7: Call constants::get_q64(): u128\n\t8: CastU128\n\t9: MoveLoc[4](loc1: u128)\n\t10: MoveLoc[3](loc0: u128)\n\t11: Sub\n\t12: Call full_math_u128::mul_div_floor(u128, u128, u128): u128\n\t13: Ret\n}\n\npublic get_liquidity_for_amounts(Arg0: u128, Arg1: u128, Arg2: u128, Arg3: u64, Arg4: u64): u128 {\nL5:\tloc0: u128\nL6:\tloc1: u128\nL7:\tloc2: u128\nL8:\tloc3: u128\nL9:\tloc4: u128\nL10:\tloc5: u128\nB0:\n\t0: MoveLoc[1](Arg1: u128)\n\t1: MoveLoc[2](Arg2: u128)\n\t2: Call sort_sqrt_prices(u128, u128): u128 * u128\n\t3: StLoc[10](loc5: u128)\n\t4: StLoc[9](loc4: u128)\n\t5: CopyLoc[0](Arg0: u128)\n\t6: CopyLoc[9](loc4: u128)\n\t7: Le\n\t8: BrFalse(15)\nB1:\n\t9: MoveLoc[9](loc4: u128)\n\t10: MoveLoc[10](loc5: u128)\n\t11: MoveLoc[3](Arg3: u64)\n\t12: Call get_liquidity_for_amount_x(u128, u128, u64): u128\n\t13: StLoc[6](loc1: u128)\n\t14: Branch(41)\nB2:\n\t15: CopyLoc[0](Arg0: u128)\n\t16: CopyLoc[10](loc5: u128)\n\t17: Lt\n\t18: BrFalse(34)\nB3:\n\t19: CopyLoc[0](Arg0: u128)\n\t20: MoveLoc[10](loc5: u128)\n\t21: MoveLoc[3](Arg3: u64)\n\t22: Call get_liquidity_for_amount_x(u128, u128, u64): u128\n\t23: StLoc[7](loc2: u128)\n\t24: MoveLoc[9](loc4: u128)\n\t25: MoveLoc[0](Arg0: u128)\n\t26: MoveLoc[4](Arg4: u64)\n\t27: Call get_liquidity_for_amount_y(u128, u128, u64): u128\n\t28: StLoc[8](loc3: u128)\n\t29: MoveLoc[7](loc2: u128)\n\t30: MoveLoc[8](loc3: u128)\n\t31: Call full_math_u128::min(u128, u128): u128\n\t32: StLoc[5](loc0: u128)\n\t33: Branch(39)\nB4:\n\t34: MoveLoc[9](loc4: u128)\n\t35: MoveLoc[10](loc5: u128)\n\t36: MoveLoc[4](Arg4: u64)\n\t37: Call get_liquidity_for_amount_y(u128, u128, u64): u128\n\t38: StLoc[5](loc0: u128)\nB5:\n\t39: MoveLoc[5](loc0: u128)\n\t40: StLoc[6](loc1: u128)\nB6:\n\t41: MoveLoc[6](loc1: u128)\n\t42: Ret\n}\n\npublic get_amount_x_for_liquidity(Arg0: u128, Arg1: u128, Arg2: u128, Arg3: bool): u64 {\nL4:\tloc0: u256\nL5:\tloc1: u256\nL6:\tloc2: bool\nL7:\tloc3: u128\nL8:\tloc4: u128\nL9:\tloc5: u128\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: MoveLoc[1](Arg1: u128)\n\t2: Call sort_sqrt_prices(u128, u128): u128 * u128\n\t3: StLoc[8](loc4: u128)\n\t4: StLoc[7](loc3: u128)\n\t5: CopyLoc[8](loc4: u128)\n\t6: CopyLoc[7](loc3: u128)\n\t7: Sub\n\t8: StLoc[9](loc5: u128)\n\t9: MoveLoc[2](Arg2: u128)\n\t10: MoveLoc[9](loc5: u128)\n\t11: Call full_math_u128::full_mul(u128, u128): u256\n\t12: Call math_u256::checked_shlw(u256): u256 * bool\n\t13: StLoc[6](loc2: bool)\n\t14: StLoc[5](loc1: u256)\n\t15: MoveLoc[6](loc2: bool)\n\t16: BrFalse(19)\nB1:\n\t17: LdConst[0](u64: 0)\n\t18: Abort\nB2:\n\t19: MoveLoc[7](loc3: u128)\n\t20: MoveLoc[8](loc4: u128)\n\t21: Call full_math_u128::full_mul(u128, u128): u256\n\t22: StLoc[4](loc0: u256)\n\t23: MoveLoc[5](loc1: u256)\n\t24: MoveLoc[4](loc0: u256)\n\t25: MoveLoc[3](Arg3: bool)\n\t26: Call math_u256::div_round(u256, u256, bool): u256\n\t27: CastU64\n\t28: Ret\n}\n\npublic get_amount_y_for_liquidity(Arg0: u128, Arg1: u128, Arg2: u128, Arg3: bool): u64 {\nL4:\tloc0: u128\nL5:\tloc1: u128\nL6:\tloc2: u128\nB0:\n\t0: MoveLoc[0](Arg0: u128)\n\t1: MoveLoc[1](Arg1: u128)\n\t2: Call sort_sqrt_prices(u128, u128): u128 * u128\n\t3: StLoc[5](loc1: u128)\n\t4: StLoc[4](loc0: u128)\n\t5: MoveLoc[5](loc1: u128)\n\t6: MoveLoc[4](loc0: u128)\n\t7: Sub\n\t8: StLoc[6](loc2: u128)\n\t9: MoveLoc[2](Arg2: u128)\n\t10: MoveLoc[6](loc2: u128)\n\t11: Call full_math_u128::full_mul(u128, u128): u256\n\t12: Call constants::get_q64(): u128\n\t13: CastU256\n\t14: MoveLoc[3](Arg3: bool)\n\t15: Call math_u256::div_round(u256, u256, bool): u256\n\t16: CastU64\n\t17: Ret\n}\n\npublic get_amounts_for_liquidity(Arg0: u128, Arg1: u128, Arg2: u128, Arg3: u128, Arg4: bool): u64 * u64 {\nL5:\tloc0: u64\nL6:\tloc1: u64\nL7:\tloc2: u64\nL8:\tloc3: u64\nL9:\tloc4: u128\nL10:\tloc5: u128\nB0:\n\t0: MoveLoc[1](Arg1: u128)\n\t1: MoveLoc[2](Arg2: u128)\n\t2: Call sort_sqrt_prices(u128, u128): u128 * u128\n\t3: StLoc[10](loc5: u128)\n\t4: StLoc[9](loc4: u128)\n\t5: CopyLoc[0](Arg0: u128)\n\t6: CopyLoc[9](loc4: u128)\n\t7: Le\n\t8: BrFalse(18)\nB1:\n\t9: MoveLoc[9](loc4: u128)\n\t10: MoveLoc[10](loc5: u128)\n\t11: MoveLoc[3](Arg3: u128)\n\t12: MoveLoc[4](Arg4: bool)\n\t13: Call get_amount_x_for_liquidity(u128, u128, u128, bool): u64\n\t14: LdU64(0)\n\t15: StLoc[8](loc3: u64)\n\t16: StLoc[7](loc2: u64)\n\t17: Branch(47)\nB2:\n\t18: CopyLoc[0](Arg0: u128)\n\t19: CopyLoc[10](loc5: u128)\n\t20: Lt\n\t21: BrFalse(35)\nB3:\n\t22: CopyLoc[0](Arg0: u128)\n\t23: MoveLoc[10](loc5: u128)\n\t24: CopyLoc[3](Arg3: u128)\n\t25: CopyLoc[4](Arg4: bool)\n\t26: Call get_amount_x_for_liquidity(u128, u128, u128, bool): u64\n\t27: MoveLoc[9](loc4: u128)\n\t28: MoveLoc[0](Arg0: u128)\n\t29: MoveLoc[3](Arg3: u128)\n\t30: MoveLoc[4](Arg4: bool)\n\t31: Call get_amount_y_for_liquidity(u128, u128, u128, bool): u64\n\t32: StLoc[6](loc1: u64)\n\t33: StLoc[5](loc0: u64)\n\t34: Branch(43)\nB4:\n\t35: LdU64(0)\n\t36: MoveLoc[9](loc4: u128)\n\t37: MoveLoc[10](loc5: u128)\n\t38: MoveLoc[3](Arg3: u128)\n\t39: MoveLoc[4](Arg4: bool)\n\t40: Call get_amount_y_for_liquidity(u128, u128, u128, bool): u64\n\t41: StLoc[6](loc1: u64)\n\t42: StLoc[5](loc0: u64)\nB5:\n\t43: MoveLoc[5](loc0: u64)\n\t44: MoveLoc[6](loc1: u64)\n\t45: StLoc[8](loc3: u64)\n\t46: StLoc[7](loc2: u64)\nB6:\n\t47: MoveLoc[7](loc2: u64)\n\t48: MoveLoc[8](loc3: u64)\n\t49: Ret\n}\n\nsort_sqrt_prices(Arg0: u128, Arg1: u128): u128 * u128 {\nL2:\tloc0: u128\nL3:\tloc1: u128\nB0:\n\t0: CopyLoc[0](Arg0: u128)\n\t1: CopyLoc[1](Arg1: u128)\n\t2: Gt\n\t3: BrFalse(9)\nB1:\n\t4: MoveLoc[1](Arg1: u128)\n\t5: MoveLoc[0](Arg0: u128)\n\t6: StLoc[3](loc1: u128)\n\t7: StLoc[2](loc0: u128)\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[0](Arg0: u128)\n\t10: MoveLoc[1](Arg1: u128)\n\t11: StLoc[3](loc1: u128)\n\t12: StLoc[2](loc0: u128)\nB3:\n\t13: MoveLoc[2](loc0: u128)\n\t14: MoveLoc[3](loc1: u128)\n\t15: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n]\n}\n",
      "math_u256": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.math_u256 {\n\npublic div_mod(Arg0: u256, Arg1: u256): u256 * u256 {\nL2:\tloc0: u256\nL3:\tloc1: u256\nB0:\n\t0: CopyLoc[0](Arg0: u256)\n\t1: CopyLoc[1](Arg1: u256)\n\t2: Div\n\t3: StLoc[2](loc0: u256)\n\t4: MoveLoc[0](Arg0: u256)\n\t5: CopyLoc[2](loc0: u256)\n\t6: MoveLoc[1](Arg1: u256)\n\t7: Mul\n\t8: Sub\n\t9: StLoc[3](loc1: u256)\n\t10: MoveLoc[2](loc0: u256)\n\t11: MoveLoc[3](loc1: u256)\n\t12: Ret\n}\n\npublic shlw(Arg0: u256): u256 {\nB0:\n\t0: MoveLoc[0](Arg0: u256)\n\t1: LdU8(64)\n\t2: Shl\n\t3: Ret\n}\n\npublic shrw(Arg0: u256): u256 {\nB0:\n\t0: MoveLoc[0](Arg0: u256)\n\t1: LdU8(64)\n\t2: Shr\n\t3: Ret\n}\n\npublic checked_shlw(Arg0: u256): u256 * bool {\nL1:\tloc0: u256\nL2:\tloc1: bool\nB0:\n\t0: CopyLoc[0](Arg0: u256)\n\t1: LdU256(115792089237316195417293883273301227089434195242432897623355228563449095127040)\n\t2: Gt\n\t3: BrFalse(9)\nB1:\n\t4: LdU256(0)\n\t5: LdTrue\n\t6: StLoc[2](loc1: bool)\n\t7: StLoc[1](loc0: u256)\n\t8: Branch(15)\nB2:\n\t9: MoveLoc[0](Arg0: u256)\n\t10: LdU8(64)\n\t11: Shl\n\t12: LdFalse\n\t13: StLoc[2](loc1: bool)\n\t14: StLoc[1](loc0: u256)\nB3:\n\t15: MoveLoc[1](loc0: u256)\n\t16: MoveLoc[2](loc1: bool)\n\t17: Ret\n}\n\npublic div_round(Arg0: u256, Arg1: u256, Arg2: bool): u256 {\nL3:\tloc0: bool\nL4:\tloc1: u256\nL5:\tloc2: u256\nB0:\n\t0: CopyLoc[1](Arg1: u256)\n\t1: LdU256(0)\n\t2: Eq\n\t3: BrFalse(6)\nB1:\n\t4: LdConst[1](u64: 1)\n\t5: Abort\nB2:\n\t6: CopyLoc[0](Arg0: u256)\n\t7: CopyLoc[1](Arg1: u256)\n\t8: Div\n\t9: StLoc[5](loc2: u256)\n\t10: MoveLoc[2](Arg2: bool)\n\t11: BrFalse(19)\nB3:\n\t12: CopyLoc[5](loc2: u256)\n\t13: MoveLoc[1](Arg1: u256)\n\t14: Mul\n\t15: MoveLoc[0](Arg0: u256)\n\t16: Neq\n\t17: StLoc[3](loc0: bool)\n\t18: Branch(21)\nB4:\n\t19: LdFalse\n\t20: StLoc[3](loc0: bool)\nB5:\n\t21: MoveLoc[3](loc0: bool)\n\t22: BrFalse(28)\nB6:\n\t23: MoveLoc[5](loc2: u256)\n\t24: LdU256(1)\n\t25: Add\n\t26: StLoc[4](loc1: u256)\n\t27: Branch(30)\nB7:\n\t28: MoveLoc[5](loc2: u256)\n\t29: StLoc[4](loc1: u256)\nB8:\n\t30: MoveLoc[4](loc1: u256)\n\t31: Ret\n}\n\npublic add_check(Arg0: u256, Arg1: u256): bool {\nB0:\n\t0: LdConst[0](u256: 1157..)\n\t1: MoveLoc[0](Arg0: u256)\n\t2: Sub\n\t3: MoveLoc[1](Arg1: u256)\n\t4: Ge\n\t5: Ret\n}\n\npublic overflow_add(Arg0: u256, Arg1: u256): u256 {\nL2:\tloc0: u256\nL3:\tloc1: u256\nB0:\n\t0: CopyLoc[0](Arg0: u256)\n\t1: CopyLoc[1](Arg1: u256)\n\t2: Call add_check(u256, u256): bool\n\t3: Not\n\t4: BrFalse(16)\nB1:\n\t5: LdConst[0](u256: 1157..)\n\t6: MoveLoc[0](Arg0: u256)\n\t7: Sub\n\t8: StLoc[3](loc1: u256)\n\t9: MoveLoc[1](Arg1: u256)\n\t10: MoveLoc[3](loc1: u256)\n\t11: Sub\n\t12: LdU256(1)\n\t13: Sub\n\t14: StLoc[2](loc0: u256)\n\t15: Branch(20)\nB2:\n\t16: MoveLoc[0](Arg0: u256)\n\t17: MoveLoc[1](Arg1: u256)\n\t18: Add\n\t19: StLoc[2](loc0: u256)\nB3:\n\t20: MoveLoc[2](loc0: u256)\n\t21: Ret\n}\n\nConstants [\n\t0 => u256: 115792089237316195423570985008687907853269984665640564039457584007913129639935\n\t1 => u64: 1\n]\n}\n",
      "oracle": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.oracle {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i32;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i64;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::math_u256;\n\nstruct Observation has copy, drop, store {\n\ttimestamp_s: u64,\n\ttick_cumulative: I64,\n\tseconds_per_liquidity_cumulative: u256,\n\tinitialized: bool\n}\n\ndefault(): Observation {\nB0:\n\t0: LdU64(0)\n\t1: Call i64::zero(): I64\n\t2: LdU256(0)\n\t3: LdFalse\n\t4: Pack[0](Observation)\n\t5: Ret\n}\n\npublic timestamp_s(Arg0: &Observation): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Observation)\n\t1: ImmBorrowField[0](Observation.timestamp_s: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic tick_cumulative(Arg0: &Observation): I64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Observation)\n\t1: ImmBorrowField[1](Observation.tick_cumulative: I64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic seconds_per_liquidity_cumulative(Arg0: &Observation): u256 {\nB0:\n\t0: MoveLoc[0](Arg0: &Observation)\n\t1: ImmBorrowField[2](Observation.seconds_per_liquidity_cumulative: u256)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic is_initialized(Arg0: &Observation): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Observation)\n\t1: ImmBorrowField[3](Observation.initialized: bool)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic transform(Arg0: &Observation, Arg1: u64, Arg2: I32, Arg3: u128): Observation {\nL4:\tloc0: I64\nL5:\tloc1: u128\nL6:\tloc2: u128\nL7:\tloc3: I64\nL8:\tloc4: u64\nB0:\n\t0: CopyLoc[2](Arg2: I32)\n\t1: Call i32::is_neg(I32): bool\n\t2: BrFalse(9)\nB1:\n\t3: MoveLoc[2](Arg2: I32)\n\t4: Call i32::abs_u32(I32): u32\n\t5: CastU64\n\t6: Call i64::neg_from(u64): I64\n\t7: StLoc[4](loc0: I64)\n\t8: Branch(14)\nB2:\n\t9: MoveLoc[2](Arg2: I32)\n\t10: Call i32::abs_u32(I32): u32\n\t11: CastU64\n\t12: Call i64::from(u64): I64\n\t13: StLoc[4](loc0: I64)\nB3:\n\t14: MoveLoc[4](loc0: I64)\n\t15: StLoc[7](loc3: I64)\n\t16: CopyLoc[1](Arg1: u64)\n\t17: CopyLoc[0](Arg0: &Observation)\n\t18: ImmBorrowField[0](Observation.timestamp_s: u64)\n\t19: ReadRef\n\t20: Sub\n\t21: StLoc[8](loc4: u64)\n\t22: CopyLoc[3](Arg3: u128)\n\t23: LdU128(0)\n\t24: Eq\n\t25: BrFalse(29)\nB4:\n\t26: LdU128(1)\n\t27: StLoc[5](loc1: u128)\n\t28: Branch(31)\nB5:\n\t29: MoveLoc[3](Arg3: u128)\n\t30: StLoc[5](loc1: u128)\nB6:\n\t31: MoveLoc[5](loc1: u128)\n\t32: StLoc[6](loc2: u128)\n\t33: MoveLoc[1](Arg1: u64)\n\t34: CopyLoc[0](Arg0: &Observation)\n\t35: ImmBorrowField[1](Observation.tick_cumulative: I64)\n\t36: ReadRef\n\t37: MoveLoc[7](loc3: I64)\n\t38: CopyLoc[8](loc4: u64)\n\t39: Call i64::from(u64): I64\n\t40: Call i64::mul(I64, I64): I64\n\t41: Call i64::add(I64, I64): I64\n\t42: MoveLoc[0](Arg0: &Observation)\n\t43: ImmBorrowField[2](Observation.seconds_per_liquidity_cumulative: u256)\n\t44: ReadRef\n\t45: MoveLoc[8](loc4: u64)\n\t46: CastU256\n\t47: LdU8(128)\n\t48: Shl\n\t49: MoveLoc[6](loc2: u128)\n\t50: CastU256\n\t51: Div\n\t52: Call math_u256::overflow_add(u256, u256): u256\n\t53: LdTrue\n\t54: Pack[0](Observation)\n\t55: Ret\n}\n\npublic initialize(Arg0: &mut vector<Observation>, Arg1: u64): u64 * u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &mut vector<Observation>)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call i64::zero(): I64\n\t3: LdU256(0)\n\t4: LdTrue\n\t5: Pack[0](Observation)\n\t6: VecPushBack(1)\n\t7: LdU64(1)\n\t8: LdU64(1)\n\t9: Ret\n}\n\npublic write(Arg0: &mut vector<Observation>, Arg1: u64, Arg2: u64, Arg3: I32, Arg4: u128, Arg5: u64, Arg6: u64): u64 * u64 {\nL7:\tloc0: u64\nL8:\tloc1: bool\nL9:\tloc2: u64\nL10:\tloc3: u64\nL11:\tloc4: u64\nL12:\tloc5: &Observation\nL13:\tloc6: &mut Observation\nL14:\tloc7: Observation\nB0:\n\t0: CopyLoc[0](Arg0: &mut vector<Observation>)\n\t1: CopyLoc[1](Arg1: u64)\n\t2: StLoc[7](loc0: u64)\n\t3: FreezeRef\n\t4: MoveLoc[7](loc0: u64)\n\t5: VecImmBorrow(1)\n\t6: StLoc[12](loc5: &Observation)\n\t7: CopyLoc[12](loc5: &Observation)\n\t8: ImmBorrowField[0](Observation.timestamp_s: u64)\n\t9: ReadRef\n\t10: CopyLoc[2](Arg2: u64)\n\t11: Eq\n\t12: BrFalse(20)\nB1:\n\t13: MoveLoc[0](Arg0: &mut vector<Observation>)\n\t14: Pop\n\t15: MoveLoc[12](loc5: &Observation)\n\t16: Pop\n\t17: MoveLoc[1](Arg1: u64)\n\t18: MoveLoc[5](Arg5: u64)\n\t19: Ret\nB2:\n\t20: CopyLoc[6](Arg6: u64)\n\t21: CopyLoc[5](Arg5: u64)\n\t22: Gt\n\t23: BrFalse(31)\nB3:\n\t24: CopyLoc[1](Arg1: u64)\n\t25: CopyLoc[5](Arg5: u64)\n\t26: LdU64(1)\n\t27: Sub\n\t28: Eq\n\t29: StLoc[8](loc1: bool)\n\t30: Branch(33)\nB4:\n\t31: LdFalse\n\t32: StLoc[8](loc1: bool)\nB5:\n\t33: MoveLoc[8](loc1: bool)\n\t34: BrFalse(38)\nB6:\n\t35: MoveLoc[6](Arg6: u64)\n\t36: StLoc[9](loc2: u64)\n\t37: Branch(40)\nB7:\n\t38: MoveLoc[5](Arg5: u64)\n\t39: StLoc[9](loc2: u64)\nB8:\n\t40: MoveLoc[9](loc2: u64)\n\t41: StLoc[10](loc3: u64)\n\t42: MoveLoc[1](Arg1: u64)\n\t43: LdU64(1)\n\t44: Add\n\t45: CopyLoc[10](loc3: u64)\n\t46: Mod\n\t47: StLoc[11](loc4: u64)\n\t48: MoveLoc[12](loc5: &Observation)\n\t49: MoveLoc[2](Arg2: u64)\n\t50: MoveLoc[3](Arg3: I32)\n\t51: MoveLoc[4](Arg4: u128)\n\t52: Call transform(&Observation, u64, I32, u128): Observation\n\t53: StLoc[14](loc7: Observation)\n\t54: MoveLoc[0](Arg0: &mut vector<Observation>)\n\t55: CopyLoc[11](loc4: u64)\n\t56: VecMutBorrow(1)\n\t57: StLoc[13](loc6: &mut Observation)\n\t58: MoveLoc[14](loc7: Observation)\n\t59: MoveLoc[13](loc6: &mut Observation)\n\t60: WriteRef\n\t61: MoveLoc[11](loc4: u64)\n\t62: MoveLoc[10](loc3: u64)\n\t63: Ret\n}\n\npublic grow(Arg0: &mut vector<Observation>, Arg1: u64, Arg2: u64): u64 {\nB0:\n\t0: CopyLoc[1](Arg1: u64)\n\t1: LdU64(0)\n\t2: Eq\n\t3: BrFalse(8)\nB1:\n\t4: MoveLoc[0](Arg0: &mut vector<Observation>)\n\t5: Pop\n\t6: LdConst[0](u64: 0)\n\t7: Abort\nB2:\n\t8: CopyLoc[2](Arg2: u64)\n\t9: LdConst[3](u64: 1000)\n\t10: Ge\n\t11: BrFalse(16)\nB3:\n\t12: MoveLoc[0](Arg0: &mut vector<Observation>)\n\t13: Pop\n\t14: LdConst[2](u64: 2)\n\t15: Abort\nB4:\n\t16: CopyLoc[2](Arg2: u64)\n\t17: CopyLoc[1](Arg1: u64)\n\t18: Le\n\t19: BrFalse(24)\nB5:\n\t20: MoveLoc[0](Arg0: &mut vector<Observation>)\n\t21: Pop\n\t22: MoveLoc[1](Arg1: u64)\n\t23: Ret\nB6:\n\t24: CopyLoc[1](Arg1: u64)\n\t25: CopyLoc[2](Arg2: u64)\n\t26: Lt\n\t27: BrFalse(41)\nB7:\n\t28: Branch(29)\nB8:\n\t29: CopyLoc[0](Arg0: &mut vector<Observation>)\n\t30: LdU64(1)\n\t31: Call i64::zero(): I64\n\t32: LdU256(0)\n\t33: LdFalse\n\t34: Pack[0](Observation)\n\t35: VecPushBack(1)\n\t36: MoveLoc[1](Arg1: u64)\n\t37: LdU64(1)\n\t38: Add\n\t39: StLoc[1](Arg1: u64)\n\t40: Branch(24)\nB9:\n\t41: MoveLoc[0](Arg0: &mut vector<Observation>)\n\t42: Pop\n\t43: MoveLoc[2](Arg2: u64)\n\t44: Ret\n}\n\ntry_get_observation(Arg0: &vector<Observation>, Arg1: u64): Observation {\nL2:\tloc0: Observation\nB0:\n\t0: CopyLoc[1](Arg1: u64)\n\t1: CopyLoc[0](Arg0: &vector<Observation>)\n\t2: VecLen(1)\n\t3: LdU64(1)\n\t4: Sub\n\t5: Gt\n\t6: BrFalse(12)\nB1:\n\t7: MoveLoc[0](Arg0: &vector<Observation>)\n\t8: Pop\n\t9: Call default(): Observation\n\t10: StLoc[2](loc0: Observation)\n\t11: Branch(17)\nB2:\n\t12: MoveLoc[0](Arg0: &vector<Observation>)\n\t13: MoveLoc[1](Arg1: u64)\n\t14: VecImmBorrow(1)\n\t15: ReadRef\n\t16: StLoc[2](loc0: Observation)\nB3:\n\t17: MoveLoc[2](loc0: Observation)\n\t18: Ret\n}\n\npublic binary_search(Arg0: &vector<Observation>, Arg1: u64, Arg2: u64, Arg3: u64): Observation * Observation {\nL4:\tloc0: bool\nL5:\tloc1: Observation\nL6:\tloc2: Observation\nL7:\tloc3: u64\nL8:\tloc4: u64\nL9:\tloc5: u64\nL10:\tloc6: bool\nB0:\n\t0: MoveLoc[2](Arg2: u64)\n\t1: LdU64(1)\n\t2: Add\n\t3: CopyLoc[3](Arg3: u64)\n\t4: Mod\n\t5: StLoc[8](loc4: u64)\n\t6: CopyLoc[8](loc4: u64)\n\t7: CopyLoc[3](Arg3: u64)\n\t8: Add\n\t9: LdU64(1)\n\t10: Sub\n\t11: StLoc[9](loc5: u64)\n\t12: LdU64(0)\n\t13: Pop\n\t14: Call default(): Observation\n\t15: StLoc[6](loc2: Observation)\n\t16: Call default(): Observation\n\t17: StLoc[5](loc1: Observation)\nB1:\n\t18: CopyLoc[8](loc4: u64)\n\t19: CopyLoc[9](loc5: u64)\n\t20: Add\n\t21: LdU64(2)\n\t22: Div\n\t23: StLoc[7](loc3: u64)\n\t24: CopyLoc[0](Arg0: &vector<Observation>)\n\t25: CopyLoc[7](loc3: u64)\n\t26: CopyLoc[3](Arg3: u64)\n\t27: Mod\n\t28: Call try_get_observation(&vector<Observation>, u64): Observation\n\t29: StLoc[6](loc2: Observation)\n\t30: ImmBorrowLoc[6](loc2: Observation)\n\t31: ImmBorrowField[3](Observation.initialized: bool)\n\t32: ReadRef\n\t33: Not\n\t34: BrFalse(40)\nB2:\n\t35: MoveLoc[7](loc3: u64)\n\t36: LdU64(1)\n\t37: Add\n\t38: StLoc[8](loc4: u64)\n\t39: Branch(18)\nB3:\n\t40: CopyLoc[0](Arg0: &vector<Observation>)\n\t41: CopyLoc[7](loc3: u64)\n\t42: LdU64(1)\n\t43: Add\n\t44: CopyLoc[3](Arg3: u64)\n\t45: Mod\n\t46: Call try_get_observation(&vector<Observation>, u64): Observation\n\t47: StLoc[5](loc1: Observation)\n\t48: ImmBorrowLoc[6](loc2: Observation)\n\t49: ImmBorrowField[0](Observation.timestamp_s: u64)\n\t50: ReadRef\n\t51: CopyLoc[1](Arg1: u64)\n\t52: Le\n\t53: StLoc[10](loc6: bool)\n\t54: CopyLoc[10](loc6: bool)\n\t55: BrFalse(63)\nB4:\n\t56: CopyLoc[1](Arg1: u64)\n\t57: ImmBorrowLoc[5](loc1: Observation)\n\t58: ImmBorrowField[0](Observation.timestamp_s: u64)\n\t59: ReadRef\n\t60: Le\n\t61: StLoc[4](loc0: bool)\n\t62: Branch(65)\nB5:\n\t63: LdFalse\n\t64: StLoc[4](loc0: bool)\nB6:\n\t65: MoveLoc[4](loc0: bool)\n\t66: BrFalse(68)\nB7:\n\t67: Branch(81)\nB8:\n\t68: MoveLoc[10](loc6: bool)\n\t69: Not\n\t70: BrFalse(76)\nB9:\n\t71: MoveLoc[7](loc3: u64)\n\t72: LdU64(1)\n\t73: Sub\n\t74: StLoc[9](loc5: u64)\n\t75: Branch(80)\nB10:\n\t76: MoveLoc[7](loc3: u64)\n\t77: LdU64(1)\n\t78: Add\n\t79: StLoc[8](loc4: u64)\nB11:\n\t80: Branch(18)\nB12:\n\t81: MoveLoc[0](Arg0: &vector<Observation>)\n\t82: Pop\n\t83: MoveLoc[6](loc2: Observation)\n\t84: MoveLoc[5](loc1: Observation)\n\t85: Ret\n}\n\npublic get_surrounding_observations(Arg0: &vector<Observation>, Arg1: u64, Arg2: I32, Arg3: u64, Arg4: u128, Arg5: u64): Observation * Observation {\nL6:\tloc0: Observation\nL7:\tloc1: Observation\nB0:\n\t0: CopyLoc[0](Arg0: &vector<Observation>)\n\t1: CopyLoc[3](Arg3: u64)\n\t2: Call try_get_observation(&vector<Observation>, u64): Observation\n\t3: StLoc[7](loc1: Observation)\n\t4: Call default(): Observation\n\t5: StLoc[6](loc0: Observation)\n\t6: ImmBorrowLoc[7](loc1: Observation)\n\t7: ImmBorrowField[0](Observation.timestamp_s: u64)\n\t8: ReadRef\n\t9: CopyLoc[1](Arg1: u64)\n\t10: Le\n\t11: BrFalse(30)\nB1:\n\t12: MoveLoc[0](Arg0: &vector<Observation>)\n\t13: Pop\n\t14: ImmBorrowLoc[7](loc1: Observation)\n\t15: ImmBorrowField[0](Observation.timestamp_s: u64)\n\t16: ReadRef\n\t17: CopyLoc[1](Arg1: u64)\n\t18: Eq\n\t19: BrFalse(23)\nB2:\n\t20: MoveLoc[7](loc1: Observation)\n\t21: MoveLoc[6](loc0: Observation)\n\t22: Ret\nB3:\n\t23: CopyLoc[7](loc1: Observation)\n\t24: ImmBorrowLoc[7](loc1: Observation)\n\t25: MoveLoc[1](Arg1: u64)\n\t26: MoveLoc[2](Arg2: I32)\n\t27: MoveLoc[4](Arg4: u128)\n\t28: Call transform(&Observation, u64, I32, u128): Observation\n\t29: Ret\nB4:\n\t30: CopyLoc[0](Arg0: &vector<Observation>)\n\t31: CopyLoc[3](Arg3: u64)\n\t32: LdU64(1)\n\t33: Add\n\t34: CopyLoc[5](Arg5: u64)\n\t35: Mod\n\t36: Call try_get_observation(&vector<Observation>, u64): Observation\n\t37: StLoc[7](loc1: Observation)\n\t38: ImmBorrowLoc[7](loc1: Observation)\n\t39: ImmBorrowField[3](Observation.initialized: bool)\n\t40: ReadRef\n\t41: Not\n\t42: BrFalse(48)\nB5:\n\t43: CopyLoc[0](Arg0: &vector<Observation>)\n\t44: LdU64(0)\n\t45: VecImmBorrow(1)\n\t46: ReadRef\n\t47: StLoc[7](loc1: Observation)\nB6:\n\t48: ImmBorrowLoc[7](loc1: Observation)\n\t49: ImmBorrowField[0](Observation.timestamp_s: u64)\n\t50: ReadRef\n\t51: CopyLoc[1](Arg1: u64)\n\t52: Gt\n\t53: BrFalse(58)\nB7:\n\t54: MoveLoc[0](Arg0: &vector<Observation>)\n\t55: Pop\n\t56: LdConst[1](u64: 1)\n\t57: Abort\nB8:\n\t58: MoveLoc[0](Arg0: &vector<Observation>)\n\t59: MoveLoc[1](Arg1: u64)\n\t60: MoveLoc[3](Arg3: u64)\n\t61: MoveLoc[5](Arg5: u64)\n\t62: Call binary_search(&vector<Observation>, u64, u64, u64): Observation * Observation\n\t63: Ret\n}\n\npublic observe_single(Arg0: &vector<Observation>, Arg1: u64, Arg2: u64, Arg3: I32, Arg4: u64, Arg5: u128, Arg6: u64): I64 * u256 {\nL7:\tloc0: I64\nL8:\tloc1: u256\nL9:\tloc2: I64\nL10:\tloc3: u256\nL11:\tloc4: Observation\nL12:\tloc5: Observation\nL13:\tloc6: Observation\nL14:\tloc7: u64\nL15:\tloc8: u64\nL16:\tloc9: u64\nB0:\n\t0: CopyLoc[2](Arg2: u64)\n\t1: LdU64(0)\n\t2: Eq\n\t3: BrFalse(27)\nB1:\n\t4: MoveLoc[0](Arg0: &vector<Observation>)\n\t5: MoveLoc[4](Arg4: u64)\n\t6: Call try_get_observation(&vector<Observation>, u64): Observation\n\t7: StLoc[13](loc6: Observation)\n\t8: ImmBorrowLoc[13](loc6: Observation)\n\t9: ImmBorrowField[0](Observation.timestamp_s: u64)\n\t10: ReadRef\n\t11: CopyLoc[1](Arg1: u64)\n\t12: Neq\n\t13: BrFalse(20)\nB2:\n\t14: ImmBorrowLoc[13](loc6: Observation)\n\t15: MoveLoc[1](Arg1: u64)\n\t16: MoveLoc[3](Arg3: I32)\n\t17: MoveLoc[5](Arg5: u128)\n\t18: Call transform(&Observation, u64, I32, u128): Observation\n\t19: StLoc[13](loc6: Observation)\nB3:\n\t20: ImmBorrowLoc[13](loc6: Observation)\n\t21: ImmBorrowField[1](Observation.tick_cumulative: I64)\n\t22: ReadRef\n\t23: ImmBorrowLoc[13](loc6: Observation)\n\t24: ImmBorrowField[2](Observation.seconds_per_liquidity_cumulative: u256)\n\t25: ReadRef\n\t26: Ret\nB4:\n\t27: MoveLoc[1](Arg1: u64)\n\t28: MoveLoc[2](Arg2: u64)\n\t29: Sub\n\t30: StLoc[15](loc8: u64)\n\t31: MoveLoc[0](Arg0: &vector<Observation>)\n\t32: CopyLoc[15](loc8: u64)\n\t33: MoveLoc[3](Arg3: I32)\n\t34: MoveLoc[4](Arg4: u64)\n\t35: MoveLoc[5](Arg5: u128)\n\t36: MoveLoc[6](Arg6: u64)\n\t37: Call get_surrounding_observations(&vector<Observation>, u64, I32, u64, u128, u64): Observation * Observation\n\t38: StLoc[11](loc4: Observation)\n\t39: StLoc[12](loc5: Observation)\n\t40: CopyLoc[15](loc8: u64)\n\t41: ImmBorrowLoc[12](loc5: Observation)\n\t42: ImmBorrowField[0](Observation.timestamp_s: u64)\n\t43: ReadRef\n\t44: Eq\n\t45: BrFalse(55)\nB5:\n\t46: ImmBorrowLoc[12](loc5: Observation)\n\t47: ImmBorrowField[1](Observation.tick_cumulative: I64)\n\t48: ReadRef\n\t49: ImmBorrowLoc[12](loc5: Observation)\n\t50: ImmBorrowField[2](Observation.seconds_per_liquidity_cumulative: u256)\n\t51: ReadRef\n\t52: StLoc[10](loc3: u256)\n\t53: StLoc[9](loc2: I64)\n\t54: Branch(124)\nB6:\n\t55: CopyLoc[15](loc8: u64)\n\t56: ImmBorrowLoc[11](loc4: Observation)\n\t57: ImmBorrowField[0](Observation.timestamp_s: u64)\n\t58: ReadRef\n\t59: Eq\n\t60: BrFalse(70)\nB7:\n\t61: ImmBorrowLoc[11](loc4: Observation)\n\t62: ImmBorrowField[1](Observation.tick_cumulative: I64)\n\t63: ReadRef\n\t64: ImmBorrowLoc[11](loc4: Observation)\n\t65: ImmBorrowField[2](Observation.seconds_per_liquidity_cumulative: u256)\n\t66: ReadRef\n\t67: StLoc[8](loc1: u256)\n\t68: StLoc[7](loc0: I64)\n\t69: Branch(120)\nB8:\n\t70: ImmBorrowLoc[11](loc4: Observation)\n\t71: ImmBorrowField[0](Observation.timestamp_s: u64)\n\t72: ReadRef\n\t73: ImmBorrowLoc[12](loc5: Observation)\n\t74: ImmBorrowField[0](Observation.timestamp_s: u64)\n\t75: ReadRef\n\t76: Sub\n\t77: StLoc[14](loc7: u64)\n\t78: MoveLoc[15](loc8: u64)\n\t79: ImmBorrowLoc[12](loc5: Observation)\n\t80: ImmBorrowField[0](Observation.timestamp_s: u64)\n\t81: ReadRef\n\t82: Sub\n\t83: StLoc[16](loc9: u64)\n\t84: ImmBorrowLoc[12](loc5: Observation)\n\t85: ImmBorrowField[1](Observation.tick_cumulative: I64)\n\t86: ReadRef\n\t87: ImmBorrowLoc[11](loc4: Observation)\n\t88: ImmBorrowField[1](Observation.tick_cumulative: I64)\n\t89: ReadRef\n\t90: ImmBorrowLoc[12](loc5: Observation)\n\t91: ImmBorrowField[1](Observation.tick_cumulative: I64)\n\t92: ReadRef\n\t93: Call i64::sub(I64, I64): I64\n\t94: CopyLoc[14](loc7: u64)\n\t95: Call i64::from(u64): I64\n\t96: Call i64::div(I64, I64): I64\n\t97: CopyLoc[16](loc9: u64)\n\t98: Call i64::from(u64): I64\n\t99: Call i64::mul(I64, I64): I64\n\t100: Call i64::add(I64, I64): I64\n\t101: ImmBorrowLoc[12](loc5: Observation)\n\t102: ImmBorrowField[2](Observation.seconds_per_liquidity_cumulative: u256)\n\t103: ReadRef\n\t104: ImmBorrowLoc[11](loc4: Observation)\n\t105: ImmBorrowField[2](Observation.seconds_per_liquidity_cumulative: u256)\n\t106: ReadRef\n\t107: ImmBorrowLoc[12](loc5: Observation)\n\t108: ImmBorrowField[2](Observation.seconds_per_liquidity_cumulative: u256)\n\t109: ReadRef\n\t110: Sub\n\t111: MoveLoc[16](loc9: u64)\n\t112: CastU256\n\t113: Mul\n\t114: MoveLoc[14](loc7: u64)\n\t115: CastU256\n\t116: Div\n\t117: Add\n\t118: StLoc[8](loc1: u256)\n\t119: StLoc[7](loc0: I64)\nB9:\n\t120: MoveLoc[7](loc0: I64)\n\t121: MoveLoc[8](loc1: u256)\n\t122: StLoc[10](loc3: u256)\n\t123: StLoc[9](loc2: I64)\nB10:\n\t124: MoveLoc[9](loc2: I64)\n\t125: MoveLoc[10](loc3: u256)\n\t126: Ret\n}\n\npublic observe(Arg0: &vector<Observation>, Arg1: u64, Arg2: vector<u64>, Arg3: I32, Arg4: u64, Arg5: u128, Arg6: u64): vector<I64> * vector<u256> {\nL7:\tloc0: u64\nL8:\tloc1: u64\nL9:\tloc2: u256\nL10:\tloc3: vector<u256>\nL11:\tloc4: I64\nL12:\tloc5: vector<I64>\nB0:\n\t0: CopyLoc[6](Arg6: u64)\n\t1: LdU64(0)\n\t2: Eq\n\t3: BrFalse(8)\nB1:\n\t4: MoveLoc[0](Arg0: &vector<Observation>)\n\t5: Pop\n\t6: LdConst[0](u64: 0)\n\t7: Abort\nB2:\n\t8: VecPack(4, 0)\n\t9: VecPack(5, 0)\n\t10: StLoc[10](loc3: vector<u256>)\n\t11: StLoc[12](loc5: vector<I64>)\n\t12: LdU64(0)\n\t13: ImmBorrowLoc[2](Arg2: vector<u64>)\n\t14: VecLen(3)\n\t15: StLoc[8](loc1: u64)\n\t16: StLoc[7](loc0: u64)\nB3:\n\t17: CopyLoc[7](loc0: u64)\n\t18: CopyLoc[8](loc1: u64)\n\t19: Lt\n\t20: BrFalse(46)\nB4:\n\t21: Branch(22)\nB5:\n\t22: CopyLoc[0](Arg0: &vector<Observation>)\n\t23: CopyLoc[1](Arg1: u64)\n\t24: ImmBorrowLoc[2](Arg2: vector<u64>)\n\t25: CopyLoc[7](loc0: u64)\n\t26: VecImmBorrow(3)\n\t27: ReadRef\n\t28: CopyLoc[3](Arg3: I32)\n\t29: CopyLoc[4](Arg4: u64)\n\t30: CopyLoc[5](Arg5: u128)\n\t31: CopyLoc[6](Arg6: u64)\n\t32: Call observe_single(&vector<Observation>, u64, u64, I32, u64, u128, u64): I64 * u256\n\t33: StLoc[9](loc2: u256)\n\t34: StLoc[11](loc4: I64)\n\t35: MutBorrowLoc[12](loc5: vector<I64>)\n\t36: MoveLoc[11](loc4: I64)\n\t37: VecPushBack(4)\n\t38: MutBorrowLoc[10](loc3: vector<u256>)\n\t39: MoveLoc[9](loc2: u256)\n\t40: VecPushBack(5)\n\t41: MoveLoc[7](loc0: u64)\n\t42: LdU64(1)\n\t43: Add\n\t44: StLoc[7](loc0: u64)\n\t45: Branch(17)\nB6:\n\t46: MoveLoc[0](Arg0: &vector<Observation>)\n\t47: Pop\n\t48: MoveLoc[12](loc5: vector<I64>)\n\t49: MoveLoc[10](loc3: vector<u256>)\n\t50: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 1000\n]\n}\n",
      "pool": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.pool {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::admin_cap;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::constants;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::full_math_u128;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::full_math_u64;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i128;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i32;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i64;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::liquidity_math;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::oracle;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::position;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::sqrt_price_math;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::swap_math;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::tick;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::tick_bitmap;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::tick_math;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::utils;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::versioned;\nuse 0000000000000000000000000000000000000000000000000000000000000001::type_name;\nuse 0000000000000000000000000000000000000000000000000000000000000002::balance;\nuse 0000000000000000000000000000000000000000000000000000000000000002::clock;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::event;\nuse 0000000000000000000000000000000000000000000000000000000000000002::math;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::table;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct PoolRewardCustodianDfKey<phantom Ty0> has copy, drop, store {\n\tdummy_field: bool\n}\n\nstruct Pool<phantom Ty0, phantom Ty1> has store, key {\n\tid: UID,\n\tcoin_type_x: TypeName,\n\tcoin_type_y: TypeName,\n\tsqrt_price: u128,\n\ttick_index: I32,\n\tobservation_index: u64,\n\tobservation_cardinality: u64,\n\tobservation_cardinality_next: u64,\n\ttick_spacing: u32,\n\tmax_liquidity_per_tick: u128,\n\tprotocol_fee_rate: u64,\n\tswap_fee_rate: u64,\n\tfee_growth_global_x: u128,\n\tfee_growth_global_y: u128,\n\tprotocol_fee_x: u64,\n\tprotocol_fee_y: u64,\n\tliquidity: u128,\n\tticks: Table<I32, TickInfo>,\n\ttick_bitmap: Table<I32, u256>,\n\tobservations: vector<Observation>,\n\tlocked: bool,\n\treward_infos: vector<PoolRewardInfo>,\n\treserve_x: Balance<Ty0>,\n\treserve_y: Balance<Ty1>\n}\n\nstruct PoolRewardInfo has copy, drop, store {\n\treward_coin_type: TypeName,\n\tlast_update_time: u64,\n\tended_at_seconds: u64,\n\ttotal_reward: u64,\n\ttotal_reward_allocated: u64,\n\treward_per_seconds: u128,\n\treward_growth_global: u128\n}\n\nstruct SwapState has copy, drop {\n\tamount_specified_remaining: u64,\n\tamount_calculated: u64,\n\tsqrt_price: u128,\n\ttick_index: I32,\n\tfee_growth_global: u128,\n\tprotocol_fee: u64,\n\tliquidity: u128,\n\tfee_amount: u64\n}\n\nstruct SwapStepComputations has copy, drop {\n\tsqrt_price_start: u128,\n\ttick_index_next: I32,\n\tinitialized: bool,\n\tsqrt_price_next: u128,\n\tamount_in: u64,\n\tamount_out: u64,\n\tfee_amount: u64\n}\n\nstruct SwapReceipt {\n\tpool_id: ID,\n\tamount_x_debt: u64,\n\tamount_y_debt: u64\n}\n\nstruct FlashReceipt {\n\tpool_id: ID,\n\tamount_x: u64,\n\tamount_y: u64,\n\tfee_x: u64,\n\tfee_y: u64\n}\n\nstruct ModifyLiquidity has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tposition_id: ID,\n\ttick_lower_index: I32,\n\ttick_upper_index: I32,\n\tliquidity_delta: I128,\n\tamount_x: u64,\n\tamount_y: u64\n}\n\nstruct Swap has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tx_for_y: bool,\n\tamount_x: u64,\n\tamount_y: u64,\n\tsqrt_price_before: u128,\n\tsqrt_price_after: u128,\n\tliquidity: u128,\n\ttick_index: I32,\n\tfee_amount: u64\n}\n\nstruct Flash has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tamount_x: u64,\n\tamount_y: u64\n}\n\nstruct Pay has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tamount_x_debt: u64,\n\tamount_y_debt: u64,\n\tpaid_x: u64,\n\tpaid_y: u64\n}\n\nstruct Collect has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tposition_id: ID,\n\tamount_x: u64,\n\tamount_y: u64\n}\n\nstruct CollectProtocolFee has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tamount_x: u64,\n\tamount_y: u64\n}\n\nstruct SetProtocolFeeRate has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tprotocol_fee_rate_x_old: u64,\n\tprotocol_fee_rate_y_old: u64,\n\tprotocol_fee_rate_x_new: u64,\n\tprotocol_fee_rate_y_new: u64\n}\n\nstruct Initialize has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tsqrt_price: u128,\n\ttick_index: I32\n}\n\nstruct IncreaseObservationCardinalityNext has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tobservation_cardinality_next_old: u64,\n\tobservation_cardinality_next_new: u64\n}\n\nstruct InitializePoolReward has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\treward_coin_type: TypeName,\n\tstarted_at_seconds: u64\n}\n\nstruct UpdatePoolRewardEmission has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\treward_coin_type: TypeName,\n\ttotal_reward: u64,\n\tended_at_seconds: u64,\n\treward_per_seconds: u128\n}\n\nstruct CollectPoolReward has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tposition_id: ID,\n\treward_coin_type: TypeName,\n\tamount: u64\n}\n\npublic pool_id<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t2: Ret\n}\n\npublic coin_type_x<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): TypeName {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[0](Pool.coin_type_x: TypeName)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic coin_type_y<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): TypeName {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[1](Pool.coin_type_y: TypeName)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic sqrt_price_current<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[2](Pool.sqrt_price: u128)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic tick_index_current<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): I32 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic observation_index<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[4](Pool.observation_index: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic observation_cardinality<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[5](Pool.observation_cardinality: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic observation_cardinality_next<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[6](Pool.observation_cardinality_next: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic tick_spacing<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u32 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[7](Pool.tick_spacing: u32)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic max_liquidity_per_tick<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[8](Pool.max_liquidity_per_tick: u128)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic protocol_fee_rate<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[9](Pool.protocol_fee_rate: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic swap_fee_rate<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[10](Pool.swap_fee_rate: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic fee_growth_global_x<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[11](Pool.fee_growth_global_x: u128)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic fee_growth_global_y<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[12](Pool.fee_growth_global_y: u128)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic protocol_fee_x<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[13](Pool.protocol_fee_x: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic protocol_fee_y<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[14](Pool.protocol_fee_y: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic liquidity<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic borrow_ticks<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): &Table<I32, TickInfo> {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t2: Ret\n}\n\npublic borrow_tick_bitmap<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): &Table<I32, u256> {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[17](Pool.tick_bitmap: Table<I32, u256>)\n\t2: Ret\n}\n\npublic borrow_observations<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): &vector<Observation> {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[18](Pool.observations: vector<Observation>)\n\t2: Ret\n}\n\npublic is_locked<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[19](Pool.locked: bool)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic reward_length<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[20](Pool.reward_infos: vector<PoolRewardInfo>)\n\t2: VecLen(51)\n\t3: Ret\n}\n\npublic reward_info_at<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>, Arg1: u64): &PoolRewardInfo {\nB0:\n\t0: CopyLoc[1](Arg1: u64)\n\t1: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t2: Call reward_length<Ty0, Ty1>(&Pool<Ty0, Ty1>): u64\n\t3: Ge\n\t4: BrFalse(9)\nB1:\n\t5: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t6: Pop\n\t7: LdConst[11](u64: 11)\n\t8: Abort\nB2:\n\t9: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t10: ImmBorrowFieldGeneric[20](Pool.reward_infos: vector<PoolRewardInfo>)\n\t11: MoveLoc[1](Arg1: u64)\n\t12: VecImmBorrow(51)\n\t13: Ret\n}\n\npublic reward_coin_type<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>, Arg1: u64): TypeName {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call reward_info_at<Ty0, Ty1>(&Pool<Ty0, Ty1>, u64): &PoolRewardInfo\n\t3: ImmBorrowField[21](PoolRewardInfo.reward_coin_type: TypeName)\n\t4: ReadRef\n\t5: Ret\n}\n\npublic reward_last_update_at<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>, Arg1: u64): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call reward_info_at<Ty0, Ty1>(&Pool<Ty0, Ty1>, u64): &PoolRewardInfo\n\t3: ImmBorrowField[22](PoolRewardInfo.last_update_time: u64)\n\t4: ReadRef\n\t5: Ret\n}\n\npublic reward_ended_at<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>, Arg1: u64): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call reward_info_at<Ty0, Ty1>(&Pool<Ty0, Ty1>, u64): &PoolRewardInfo\n\t3: ImmBorrowField[23](PoolRewardInfo.ended_at_seconds: u64)\n\t4: ReadRef\n\t5: Ret\n}\n\npublic total_reward<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>, Arg1: u64): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call reward_info_at<Ty0, Ty1>(&Pool<Ty0, Ty1>, u64): &PoolRewardInfo\n\t3: ImmBorrowField[24](PoolRewardInfo.total_reward: u64)\n\t4: ReadRef\n\t5: Ret\n}\n\npublic total_reward_allocated<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>, Arg1: u64): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call reward_info_at<Ty0, Ty1>(&Pool<Ty0, Ty1>, u64): &PoolRewardInfo\n\t3: ImmBorrowField[25](PoolRewardInfo.total_reward_allocated: u64)\n\t4: ReadRef\n\t5: Ret\n}\n\npublic reward_per_seconds<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>, Arg1: u64): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call reward_info_at<Ty0, Ty1>(&Pool<Ty0, Ty1>, u64): &PoolRewardInfo\n\t3: ImmBorrowField[26](PoolRewardInfo.reward_per_seconds: u128)\n\t4: ReadRef\n\t5: Ret\n}\n\npublic reward_growth_global<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>, Arg1: u64): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call reward_info_at<Ty0, Ty1>(&Pool<Ty0, Ty1>, u64): &PoolRewardInfo\n\t3: ImmBorrowField[27](PoolRewardInfo.reward_growth_global: u128)\n\t4: ReadRef\n\t5: Ret\n}\n\npublic reserves<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>): u64 * u64 {\nB0:\n\t0: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[21](Pool.reserve_x: Balance<Ty0>)\n\t2: Call balance::value<Ty0>(&Balance<Ty0>): u64\n\t3: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t4: ImmBorrowFieldGeneric[22](Pool.reserve_y: Balance<Ty1>)\n\t5: Call balance::value<Ty1>(&Balance<Ty1>): u64\n\t6: Ret\n}\n\npublic swap_receipt_debts(Arg0: &SwapReceipt): u64 * u64 {\nB0:\n\t0: CopyLoc[0](Arg0: &SwapReceipt)\n\t1: ImmBorrowField[30](SwapReceipt.amount_x_debt: u64)\n\t2: ReadRef\n\t3: MoveLoc[0](Arg0: &SwapReceipt)\n\t4: ImmBorrowField[31](SwapReceipt.amount_y_debt: u64)\n\t5: ReadRef\n\t6: Ret\n}\n\npublic flash_receipt_debts(Arg0: &FlashReceipt): u64 * u64 {\nB0:\n\t0: CopyLoc[0](Arg0: &FlashReceipt)\n\t1: ImmBorrowField[32](FlashReceipt.amount_x: u64)\n\t2: ReadRef\n\t3: CopyLoc[0](Arg0: &FlashReceipt)\n\t4: ImmBorrowField[33](FlashReceipt.fee_x: u64)\n\t5: ReadRef\n\t6: Add\n\t7: CopyLoc[0](Arg0: &FlashReceipt)\n\t8: ImmBorrowField[34](FlashReceipt.amount_y: u64)\n\t9: ReadRef\n\t10: MoveLoc[0](Arg0: &FlashReceipt)\n\t11: ImmBorrowField[35](FlashReceipt.fee_y: u64)\n\t12: ReadRef\n\t13: Add\n\t14: Ret\n}\n\npublic(friend) create<Ty0, Ty1>(Arg0: u64, Arg1: u32, Arg2: &mut TxContext): Pool<Ty0, Ty1> {\nL3:\tloc0: UID\nL4:\tloc1: Table<I32, TickInfo>\nL5:\tloc2: Table<I32, u256>\nL6:\tloc3: TypeName\nL7:\tloc4: vector<Observation>\nL8:\tloc5: vector<PoolRewardInfo>\nL9:\tloc6: Balance<Ty0>\nL10:\tloc7: Balance<Ty1>\nL11:\tloc8: TypeName\nL12:\tloc9: I32\nL13:\tloc10: u32\nL14:\tloc11: u128\nL15:\tloc12: u64\nB0:\n\t0: CopyLoc[2](Arg2: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: StLoc[3](loc0: UID)\n\t3: Call type_name::get<Ty0>(): TypeName\n\t4: StLoc[6](loc3: TypeName)\n\t5: Call type_name::get<Ty1>(): TypeName\n\t6: StLoc[11](loc8: TypeName)\n\t7: Call i32::zero(): I32\n\t8: StLoc[12](loc9: I32)\n\t9: CopyLoc[1](Arg1: u32)\n\t10: StLoc[13](loc10: u32)\n\t11: MoveLoc[1](Arg1: u32)\n\t12: Call tick::tick_spacing_to_max_liquidity_per_tick(u32): u128\n\t13: StLoc[14](loc11: u128)\n\t14: MoveLoc[0](Arg0: u64)\n\t15: StLoc[15](loc12: u64)\n\t16: CopyLoc[2](Arg2: &mut TxContext)\n\t17: Call table::new<I32, TickInfo>(&mut TxContext): Table<I32, TickInfo>\n\t18: StLoc[4](loc1: Table<I32, TickInfo>)\n\t19: MoveLoc[2](Arg2: &mut TxContext)\n\t20: Call table::new<I32, u256>(&mut TxContext): Table<I32, u256>\n\t21: StLoc[5](loc2: Table<I32, u256>)\n\t22: VecPack(61, 0)\n\t23: StLoc[7](loc4: vector<Observation>)\n\t24: VecPack(51, 0)\n\t25: StLoc[8](loc5: vector<PoolRewardInfo>)\n\t26: Call balance::zero<Ty0>(): Balance<Ty0>\n\t27: StLoc[9](loc6: Balance<Ty0>)\n\t28: Call balance::zero<Ty1>(): Balance<Ty1>\n\t29: StLoc[10](loc7: Balance<Ty1>)\n\t30: MoveLoc[3](loc0: UID)\n\t31: MoveLoc[6](loc3: TypeName)\n\t32: MoveLoc[11](loc8: TypeName)\n\t33: LdU128(0)\n\t34: MoveLoc[12](loc9: I32)\n\t35: LdU64(0)\n\t36: LdU64(0)\n\t37: LdU64(0)\n\t38: MoveLoc[13](loc10: u32)\n\t39: MoveLoc[14](loc11: u128)\n\t40: LdU64(0)\n\t41: MoveLoc[15](loc12: u64)\n\t42: LdU128(0)\n\t43: LdU128(0)\n\t44: LdU64(0)\n\t45: LdU64(0)\n\t46: LdU128(0)\n\t47: MoveLoc[4](loc1: Table<I32, TickInfo>)\n\t48: MoveLoc[5](loc2: Table<I32, u256>)\n\t49: MoveLoc[7](loc4: vector<Observation>)\n\t50: LdTrue\n\t51: MoveLoc[8](loc5: vector<PoolRewardInfo>)\n\t52: MoveLoc[9](loc6: Balance<Ty0>)\n\t53: MoveLoc[10](loc7: Balance<Ty1>)\n\t54: PackGeneric[0](Pool<Ty0, Ty1>)\n\t55: Ret\n}\n\npublic initialize<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: u128, Arg2: &Versioned, Arg3: &Clock, Arg4: &TxContext) {\nL5:\tloc0: u64\nL6:\tloc1: I32\nB0:\n\t0: MoveLoc[2](Arg2: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t3: ImmBorrowFieldGeneric[2](Pool.sqrt_price: u128)\n\t4: ReadRef\n\t5: LdU128(0)\n\t6: Gt\n\t7: BrFalse(16)\nB1:\n\t8: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t9: Pop\n\t10: MoveLoc[4](Arg4: &TxContext)\n\t11: Pop\n\t12: MoveLoc[3](Arg3: &Clock)\n\t13: Pop\n\t14: LdConst[2](u64: 2)\n\t15: Abort\nB2:\n\t16: CopyLoc[1](Arg1: u128)\n\t17: Call tick_math::get_tick_at_sqrt_price(u128): I32\n\t18: StLoc[6](loc1: I32)\n\t19: CopyLoc[6](loc1: I32)\n\t20: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t21: MutBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t22: WriteRef\n\t23: CopyLoc[1](Arg1: u128)\n\t24: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t25: MutBorrowFieldGeneric[2](Pool.sqrt_price: u128)\n\t26: WriteRef\n\t27: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t28: MutBorrowFieldGeneric[18](Pool.observations: vector<Observation>)\n\t29: MoveLoc[3](Arg3: &Clock)\n\t30: Call clock::timestamp_ms(&Clock): u64\n\t31: Call utils::to_seconds(u64): u64\n\t32: Call oracle::initialize(&mut vector<Observation>, u64): u64 * u64\n\t33: StLoc[5](loc0: u64)\n\t34: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t35: MutBorrowFieldGeneric[5](Pool.observation_cardinality: u64)\n\t36: WriteRef\n\t37: MoveLoc[5](loc0: u64)\n\t38: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t39: MutBorrowFieldGeneric[6](Pool.observation_cardinality_next: u64)\n\t40: WriteRef\n\t41: LdFalse\n\t42: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t43: MutBorrowFieldGeneric[19](Pool.locked: bool)\n\t44: WriteRef\n\t45: MoveLoc[4](Arg4: &TxContext)\n\t46: Call tx_context::sender(&TxContext): address\n\t47: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t48: FreezeRef\n\t49: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t50: MoveLoc[1](Arg1: u128)\n\t51: MoveLoc[6](loc1: I32)\n\t52: Pack[14](Initialize)\n\t53: Call event::emit<Initialize>(Initialize)\n\t54: Ret\n}\n\npublic modify_liquidity<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: &mut Position, Arg2: I128, Arg3: Balance<Ty0>, Arg4: Balance<Ty1>, Arg5: &Versioned, Arg6: &Clock, Arg7: &TxContext): u64 * u64 {\nL8:\tloc0: ID\nL9:\tloc1: bool\nL10:\tloc2: bool\nL11:\tloc3: bool\nL12:\tloc4: u64\nL13:\tloc5: u64\nB0:\n\t0: MoveLoc[5](Arg5: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t3: FreezeRef\n\t4: Call check_lock<Ty0, Ty1>(&Pool<Ty0, Ty1>)\n\t5: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t6: CopyLoc[1](Arg1: &mut Position)\n\t7: FreezeRef\n\t8: Call position::pool_id(&Position): ID\n\t9: StLoc[8](loc0: ID)\n\t10: FreezeRef\n\t11: MoveLoc[8](loc0: ID)\n\t12: Call check_pool_match<Ty0, Ty1>(&Pool<Ty0, Ty1>, ID)\n\t13: CopyLoc[2](Arg2: I128)\n\t14: Call i128::is_neg(I128): bool\n\t15: Not\n\t16: StLoc[11](loc3: bool)\n\t17: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t18: CopyLoc[1](Arg1: &mut Position)\n\t19: CopyLoc[2](Arg2: I128)\n\t20: MoveLoc[6](Arg6: &Clock)\n\t21: Call modify_position<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, &mut Position, I128, &Clock): u64 * u64\n\t22: StLoc[13](loc5: u64)\n\t23: StLoc[12](loc4: u64)\n\t24: MoveLoc[11](loc3: bool)\n\t25: BrFalse(54)\nB1:\n\t26: ImmBorrowLoc[3](Arg3: Balance<Ty0>)\n\t27: Call balance::value<Ty0>(&Balance<Ty0>): u64\n\t28: CopyLoc[12](loc4: u64)\n\t29: Lt\n\t30: BrFalse(34)\nB2:\n\t31: LdTrue\n\t32: StLoc[9](loc1: bool)\n\t33: Branch(39)\nB3:\n\t34: ImmBorrowLoc[4](Arg4: Balance<Ty1>)\n\t35: Call balance::value<Ty1>(&Balance<Ty1>): u64\n\t36: CopyLoc[13](loc5: u64)\n\t37: Lt\n\t38: StLoc[9](loc1: bool)\nB4:\n\t39: MoveLoc[9](loc1: bool)\n\t40: BrFalse(49)\nB5:\n\t41: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t42: Pop\n\t43: MoveLoc[1](Arg1: &mut Position)\n\t44: Pop\n\t45: MoveLoc[7](Arg7: &TxContext)\n\t46: Pop\n\t47: LdConst[1](u64: 1)\n\t48: Abort\nB6:\n\t49: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t50: MoveLoc[3](Arg3: Balance<Ty0>)\n\t51: MoveLoc[4](Arg4: Balance<Ty1>)\n\t52: Call put<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, Balance<Ty0>, Balance<Ty1>)\n\t53: Branch(75)\nB7:\n\t54: MoveLoc[3](Arg3: Balance<Ty0>)\n\t55: Call balance::destroy_zero<Ty0>(Balance<Ty0>)\n\t56: MoveLoc[4](Arg4: Balance<Ty1>)\n\t57: Call balance::destroy_zero<Ty1>(Balance<Ty1>)\n\t58: CopyLoc[12](loc4: u64)\n\t59: LdU64(0)\n\t60: Gt\n\t61: BrFalse(65)\nB8:\n\t62: LdTrue\n\t63: StLoc[10](loc2: bool)\n\t64: Branch(69)\nB9:\n\t65: CopyLoc[13](loc5: u64)\n\t66: LdU64(0)\n\t67: Gt\n\t68: StLoc[10](loc2: bool)\nB10:\n\t69: MoveLoc[10](loc2: bool)\n\t70: BrFalse(75)\nB11:\n\t71: CopyLoc[1](Arg1: &mut Position)\n\t72: CopyLoc[12](loc4: u64)\n\t73: CopyLoc[13](loc5: u64)\n\t74: Call position::increase_debt(&mut Position, u64, u64)\nB12:\n\t75: MoveLoc[7](Arg7: &TxContext)\n\t76: Call tx_context::sender(&TxContext): address\n\t77: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t78: FreezeRef\n\t79: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t80: CopyLoc[1](Arg1: &mut Position)\n\t81: FreezeRef\n\t82: Call object::id<Position>(&Position): ID\n\t83: CopyLoc[1](Arg1: &mut Position)\n\t84: FreezeRef\n\t85: Call position::tick_lower_index(&Position): I32\n\t86: MoveLoc[1](Arg1: &mut Position)\n\t87: FreezeRef\n\t88: Call position::tick_upper_index(&Position): I32\n\t89: MoveLoc[2](Arg2: I128)\n\t90: CopyLoc[12](loc4: u64)\n\t91: CopyLoc[13](loc5: u64)\n\t92: Pack[7](ModifyLiquidity)\n\t93: Call event::emit<ModifyLiquidity>(ModifyLiquidity)\n\t94: MoveLoc[12](loc4: u64)\n\t95: MoveLoc[13](loc5: u64)\n\t96: Ret\n}\n\npublic swap<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: bool, Arg2: bool, Arg3: u64, Arg4: u128, Arg5: &Versioned, Arg6: &Clock, Arg7: &TxContext): Balance<Ty0> * Balance<Ty1> * SwapReceipt {\nL8:\tloc0: u64\nL9:\tloc1: Balance<Ty0>\nL10:\tloc2: Balance<Ty1>\nL11:\tloc3: SwapReceipt\nL12:\tloc4: ID\nL13:\tloc5: address\nL14:\tloc6: bool\nL15:\tloc7: u64\nL16:\tloc8: u64\nL17:\tloc9: u128\nL18:\tloc10: u128\nL19:\tloc11: u128\nL20:\tloc12: u128\nL21:\tloc13: I32\nL22:\tloc14: u64\nL23:\tloc15: bool\nL24:\tloc16: u128\nL25:\tloc17: u128\nL26:\tloc18: u128\nL27:\tloc19: I32\nL28:\tloc20: u64\nL29:\tloc21: u64\nL30:\tloc22: u256\nL31:\tloc23: u64\nL32:\tloc24: u64\nL33:\tloc25: u64\nL34:\tloc26: u64\nL35:\tloc27: bool\nL36:\tloc28: u64\nL37:\tloc29: u64\nL38:\tloc30: u128\nL39:\tloc31: u128\nL40:\tloc32: u128\nL41:\tloc33: bool\nL42:\tloc34: I128\nL43:\tloc35: u64\nL44:\tloc36: u64\nL45:\tloc37: u64\nL46:\tloc38: SwapReceipt\nL47:\tloc39: SwapReceipt\nL48:\tloc40: SwapReceipt\nL49:\tloc41: vector<u128>\nL50:\tloc42: u256\nL51:\tloc43: u128\nL52:\tloc44: u128\nL53:\tloc45: SwapState\nL54:\tloc46: SwapStepComputations\nL55:\tloc47: I64\nL56:\tloc48: u64\nL57:\tloc49: Balance<Ty0>\nL58:\tloc50: Balance<Ty1>\nB0:\n\t0: MoveLoc[5](Arg5: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t3: FreezeRef\n\t4: Call check_lock<Ty0, Ty1>(&Pool<Ty0, Ty1>)\n\t5: CopyLoc[1](Arg1: bool)\n\t6: BrFalse(34)\nB1:\n\t7: CopyLoc[4](Arg4: u128)\n\t8: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t9: ImmBorrowFieldGeneric[2](Pool.sqrt_price: u128)\n\t10: ReadRef\n\t11: Ge\n\t12: BrFalse(21)\nB2:\n\t13: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t14: Pop\n\t15: MoveLoc[7](Arg7: &TxContext)\n\t16: Pop\n\t17: MoveLoc[6](Arg6: &Clock)\n\t18: Pop\n\t19: LdConst[4](u64: 4)\n\t20: Abort\nB3:\n\t21: CopyLoc[4](Arg4: u128)\n\t22: Call tick_math::min_sqrt_price(): u128\n\t23: Le\n\t24: BrFalse(33)\nB4:\n\t25: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t26: Pop\n\t27: MoveLoc[7](Arg7: &TxContext)\n\t28: Pop\n\t29: MoveLoc[6](Arg6: &Clock)\n\t30: Pop\n\t31: LdConst[5](u64: 5)\n\t32: Abort\nB5:\n\t33: Branch(60)\nB6:\n\t34: CopyLoc[4](Arg4: u128)\n\t35: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t36: ImmBorrowFieldGeneric[2](Pool.sqrt_price: u128)\n\t37: ReadRef\n\t38: Le\n\t39: BrFalse(48)\nB7:\n\t40: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t41: Pop\n\t42: MoveLoc[7](Arg7: &TxContext)\n\t43: Pop\n\t44: MoveLoc[6](Arg6: &Clock)\n\t45: Pop\n\t46: LdConst[4](u64: 4)\n\t47: Abort\nB8:\n\t48: CopyLoc[4](Arg4: u128)\n\t49: Call tick_math::max_sqrt_price(): u128\n\t50: Ge\n\t51: BrFalse(60)\nB9:\n\t52: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t53: Pop\n\t54: MoveLoc[7](Arg7: &TxContext)\n\t55: Pop\n\t56: MoveLoc[6](Arg6: &Clock)\n\t57: Pop\n\t58: LdConst[5](u64: 5)\n\t59: Abort\nB10:\n\t60: LdTrue\n\t61: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t62: MutBorrowFieldGeneric[19](Pool.locked: bool)\n\t63: WriteRef\n\t64: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t65: ImmBorrowFieldGeneric[2](Pool.sqrt_price: u128)\n\t66: ReadRef\n\t67: StLoc[51](loc43: u128)\n\t68: MoveLoc[6](Arg6: &Clock)\n\t69: Call clock::timestamp_ms(&Clock): u64\n\t70: Call utils::to_seconds(u64): u64\n\t71: LdFalse\n\t72: Call i64::zero(): I64\n\t73: LdU256(0)\n\t74: StLoc[50](loc42: u256)\n\t75: StLoc[55](loc47: I64)\n\t76: StLoc[35](loc27: bool)\n\t77: StLoc[56](loc48: u64)\n\t78: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t79: CopyLoc[56](loc48: u64)\n\t80: Call update_reward_infos<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, u64): vector<u128>\n\t81: StLoc[49](loc41: vector<u128>)\n\t82: CopyLoc[2](Arg2: bool)\n\t83: BrFalse(91)\nB11:\n\t84: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t85: ImmBorrowFieldGeneric[9](Pool.protocol_fee_rate: u64)\n\t86: ReadRef\n\t87: LdU64(16)\n\t88: Mod\n\t89: StLoc[8](loc0: u64)\n\t90: Branch(97)\nB12:\n\t91: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t92: ImmBorrowFieldGeneric[9](Pool.protocol_fee_rate: u64)\n\t93: ReadRef\n\t94: LdU8(4)\n\t95: Shr\n\t96: StLoc[8](loc0: u64)\nB13:\n\t97: MoveLoc[8](loc0: u64)\n\t98: StLoc[45](loc37: u64)\n\t99: CopyLoc[1](Arg1: bool)\n\t100: BrFalse(106)\nB14:\n\t101: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t102: ImmBorrowFieldGeneric[11](Pool.fee_growth_global_x: u128)\n\t103: ReadRef\n\t104: StLoc[19](loc11: u128)\n\t105: Branch(110)\nB15:\n\t106: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t107: ImmBorrowFieldGeneric[12](Pool.fee_growth_global_y: u128)\n\t108: ReadRef\n\t109: StLoc[19](loc11: u128)\nB16:\n\t110: MoveLoc[19](loc11: u128)\n\t111: StLoc[38](loc30: u128)\n\t112: CopyLoc[3](Arg3: u64)\n\t113: LdU64(0)\n\t114: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t115: ImmBorrowFieldGeneric[2](Pool.sqrt_price: u128)\n\t116: ReadRef\n\t117: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t118: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t119: ReadRef\n\t120: MoveLoc[38](loc30: u128)\n\t121: LdU64(0)\n\t122: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t123: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t124: ReadRef\n\t125: LdU64(0)\n\t126: Pack[3](SwapState)\n\t127: StLoc[53](loc45: SwapState)\nB17:\n\t128: ImmBorrowLoc[53](loc45: SwapState)\n\t129: ImmBorrowField[36](SwapState.amount_specified_remaining: u64)\n\t130: ReadRef\n\t131: LdU64(0)\n\t132: Neq\n\t133: BrFalse(142)\nB18:\n\t134: Branch(135)\nB19:\n\t135: ImmBorrowLoc[53](loc45: SwapState)\n\t136: ImmBorrowField[37](SwapState.sqrt_price: u128)\n\t137: ReadRef\n\t138: CopyLoc[4](Arg4: u128)\n\t139: Neq\n\t140: StLoc[23](loc15: bool)\n\t141: Branch(144)\nB20:\n\t142: LdFalse\n\t143: StLoc[23](loc15: bool)\nB21:\n\t144: MoveLoc[23](loc15: bool)\n\t145: BrFalse(489)\nB22:\n\t146: LdU128(0)\n\t147: Call i32::zero(): I32\n\t148: LdFalse\n\t149: LdU128(0)\n\t150: LdU64(0)\n\t151: LdU64(0)\n\t152: LdU64(0)\n\t153: Pack[4](SwapStepComputations)\n\t154: StLoc[54](loc46: SwapStepComputations)\n\t155: ImmBorrowLoc[53](loc45: SwapState)\n\t156: ImmBorrowField[37](SwapState.sqrt_price: u128)\n\t157: ReadRef\n\t158: MutBorrowLoc[54](loc46: SwapStepComputations)\n\t159: MutBorrowField[38](SwapStepComputations.sqrt_price_start: u128)\n\t160: WriteRef\n\t161: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t162: ImmBorrowFieldGeneric[17](Pool.tick_bitmap: Table<I32, u256>)\n\t163: ImmBorrowLoc[53](loc45: SwapState)\n\t164: ImmBorrowField[39](SwapState.tick_index: I32)\n\t165: ReadRef\n\t166: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t167: ImmBorrowFieldGeneric[7](Pool.tick_spacing: u32)\n\t168: ReadRef\n\t169: CopyLoc[1](Arg1: bool)\n\t170: Call tick_bitmap::next_initialized_tick_within_one_word(&Table<I32, u256>, I32, u32, bool): I32 * bool\n\t171: StLoc[41](loc33: bool)\n\t172: MutBorrowLoc[54](loc46: SwapStepComputations)\n\t173: MutBorrowField[40](SwapStepComputations.tick_index_next: I32)\n\t174: WriteRef\n\t175: MoveLoc[41](loc33: bool)\n\t176: MutBorrowLoc[54](loc46: SwapStepComputations)\n\t177: MutBorrowField[41](SwapStepComputations.initialized: bool)\n\t178: WriteRef\n\t179: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t180: ImmBorrowField[40](SwapStepComputations.tick_index_next: I32)\n\t181: ReadRef\n\t182: Call tick_math::min_tick(): I32\n\t183: Call i32::lt(I32, I32): bool\n\t184: BrFalse(190)\nB23:\n\t185: Call tick_math::min_tick(): I32\n\t186: MutBorrowLoc[54](loc46: SwapStepComputations)\n\t187: MutBorrowField[40](SwapStepComputations.tick_index_next: I32)\n\t188: WriteRef\n\t189: Branch(200)\nB24:\n\t190: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t191: ImmBorrowField[40](SwapStepComputations.tick_index_next: I32)\n\t192: ReadRef\n\t193: Call tick_math::max_tick(): I32\n\t194: Call i32::gt(I32, I32): bool\n\t195: BrFalse(200)\nB25:\n\t196: Call tick_math::max_tick(): I32\n\t197: MutBorrowLoc[54](loc46: SwapStepComputations)\n\t198: MutBorrowField[40](SwapStepComputations.tick_index_next: I32)\n\t199: WriteRef\nB26:\n\t200: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t201: ImmBorrowField[40](SwapStepComputations.tick_index_next: I32)\n\t202: ReadRef\n\t203: Call tick_math::get_sqrt_price_at_tick(I32): u128\n\t204: MutBorrowLoc[54](loc46: SwapStepComputations)\n\t205: MutBorrowField[42](SwapStepComputations.sqrt_price_next: u128)\n\t206: WriteRef\n\t207: CopyLoc[1](Arg1: bool)\n\t208: BrFalse(216)\nB27:\n\t209: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t210: ImmBorrowField[42](SwapStepComputations.sqrt_price_next: u128)\n\t211: ReadRef\n\t212: CopyLoc[4](Arg4: u128)\n\t213: Call full_math_u128::max(u128, u128): u128\n\t214: StLoc[24](loc16: u128)\n\t215: Branch(222)\nB28:\n\t216: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t217: ImmBorrowField[42](SwapStepComputations.sqrt_price_next: u128)\n\t218: ReadRef\n\t219: CopyLoc[4](Arg4: u128)\n\t220: Call full_math_u128::min(u128, u128): u128\n\t221: StLoc[24](loc16: u128)\nB29:\n\t222: MoveLoc[24](loc16: u128)\n\t223: StLoc[52](loc44: u128)\n\t224: ImmBorrowLoc[53](loc45: SwapState)\n\t225: ImmBorrowField[37](SwapState.sqrt_price: u128)\n\t226: ReadRef\n\t227: MoveLoc[52](loc44: u128)\n\t228: ImmBorrowLoc[53](loc45: SwapState)\n\t229: ImmBorrowField[43](SwapState.liquidity: u128)\n\t230: ReadRef\n\t231: ImmBorrowLoc[53](loc45: SwapState)\n\t232: ImmBorrowField[36](SwapState.amount_specified_remaining: u64)\n\t233: ReadRef\n\t234: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t235: ImmBorrowFieldGeneric[10](Pool.swap_fee_rate: u64)\n\t236: ReadRef\n\t237: CopyLoc[2](Arg2: bool)\n\t238: Call swap_math::compute_swap_step(u128, u128, u128, u64, u64, bool): u128 * u64 * u64 * u64\n\t239: StLoc[37](loc29: u64)\n\t240: StLoc[32](loc24: u64)\n\t241: StLoc[31](loc23: u64)\n\t242: MutBorrowLoc[53](loc45: SwapState)\n\t243: MutBorrowField[37](SwapState.sqrt_price: u128)\n\t244: WriteRef\n\t245: MoveLoc[31](loc23: u64)\n\t246: MutBorrowLoc[54](loc46: SwapStepComputations)\n\t247: MutBorrowField[44](SwapStepComputations.amount_in: u64)\n\t248: WriteRef\n\t249: MoveLoc[32](loc24: u64)\n\t250: MutBorrowLoc[54](loc46: SwapStepComputations)\n\t251: MutBorrowField[45](SwapStepComputations.amount_out: u64)\n\t252: WriteRef\n\t253: MoveLoc[37](loc29: u64)\n\t254: MutBorrowLoc[54](loc46: SwapStepComputations)\n\t255: MutBorrowField[46](SwapStepComputations.fee_amount: u64)\n\t256: WriteRef\n\t257: CopyLoc[2](Arg2: bool)\n\t258: BrFalse(284)\nB30:\n\t259: ImmBorrowLoc[53](loc45: SwapState)\n\t260: ImmBorrowField[36](SwapState.amount_specified_remaining: u64)\n\t261: ReadRef\n\t262: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t263: ImmBorrowField[44](SwapStepComputations.amount_in: u64)\n\t264: ReadRef\n\t265: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t266: ImmBorrowField[46](SwapStepComputations.fee_amount: u64)\n\t267: ReadRef\n\t268: Add\n\t269: Sub\n\t270: MutBorrowLoc[53](loc45: SwapState)\n\t271: MutBorrowField[36](SwapState.amount_specified_remaining: u64)\n\t272: WriteRef\n\t273: ImmBorrowLoc[53](loc45: SwapState)\n\t274: ImmBorrowField[47](SwapState.amount_calculated: u64)\n\t275: ReadRef\n\t276: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t277: ImmBorrowField[45](SwapStepComputations.amount_out: u64)\n\t278: ReadRef\n\t279: Add\n\t280: MutBorrowLoc[53](loc45: SwapState)\n\t281: MutBorrowField[47](SwapState.amount_calculated: u64)\n\t282: WriteRef\n\t283: Branch(308)\nB31:\n\t284: ImmBorrowLoc[53](loc45: SwapState)\n\t285: ImmBorrowField[36](SwapState.amount_specified_remaining: u64)\n\t286: ReadRef\n\t287: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t288: ImmBorrowField[45](SwapStepComputations.amount_out: u64)\n\t289: ReadRef\n\t290: Sub\n\t291: MutBorrowLoc[53](loc45: SwapState)\n\t292: MutBorrowField[36](SwapState.amount_specified_remaining: u64)\n\t293: WriteRef\n\t294: ImmBorrowLoc[53](loc45: SwapState)\n\t295: ImmBorrowField[47](SwapState.amount_calculated: u64)\n\t296: ReadRef\n\t297: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t298: ImmBorrowField[44](SwapStepComputations.amount_in: u64)\n\t299: ReadRef\n\t300: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t301: ImmBorrowField[46](SwapStepComputations.fee_amount: u64)\n\t302: ReadRef\n\t303: Add\n\t304: Add\n\t305: MutBorrowLoc[53](loc45: SwapState)\n\t306: MutBorrowField[47](SwapState.amount_calculated: u64)\n\t307: WriteRef\nB32:\n\t308: CopyLoc[45](loc37: u64)\n\t309: LdU64(0)\n\t310: Gt\n\t311: BrFalse(334)\nB33:\n\t312: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t313: ImmBorrowField[46](SwapStepComputations.fee_amount: u64)\n\t314: ReadRef\n\t315: CopyLoc[45](loc37: u64)\n\t316: Div\n\t317: StLoc[36](loc28: u64)\n\t318: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t319: ImmBorrowField[46](SwapStepComputations.fee_amount: u64)\n\t320: ReadRef\n\t321: CopyLoc[36](loc28: u64)\n\t322: Sub\n\t323: MutBorrowLoc[54](loc46: SwapStepComputations)\n\t324: MutBorrowField[46](SwapStepComputations.fee_amount: u64)\n\t325: WriteRef\n\t326: ImmBorrowLoc[53](loc45: SwapState)\n\t327: ImmBorrowField[48](SwapState.protocol_fee: u64)\n\t328: ReadRef\n\t329: MoveLoc[36](loc28: u64)\n\t330: Add\n\t331: MutBorrowLoc[53](loc45: SwapState)\n\t332: MutBorrowField[48](SwapState.protocol_fee: u64)\n\t333: WriteRef\nB34:\n\t334: ImmBorrowLoc[53](loc45: SwapState)\n\t335: ImmBorrowField[43](SwapState.liquidity: u128)\n\t336: ReadRef\n\t337: LdU128(0)\n\t338: Gt\n\t339: BrFalse(357)\nB35:\n\t340: ImmBorrowLoc[53](loc45: SwapState)\n\t341: ImmBorrowField[49](SwapState.fee_growth_global: u128)\n\t342: ReadRef\n\t343: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t344: ImmBorrowField[46](SwapStepComputations.fee_amount: u64)\n\t345: ReadRef\n\t346: CastU128\n\t347: Call constants::get_q64(): u128\n\t348: CastU128\n\t349: ImmBorrowLoc[53](loc45: SwapState)\n\t350: ImmBorrowField[43](SwapState.liquidity: u128)\n\t351: ReadRef\n\t352: Call full_math_u128::mul_div_floor(u128, u128, u128): u128\n\t353: Call full_math_u128::wrapping_add(u128, u128): u128\n\t354: MutBorrowLoc[53](loc45: SwapState)\n\t355: MutBorrowField[49](SwapState.fee_growth_global: u128)\n\t356: WriteRef\nB36:\n\t357: ImmBorrowLoc[53](loc45: SwapState)\n\t358: ImmBorrowField[50](SwapState.fee_amount: u64)\n\t359: ReadRef\n\t360: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t361: ImmBorrowField[46](SwapStepComputations.fee_amount: u64)\n\t362: ReadRef\n\t363: Add\n\t364: MutBorrowLoc[53](loc45: SwapState)\n\t365: MutBorrowField[50](SwapState.fee_amount: u64)\n\t366: WriteRef\n\t367: ImmBorrowLoc[53](loc45: SwapState)\n\t368: ImmBorrowField[37](SwapState.sqrt_price: u128)\n\t369: ReadRef\n\t370: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t371: ImmBorrowField[42](SwapStepComputations.sqrt_price_next: u128)\n\t372: ReadRef\n\t373: Eq\n\t374: BrFalse(473)\nB37:\n\t375: CopyLoc[1](Arg1: bool)\n\t376: BrFalse(386)\nB38:\n\t377: ImmBorrowLoc[53](loc45: SwapState)\n\t378: ImmBorrowField[49](SwapState.fee_growth_global: u128)\n\t379: ReadRef\n\t380: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t381: ImmBorrowFieldGeneric[12](Pool.fee_growth_global_y: u128)\n\t382: ReadRef\n\t383: StLoc[26](loc18: u128)\n\t384: StLoc[25](loc17: u128)\n\t385: Branch(394)\nB39:\n\t386: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t387: ImmBorrowFieldGeneric[11](Pool.fee_growth_global_x: u128)\n\t388: ReadRef\n\t389: ImmBorrowLoc[53](loc45: SwapState)\n\t390: ImmBorrowField[49](SwapState.fee_growth_global: u128)\n\t391: ReadRef\n\t392: StLoc[26](loc18: u128)\n\t393: StLoc[25](loc17: u128)\nB40:\n\t394: MoveLoc[25](loc17: u128)\n\t395: MoveLoc[26](loc18: u128)\n\t396: StLoc[40](loc32: u128)\n\t397: StLoc[39](loc31: u128)\n\t398: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t399: ImmBorrowField[41](SwapStepComputations.initialized: bool)\n\t400: ReadRef\n\t401: BrFalse(454)\nB41:\n\t402: CopyLoc[35](loc27: bool)\n\t403: Not\n\t404: BrFalse(428)\nB42:\n\t405: LdTrue\n\t406: StLoc[35](loc27: bool)\n\t407: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t408: ImmBorrowFieldGeneric[18](Pool.observations: vector<Observation>)\n\t409: CopyLoc[56](loc48: u64)\n\t410: LdU64(0)\n\t411: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t412: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t413: ReadRef\n\t414: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t415: ImmBorrowFieldGeneric[4](Pool.observation_index: u64)\n\t416: ReadRef\n\t417: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t418: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t419: ReadRef\n\t420: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t421: ImmBorrowFieldGeneric[5](Pool.observation_cardinality: u64)\n\t422: ReadRef\n\t423: Call oracle::observe_single(&vector<Observation>, u64, u64, I32, u64, u128, u64): I64 * u256\n\t424: StLoc[30](loc22: u256)\n\t425: StLoc[55](loc47: I64)\n\t426: MoveLoc[30](loc22: u256)\n\t427: StLoc[50](loc42: u256)\nB43:\n\t428: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t429: MutBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t430: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t431: ImmBorrowField[40](SwapStepComputations.tick_index_next: I32)\n\t432: ReadRef\n\t433: MoveLoc[39](loc31: u128)\n\t434: MoveLoc[40](loc32: u128)\n\t435: CopyLoc[49](loc41: vector<u128>)\n\t436: CopyLoc[50](loc42: u256)\n\t437: CopyLoc[55](loc47: I64)\n\t438: CopyLoc[56](loc48: u64)\n\t439: Call tick::cross(&mut Table<I32, TickInfo>, I32, u128, u128, vector<u128>, u256, I64, u64): I128\n\t440: StLoc[42](loc34: I128)\n\t441: CopyLoc[1](Arg1: bool)\n\t442: BrFalse(446)\nB44:\n\t443: MoveLoc[42](loc34: I128)\n\t444: Call i128::neg(I128): I128\n\t445: StLoc[42](loc34: I128)\nB45:\n\t446: ImmBorrowLoc[53](loc45: SwapState)\n\t447: ImmBorrowField[43](SwapState.liquidity: u128)\n\t448: ReadRef\n\t449: MoveLoc[42](loc34: I128)\n\t450: Call liquidity_math::add_delta(u128, I128): u128\n\t451: MutBorrowLoc[53](loc45: SwapState)\n\t452: MutBorrowField[43](SwapState.liquidity: u128)\n\t453: WriteRef\nB46:\n\t454: CopyLoc[1](Arg1: bool)\n\t455: BrFalse(464)\nB47:\n\t456: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t457: ImmBorrowField[40](SwapStepComputations.tick_index_next: I32)\n\t458: ReadRef\n\t459: LdU32(1)\n\t460: Call i32::from(u32): I32\n\t461: Call i32::sub(I32, I32): I32\n\t462: StLoc[27](loc19: I32)\n\t463: Branch(468)\nB48:\n\t464: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t465: ImmBorrowField[40](SwapStepComputations.tick_index_next: I32)\n\t466: ReadRef\n\t467: StLoc[27](loc19: I32)\nB49:\n\t468: MoveLoc[27](loc19: I32)\n\t469: MutBorrowLoc[53](loc45: SwapState)\n\t470: MutBorrowField[39](SwapState.tick_index: I32)\n\t471: WriteRef\n\t472: Branch(488)\nB50:\n\t473: ImmBorrowLoc[53](loc45: SwapState)\n\t474: ImmBorrowField[37](SwapState.sqrt_price: u128)\n\t475: ReadRef\n\t476: ImmBorrowLoc[54](loc46: SwapStepComputations)\n\t477: ImmBorrowField[38](SwapStepComputations.sqrt_price_start: u128)\n\t478: ReadRef\n\t479: Neq\n\t480: BrFalse(488)\nB51:\n\t481: ImmBorrowLoc[53](loc45: SwapState)\n\t482: ImmBorrowField[37](SwapState.sqrt_price: u128)\n\t483: ReadRef\n\t484: Call tick_math::get_tick_at_sqrt_price(u128): I32\n\t485: MutBorrowLoc[53](loc45: SwapState)\n\t486: MutBorrowField[39](SwapState.tick_index: I32)\n\t487: WriteRef\nB52:\n\t488: Branch(128)\nB53:\n\t489: ImmBorrowLoc[53](loc45: SwapState)\n\t490: ImmBorrowField[39](SwapState.tick_index: I32)\n\t491: ReadRef\n\t492: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t493: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t494: ReadRef\n\t495: Call i32::eq(I32, I32): bool\n\t496: Not\n\t497: BrFalse(540)\nB54:\n\t498: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t499: MutBorrowFieldGeneric[18](Pool.observations: vector<Observation>)\n\t500: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t501: ImmBorrowFieldGeneric[4](Pool.observation_index: u64)\n\t502: ReadRef\n\t503: MoveLoc[56](loc48: u64)\n\t504: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t505: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t506: ReadRef\n\t507: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t508: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t509: ReadRef\n\t510: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t511: ImmBorrowFieldGeneric[5](Pool.observation_cardinality: u64)\n\t512: ReadRef\n\t513: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t514: ImmBorrowFieldGeneric[6](Pool.observation_cardinality_next: u64)\n\t515: ReadRef\n\t516: Call oracle::write(&mut vector<Observation>, u64, u64, I32, u128, u64, u64): u64 * u64\n\t517: StLoc[43](loc35: u64)\n\t518: StLoc[44](loc36: u64)\n\t519: ImmBorrowLoc[53](loc45: SwapState)\n\t520: ImmBorrowField[37](SwapState.sqrt_price: u128)\n\t521: ReadRef\n\t522: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t523: MutBorrowFieldGeneric[2](Pool.sqrt_price: u128)\n\t524: WriteRef\n\t525: ImmBorrowLoc[53](loc45: SwapState)\n\t526: ImmBorrowField[39](SwapState.tick_index: I32)\n\t527: ReadRef\n\t528: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t529: MutBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t530: WriteRef\n\t531: MoveLoc[44](loc36: u64)\n\t532: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t533: MutBorrowFieldGeneric[4](Pool.observation_index: u64)\n\t534: WriteRef\n\t535: MoveLoc[43](loc35: u64)\n\t536: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t537: MutBorrowFieldGeneric[5](Pool.observation_cardinality: u64)\n\t538: WriteRef\n\t539: Branch(546)\nB55:\n\t540: ImmBorrowLoc[53](loc45: SwapState)\n\t541: ImmBorrowField[37](SwapState.sqrt_price: u128)\n\t542: ReadRef\n\t543: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t544: MutBorrowFieldGeneric[2](Pool.sqrt_price: u128)\n\t545: WriteRef\nB56:\n\t546: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t547: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t548: ReadRef\n\t549: ImmBorrowLoc[53](loc45: SwapState)\n\t550: ImmBorrowField[43](SwapState.liquidity: u128)\n\t551: ReadRef\n\t552: Neq\n\t553: BrFalse(560)\nB57:\n\t554: ImmBorrowLoc[53](loc45: SwapState)\n\t555: ImmBorrowField[43](SwapState.liquidity: u128)\n\t556: ReadRef\n\t557: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t558: MutBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t559: WriteRef\nB58:\n\t560: CopyLoc[1](Arg1: bool)\n\t561: BrFalse(579)\nB59:\n\t562: ImmBorrowLoc[53](loc45: SwapState)\n\t563: ImmBorrowField[49](SwapState.fee_growth_global: u128)\n\t564: ReadRef\n\t565: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t566: MutBorrowFieldGeneric[11](Pool.fee_growth_global_x: u128)\n\t567: WriteRef\n\t568: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t569: ImmBorrowFieldGeneric[13](Pool.protocol_fee_x: u64)\n\t570: ReadRef\n\t571: ImmBorrowLoc[53](loc45: SwapState)\n\t572: ImmBorrowField[48](SwapState.protocol_fee: u64)\n\t573: ReadRef\n\t574: Add\n\t575: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t576: MutBorrowFieldGeneric[13](Pool.protocol_fee_x: u64)\n\t577: WriteRef\n\t578: Branch(595)\nB60:\n\t579: ImmBorrowLoc[53](loc45: SwapState)\n\t580: ImmBorrowField[49](SwapState.fee_growth_global: u128)\n\t581: ReadRef\n\t582: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t583: MutBorrowFieldGeneric[12](Pool.fee_growth_global_y: u128)\n\t584: WriteRef\n\t585: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t586: ImmBorrowFieldGeneric[14](Pool.protocol_fee_y: u64)\n\t587: ReadRef\n\t588: ImmBorrowLoc[53](loc45: SwapState)\n\t589: ImmBorrowField[48](SwapState.protocol_fee: u64)\n\t590: ReadRef\n\t591: Add\n\t592: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t593: MutBorrowFieldGeneric[14](Pool.protocol_fee_y: u64)\n\t594: WriteRef\nB61:\n\t595: CopyLoc[1](Arg1: bool)\n\t596: MoveLoc[2](Arg2: bool)\n\t597: Eq\n\t598: BrFalse(610)\nB62:\n\t599: MoveLoc[3](Arg3: u64)\n\t600: ImmBorrowLoc[53](loc45: SwapState)\n\t601: ImmBorrowField[36](SwapState.amount_specified_remaining: u64)\n\t602: ReadRef\n\t603: Sub\n\t604: ImmBorrowLoc[53](loc45: SwapState)\n\t605: ImmBorrowField[47](SwapState.amount_calculated: u64)\n\t606: ReadRef\n\t607: StLoc[29](loc21: u64)\n\t608: StLoc[28](loc20: u64)\n\t609: Branch(620)\nB63:\n\t610: ImmBorrowLoc[53](loc45: SwapState)\n\t611: ImmBorrowField[47](SwapState.amount_calculated: u64)\n\t612: ReadRef\n\t613: MoveLoc[3](Arg3: u64)\n\t614: ImmBorrowLoc[53](loc45: SwapState)\n\t615: ImmBorrowField[36](SwapState.amount_specified_remaining: u64)\n\t616: ReadRef\n\t617: Sub\n\t618: StLoc[29](loc21: u64)\n\t619: StLoc[28](loc20: u64)\nB64:\n\t620: MoveLoc[28](loc20: u64)\n\t621: MoveLoc[29](loc21: u64)\n\t622: StLoc[34](loc26: u64)\n\t623: StLoc[33](loc25: u64)\n\t624: CopyLoc[1](Arg1: bool)\n\t625: BrFalse(642)\nB65:\n\t626: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t627: FreezeRef\n\t628: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t629: CopyLoc[33](loc25: u64)\n\t630: LdU64(0)\n\t631: Pack[5](SwapReceipt)\n\t632: StLoc[46](loc38: SwapReceipt)\n\t633: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t634: LdU64(0)\n\t635: CopyLoc[34](loc26: u64)\n\t636: Call take<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, u64, u64): Balance<Ty0> * Balance<Ty1>\n\t637: MoveLoc[46](loc38: SwapReceipt)\n\t638: StLoc[11](loc3: SwapReceipt)\n\t639: StLoc[10](loc2: Balance<Ty1>)\n\t640: StLoc[9](loc1: Balance<Ty0>)\n\t641: Branch(657)\nB66:\n\t642: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t643: FreezeRef\n\t644: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t645: LdU64(0)\n\t646: CopyLoc[34](loc26: u64)\n\t647: Pack[5](SwapReceipt)\n\t648: StLoc[47](loc39: SwapReceipt)\n\t649: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t650: CopyLoc[33](loc25: u64)\n\t651: LdU64(0)\n\t652: Call take<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, u64, u64): Balance<Ty0> * Balance<Ty1>\n\t653: MoveLoc[47](loc39: SwapReceipt)\n\t654: StLoc[11](loc3: SwapReceipt)\n\t655: StLoc[10](loc2: Balance<Ty1>)\n\t656: StLoc[9](loc1: Balance<Ty0>)\nB67:\n\t657: MoveLoc[9](loc1: Balance<Ty0>)\n\t658: MoveLoc[10](loc2: Balance<Ty1>)\n\t659: MoveLoc[11](loc3: SwapReceipt)\n\t660: StLoc[48](loc40: SwapReceipt)\n\t661: StLoc[58](loc50: Balance<Ty1>)\n\t662: StLoc[57](loc49: Balance<Ty0>)\n\t663: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t664: FreezeRef\n\t665: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t666: StLoc[12](loc4: ID)\n\t667: MoveLoc[7](Arg7: &TxContext)\n\t668: Call tx_context::sender(&TxContext): address\n\t669: StLoc[13](loc5: address)\n\t670: MoveLoc[1](Arg1: bool)\n\t671: StLoc[14](loc6: bool)\n\t672: MoveLoc[33](loc25: u64)\n\t673: StLoc[15](loc7: u64)\n\t674: MoveLoc[34](loc26: u64)\n\t675: StLoc[16](loc8: u64)\n\t676: MoveLoc[51](loc43: u128)\n\t677: StLoc[17](loc9: u128)\n\t678: ImmBorrowLoc[53](loc45: SwapState)\n\t679: ImmBorrowField[37](SwapState.sqrt_price: u128)\n\t680: ReadRef\n\t681: StLoc[18](loc10: u128)\n\t682: ImmBorrowLoc[53](loc45: SwapState)\n\t683: ImmBorrowField[43](SwapState.liquidity: u128)\n\t684: ReadRef\n\t685: StLoc[20](loc12: u128)\n\t686: ImmBorrowLoc[53](loc45: SwapState)\n\t687: ImmBorrowField[39](SwapState.tick_index: I32)\n\t688: ReadRef\n\t689: StLoc[21](loc13: I32)\n\t690: ImmBorrowLoc[53](loc45: SwapState)\n\t691: ImmBorrowField[50](SwapState.fee_amount: u64)\n\t692: ReadRef\n\t693: StLoc[22](loc14: u64)\n\t694: MoveLoc[13](loc5: address)\n\t695: MoveLoc[12](loc4: ID)\n\t696: MoveLoc[14](loc6: bool)\n\t697: MoveLoc[15](loc7: u64)\n\t698: MoveLoc[16](loc8: u64)\n\t699: MoveLoc[17](loc9: u128)\n\t700: MoveLoc[18](loc10: u128)\n\t701: MoveLoc[20](loc12: u128)\n\t702: MoveLoc[21](loc13: I32)\n\t703: MoveLoc[22](loc14: u64)\n\t704: Pack[8](Swap)\n\t705: Call event::emit<Swap>(Swap)\n\t706: MoveLoc[57](loc49: Balance<Ty0>)\n\t707: MoveLoc[58](loc50: Balance<Ty1>)\n\t708: MoveLoc[48](loc40: SwapReceipt)\n\t709: Ret\n}\n\npublic pay<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: SwapReceipt, Arg2: Balance<Ty0>, Arg3: Balance<Ty1>, Arg4: &Versioned, Arg5: &TxContext) {\nL6:\tloc0: ID\nL7:\tloc1: bool\nL8:\tloc2: u64\nL9:\tloc3: u64\nL10:\tloc4: u64\nL11:\tloc5: u64\nL12:\tloc6: u64\nL13:\tloc7: u64\nB0:\n\t0: MoveLoc[4](Arg4: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t3: ImmBorrowLoc[1](Arg1: SwapReceipt)\n\t4: ImmBorrowField[51](SwapReceipt.pool_id: ID)\n\t5: ReadRef\n\t6: StLoc[6](loc0: ID)\n\t7: FreezeRef\n\t8: MoveLoc[6](loc0: ID)\n\t9: Call check_pool_match<Ty0, Ty1>(&Pool<Ty0, Ty1>, ID)\n\t10: MoveLoc[1](Arg1: SwapReceipt)\n\t11: Unpack[5](SwapReceipt)\n\t12: StLoc[9](loc3: u64)\n\t13: StLoc[8](loc2: u64)\n\t14: Pop\n\t15: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t16: FreezeRef\n\t17: Call reserves<Ty0, Ty1>(&Pool<Ty0, Ty1>): u64 * u64\n\t18: StLoc[13](loc7: u64)\n\t19: StLoc[11](loc5: u64)\n\t20: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t21: MoveLoc[2](Arg2: Balance<Ty0>)\n\t22: MoveLoc[3](Arg3: Balance<Ty1>)\n\t23: Call put<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, Balance<Ty0>, Balance<Ty1>)\n\t24: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t25: FreezeRef\n\t26: Call reserves<Ty0, Ty1>(&Pool<Ty0, Ty1>): u64 * u64\n\t27: StLoc[12](loc6: u64)\n\t28: StLoc[10](loc4: u64)\n\t29: CopyLoc[11](loc5: u64)\n\t30: CopyLoc[8](loc2: u64)\n\t31: Add\n\t32: CopyLoc[10](loc4: u64)\n\t33: Gt\n\t34: BrFalse(38)\nB1:\n\t35: LdTrue\n\t36: StLoc[7](loc1: bool)\n\t37: Branch(44)\nB2:\n\t38: CopyLoc[13](loc7: u64)\n\t39: CopyLoc[9](loc3: u64)\n\t40: Add\n\t41: CopyLoc[12](loc6: u64)\n\t42: Gt\n\t43: StLoc[7](loc1: bool)\nB3:\n\t44: MoveLoc[7](loc1: bool)\n\t45: BrFalse(52)\nB4:\n\t46: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t47: Pop\n\t48: MoveLoc[5](Arg5: &TxContext)\n\t49: Pop\n\t50: LdConst[1](u64: 1)\n\t51: Abort\nB5:\n\t52: LdFalse\n\t53: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t54: MutBorrowFieldGeneric[19](Pool.locked: bool)\n\t55: WriteRef\n\t56: MoveLoc[5](Arg5: &TxContext)\n\t57: Call tx_context::sender(&TxContext): address\n\t58: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t59: FreezeRef\n\t60: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t61: MoveLoc[8](loc2: u64)\n\t62: MoveLoc[9](loc3: u64)\n\t63: MoveLoc[10](loc4: u64)\n\t64: MoveLoc[11](loc5: u64)\n\t65: Sub\n\t66: MoveLoc[12](loc6: u64)\n\t67: MoveLoc[13](loc7: u64)\n\t68: Sub\n\t69: Pack[10](Pay)\n\t70: Call event::emit<Pay>(Pay)\n\t71: Ret\n}\n\npublic flash<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: u64, Arg2: u64, Arg3: &Versioned, Arg4: &TxContext): Balance<Ty0> * Balance<Ty1> * FlashReceipt {\nL5:\tloc0: u64\nL6:\tloc1: u64\nL7:\tloc2: Balance<Ty0>\nL8:\tloc3: Balance<Ty1>\nB0:\n\t0: MoveLoc[3](Arg3: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t3: FreezeRef\n\t4: Call check_lock<Ty0, Ty1>(&Pool<Ty0, Ty1>)\n\t5: LdTrue\n\t6: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t7: MutBorrowFieldGeneric[19](Pool.locked: bool)\n\t8: WriteRef\n\t9: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t10: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t11: ReadRef\n\t12: LdU128(0)\n\t13: Eq\n\t14: BrFalse(21)\nB1:\n\t15: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t16: Pop\n\t17: MoveLoc[4](Arg4: &TxContext)\n\t18: Pop\n\t19: LdConst[6](u64: 6)\n\t20: Abort\nB2:\n\t21: CopyLoc[1](Arg1: u64)\n\t22: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t23: ImmBorrowFieldGeneric[10](Pool.swap_fee_rate: u64)\n\t24: ReadRef\n\t25: Call constants::get_fee_rate_denominator_value(): u64\n\t26: Call full_math_u64::mul_div_round(u64, u64, u64): u64\n\t27: CopyLoc[2](Arg2: u64)\n\t28: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t29: ImmBorrowFieldGeneric[10](Pool.swap_fee_rate: u64)\n\t30: ReadRef\n\t31: Call constants::get_fee_rate_denominator_value(): u64\n\t32: Call full_math_u64::mul_div_round(u64, u64, u64): u64\n\t33: StLoc[6](loc1: u64)\n\t34: StLoc[5](loc0: u64)\n\t35: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t36: MutBorrowFieldGeneric[21](Pool.reserve_x: Balance<Ty0>)\n\t37: CopyLoc[1](Arg1: u64)\n\t38: Call balance::split<Ty0>(&mut Balance<Ty0>, u64): Balance<Ty0>\n\t39: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t40: MutBorrowFieldGeneric[22](Pool.reserve_y: Balance<Ty1>)\n\t41: CopyLoc[2](Arg2: u64)\n\t42: Call balance::split<Ty1>(&mut Balance<Ty1>, u64): Balance<Ty1>\n\t43: StLoc[8](loc3: Balance<Ty1>)\n\t44: StLoc[7](loc2: Balance<Ty0>)\n\t45: MoveLoc[4](Arg4: &TxContext)\n\t46: Call tx_context::sender(&TxContext): address\n\t47: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t48: FreezeRef\n\t49: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t50: CopyLoc[1](Arg1: u64)\n\t51: CopyLoc[2](Arg2: u64)\n\t52: Pack[9](Flash)\n\t53: Call event::emit<Flash>(Flash)\n\t54: MoveLoc[7](loc2: Balance<Ty0>)\n\t55: MoveLoc[8](loc3: Balance<Ty1>)\n\t56: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t57: FreezeRef\n\t58: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t59: MoveLoc[1](Arg1: u64)\n\t60: MoveLoc[2](Arg2: u64)\n\t61: MoveLoc[5](loc0: u64)\n\t62: MoveLoc[6](loc1: u64)\n\t63: Pack[6](FlashReceipt)\n\t64: Ret\n}\n\npublic repay<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: FlashReceipt, Arg2: Balance<Ty0>, Arg3: Balance<Ty1>, Arg4: &Versioned, Arg5: &TxContext) {\nL6:\tloc0: ID\nL7:\tloc1: bool\nL8:\tloc2: u64\nL9:\tloc3: u64\nL10:\tloc4: u64\nL11:\tloc5: u64\nL12:\tloc6: u64\nL13:\tloc7: u64\nL14:\tloc8: u64\nL15:\tloc9: u64\nL16:\tloc10: u64\nL17:\tloc11: u64\nL18:\tloc12: u64\nL19:\tloc13: u64\nL20:\tloc14: u64\nL21:\tloc15: u64\nL22:\tloc16: u64\nL23:\tloc17: u64\nB0:\n\t0: MoveLoc[4](Arg4: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t3: ImmBorrowLoc[1](Arg1: FlashReceipt)\n\t4: ImmBorrowField[52](FlashReceipt.pool_id: ID)\n\t5: ReadRef\n\t6: StLoc[6](loc0: ID)\n\t7: FreezeRef\n\t8: MoveLoc[6](loc0: ID)\n\t9: Call check_pool_match<Ty0, Ty1>(&Pool<Ty0, Ty1>, ID)\n\t10: MoveLoc[1](Arg1: FlashReceipt)\n\t11: Unpack[6](FlashReceipt)\n\t12: StLoc[18](loc12: u64)\n\t13: StLoc[16](loc10: u64)\n\t14: StLoc[11](loc5: u64)\n\t15: StLoc[10](loc4: u64)\n\t16: Pop\n\t17: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t18: FreezeRef\n\t19: Call reserves<Ty0, Ty1>(&Pool<Ty0, Ty1>): u64 * u64\n\t20: StLoc[15](loc9: u64)\n\t21: StLoc[13](loc7: u64)\n\t22: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t23: MoveLoc[2](Arg2: Balance<Ty0>)\n\t24: MoveLoc[3](Arg3: Balance<Ty1>)\n\t25: Call put<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, Balance<Ty0>, Balance<Ty1>)\n\t26: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t27: FreezeRef\n\t28: Call reserves<Ty0, Ty1>(&Pool<Ty0, Ty1>): u64 * u64\n\t29: StLoc[14](loc8: u64)\n\t30: StLoc[12](loc6: u64)\n\t31: CopyLoc[13](loc7: u64)\n\t32: CopyLoc[10](loc4: u64)\n\t33: CopyLoc[16](loc10: u64)\n\t34: Add\n\t35: Add\n\t36: CopyLoc[12](loc6: u64)\n\t37: Gt\n\t38: BrFalse(42)\nB1:\n\t39: LdTrue\n\t40: StLoc[7](loc1: bool)\n\t41: Branch(50)\nB2:\n\t42: CopyLoc[15](loc9: u64)\n\t43: CopyLoc[11](loc5: u64)\n\t44: CopyLoc[18](loc12: u64)\n\t45: Add\n\t46: Add\n\t47: CopyLoc[14](loc8: u64)\n\t48: Gt\n\t49: StLoc[7](loc1: bool)\nB3:\n\t50: MoveLoc[7](loc1: bool)\n\t51: BrFalse(58)\nB4:\n\t52: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t53: Pop\n\t54: MoveLoc[5](Arg5: &TxContext)\n\t55: Pop\n\t56: LdConst[1](u64: 1)\n\t57: Abort\nB5:\n\t58: MoveLoc[12](loc6: u64)\n\t59: MoveLoc[13](loc7: u64)\n\t60: CopyLoc[10](loc4: u64)\n\t61: Add\n\t62: Sub\n\t63: StLoc[20](loc14: u64)\n\t64: MoveLoc[14](loc8: u64)\n\t65: MoveLoc[15](loc9: u64)\n\t66: CopyLoc[11](loc5: u64)\n\t67: Add\n\t68: Sub\n\t69: StLoc[21](loc15: u64)\n\t70: CopyLoc[20](loc14: u64)\n\t71: LdU64(0)\n\t72: Gt\n\t73: BrFalse(118)\nB6:\n\t74: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t75: ImmBorrowFieldGeneric[9](Pool.protocol_fee_rate: u64)\n\t76: ReadRef\n\t77: LdU64(16)\n\t78: Mod\n\t79: StLoc[22](loc16: u64)\n\t80: CopyLoc[22](loc16: u64)\n\t81: LdU64(0)\n\t82: Eq\n\t83: BrFalse(87)\nB7:\n\t84: LdU64(0)\n\t85: StLoc[8](loc2: u64)\n\t86: Branch(91)\nB8:\n\t87: CopyLoc[20](loc14: u64)\n\t88: MoveLoc[22](loc16: u64)\n\t89: Div\n\t90: StLoc[8](loc2: u64)\nB9:\n\t91: MoveLoc[8](loc2: u64)\n\t92: StLoc[17](loc11: u64)\n\t93: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t94: ImmBorrowFieldGeneric[13](Pool.protocol_fee_x: u64)\n\t95: ReadRef\n\t96: CopyLoc[17](loc11: u64)\n\t97: Add\n\t98: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t99: MutBorrowFieldGeneric[13](Pool.protocol_fee_x: u64)\n\t100: WriteRef\n\t101: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t102: ImmBorrowFieldGeneric[11](Pool.fee_growth_global_x: u128)\n\t103: ReadRef\n\t104: CopyLoc[20](loc14: u64)\n\t105: MoveLoc[17](loc11: u64)\n\t106: Sub\n\t107: CastU128\n\t108: Call constants::get_q64(): u128\n\t109: CastU128\n\t110: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t111: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t112: ReadRef\n\t113: Call full_math_u128::mul_div_floor(u128, u128, u128): u128\n\t114: Call full_math_u128::wrapping_add(u128, u128): u128\n\t115: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t116: MutBorrowFieldGeneric[11](Pool.fee_growth_global_x: u128)\n\t117: WriteRef\nB10:\n\t118: CopyLoc[21](loc15: u64)\n\t119: LdU64(0)\n\t120: Gt\n\t121: BrFalse(166)\nB11:\n\t122: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t123: ImmBorrowFieldGeneric[9](Pool.protocol_fee_rate: u64)\n\t124: ReadRef\n\t125: LdU8(4)\n\t126: Shr\n\t127: StLoc[23](loc17: u64)\n\t128: CopyLoc[23](loc17: u64)\n\t129: LdU64(0)\n\t130: Eq\n\t131: BrFalse(135)\nB12:\n\t132: LdU64(0)\n\t133: StLoc[9](loc3: u64)\n\t134: Branch(139)\nB13:\n\t135: CopyLoc[21](loc15: u64)\n\t136: MoveLoc[23](loc17: u64)\n\t137: Div\n\t138: StLoc[9](loc3: u64)\nB14:\n\t139: MoveLoc[9](loc3: u64)\n\t140: StLoc[19](loc13: u64)\n\t141: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t142: ImmBorrowFieldGeneric[14](Pool.protocol_fee_y: u64)\n\t143: ReadRef\n\t144: CopyLoc[19](loc13: u64)\n\t145: Add\n\t146: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t147: MutBorrowFieldGeneric[14](Pool.protocol_fee_y: u64)\n\t148: WriteRef\n\t149: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t150: ImmBorrowFieldGeneric[12](Pool.fee_growth_global_y: u128)\n\t151: ReadRef\n\t152: CopyLoc[21](loc15: u64)\n\t153: MoveLoc[19](loc13: u64)\n\t154: Sub\n\t155: CastU128\n\t156: Call constants::get_q64(): u128\n\t157: CastU128\n\t158: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t159: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t160: ReadRef\n\t161: Call full_math_u128::mul_div_floor(u128, u128, u128): u128\n\t162: Call full_math_u128::wrapping_add(u128, u128): u128\n\t163: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t164: MutBorrowFieldGeneric[12](Pool.fee_growth_global_y: u128)\n\t165: WriteRef\nB15:\n\t166: LdFalse\n\t167: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t168: MutBorrowFieldGeneric[19](Pool.locked: bool)\n\t169: WriteRef\n\t170: MoveLoc[5](Arg5: &TxContext)\n\t171: Call tx_context::sender(&TxContext): address\n\t172: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t173: FreezeRef\n\t174: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t175: MoveLoc[10](loc4: u64)\n\t176: MoveLoc[16](loc10: u64)\n\t177: Add\n\t178: MoveLoc[11](loc5: u64)\n\t179: MoveLoc[18](loc12: u64)\n\t180: Add\n\t181: MoveLoc[20](loc14: u64)\n\t182: MoveLoc[21](loc15: u64)\n\t183: Pack[10](Pay)\n\t184: Call event::emit<Pay>(Pay)\n\t185: Ret\n}\n\npublic collect<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: &mut Position, Arg2: u64, Arg3: u64, Arg4: &Versioned, Arg5: &TxContext): Balance<Ty0> * Balance<Ty1> {\nL6:\tloc0: ID\nL7:\tloc1: u64\nL8:\tloc2: u64\nB0:\n\t0: MoveLoc[4](Arg4: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t3: FreezeRef\n\t4: Call check_lock<Ty0, Ty1>(&Pool<Ty0, Ty1>)\n\t5: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t6: CopyLoc[1](Arg1: &mut Position)\n\t7: FreezeRef\n\t8: Call position::pool_id(&Position): ID\n\t9: StLoc[6](loc0: ID)\n\t10: FreezeRef\n\t11: MoveLoc[6](loc0: ID)\n\t12: Call check_pool_match<Ty0, Ty1>(&Pool<Ty0, Ty1>, ID)\n\t13: MoveLoc[2](Arg2: u64)\n\t14: CopyLoc[1](Arg1: &mut Position)\n\t15: FreezeRef\n\t16: Call position::coins_owed_x(&Position): u64\n\t17: Call math::min(u64, u64): u64\n\t18: StLoc[7](loc1: u64)\n\t19: MoveLoc[3](Arg3: u64)\n\t20: CopyLoc[1](Arg1: &mut Position)\n\t21: FreezeRef\n\t22: Call position::coins_owed_y(&Position): u64\n\t23: Call math::min(u64, u64): u64\n\t24: StLoc[8](loc2: u64)\n\t25: CopyLoc[1](Arg1: &mut Position)\n\t26: CopyLoc[7](loc1: u64)\n\t27: CopyLoc[8](loc2: u64)\n\t28: Call position::decrease_debt(&mut Position, u64, u64)\n\t29: MoveLoc[5](Arg5: &TxContext)\n\t30: Call tx_context::sender(&TxContext): address\n\t31: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t32: FreezeRef\n\t33: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t34: MoveLoc[1](Arg1: &mut Position)\n\t35: FreezeRef\n\t36: Call object::id<Position>(&Position): ID\n\t37: CopyLoc[7](loc1: u64)\n\t38: CopyLoc[8](loc2: u64)\n\t39: Pack[11](Collect)\n\t40: Call event::emit<Collect>(Collect)\n\t41: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t42: MoveLoc[7](loc1: u64)\n\t43: MoveLoc[8](loc2: u64)\n\t44: Call take<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, u64, u64): Balance<Ty0> * Balance<Ty1>\n\t45: Ret\n}\n\npublic collect_protocol_fee<Ty0, Ty1>(Arg0: &AdminCap, Arg1: &mut Pool<Ty0, Ty1>, Arg2: u64, Arg3: u64, Arg4: &Versioned, Arg5: &TxContext): Balance<Ty0> * Balance<Ty1> {\nL6:\tloc0: u64\nL7:\tloc1: u64\nB0:\n\t0: MoveLoc[4](Arg4: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t3: FreezeRef\n\t4: Call check_lock<Ty0, Ty1>(&Pool<Ty0, Ty1>)\n\t5: MoveLoc[2](Arg2: u64)\n\t6: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t7: ImmBorrowFieldGeneric[13](Pool.protocol_fee_x: u64)\n\t8: ReadRef\n\t9: Call math::min(u64, u64): u64\n\t10: StLoc[6](loc0: u64)\n\t11: MoveLoc[3](Arg3: u64)\n\t12: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t13: ImmBorrowFieldGeneric[14](Pool.protocol_fee_y: u64)\n\t14: ReadRef\n\t15: Call math::min(u64, u64): u64\n\t16: StLoc[7](loc1: u64)\n\t17: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t18: ImmBorrowFieldGeneric[13](Pool.protocol_fee_x: u64)\n\t19: ReadRef\n\t20: CopyLoc[6](loc0: u64)\n\t21: Sub\n\t22: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t23: MutBorrowFieldGeneric[13](Pool.protocol_fee_x: u64)\n\t24: WriteRef\n\t25: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t26: ImmBorrowFieldGeneric[14](Pool.protocol_fee_y: u64)\n\t27: ReadRef\n\t28: CopyLoc[7](loc1: u64)\n\t29: Sub\n\t30: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t31: MutBorrowFieldGeneric[14](Pool.protocol_fee_y: u64)\n\t32: WriteRef\n\t33: MoveLoc[5](Arg5: &TxContext)\n\t34: Call tx_context::sender(&TxContext): address\n\t35: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t36: FreezeRef\n\t37: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t38: CopyLoc[6](loc0: u64)\n\t39: CopyLoc[7](loc1: u64)\n\t40: Pack[12](CollectProtocolFee)\n\t41: Call event::emit<CollectProtocolFee>(CollectProtocolFee)\n\t42: MoveLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t43: MoveLoc[6](loc0: u64)\n\t44: MoveLoc[7](loc1: u64)\n\t45: Call take<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, u64, u64): Balance<Ty0> * Balance<Ty1>\n\t46: Ret\n}\n\npublic collect_pool_reward<Ty0, Ty1, Ty2>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: &mut Position, Arg2: u64, Arg3: &Versioned, Arg4: &TxContext): Balance<Ty2> {\nL5:\tloc0: ID\nL6:\tloc1: &mut Position\nL7:\tloc2: u64\nL8:\tloc3: u64\nL9:\tloc4: u64\nL10:\tloc5: ID\nL11:\tloc6: u64\nB0:\n\t0: MoveLoc[3](Arg3: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t3: FreezeRef\n\t4: Call check_lock<Ty0, Ty1>(&Pool<Ty0, Ty1>)\n\t5: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t6: CopyLoc[1](Arg1: &mut Position)\n\t7: FreezeRef\n\t8: Call position::pool_id(&Position): ID\n\t9: StLoc[5](loc0: ID)\n\t10: FreezeRef\n\t11: MoveLoc[5](loc0: ID)\n\t12: Call check_pool_match<Ty0, Ty1>(&Pool<Ty0, Ty1>, ID)\n\t13: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t14: FreezeRef\n\t15: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t16: StLoc[10](loc5: ID)\n\t17: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t18: FreezeRef\n\t19: Call find_reward_info_index<Ty0, Ty1, Ty2>(&Pool<Ty0, Ty1>): u64\n\t20: StLoc[11](loc6: u64)\n\t21: MoveLoc[2](Arg2: u64)\n\t22: StLoc[8](loc3: u64)\n\t23: CopyLoc[1](Arg1: &mut Position)\n\t24: CopyLoc[11](loc6: u64)\n\t25: StLoc[7](loc2: u64)\n\t26: StLoc[6](loc1: &mut Position)\n\t27: MoveLoc[8](loc3: u64)\n\t28: MoveLoc[6](loc1: &mut Position)\n\t29: FreezeRef\n\t30: MoveLoc[7](loc2: u64)\n\t31: Call position::coins_owed_reward(&Position, u64): u64\n\t32: Call math::min(u64, u64): u64\n\t33: StLoc[9](loc4: u64)\n\t34: CopyLoc[1](Arg1: &mut Position)\n\t35: MoveLoc[11](loc6: u64)\n\t36: CopyLoc[9](loc4: u64)\n\t37: Call position::decrease_reward_debt(&mut Position, u64, u64)\n\t38: MoveLoc[4](Arg4: &TxContext)\n\t39: Call tx_context::sender(&TxContext): address\n\t40: MoveLoc[10](loc5: ID)\n\t41: MoveLoc[1](Arg1: &mut Position)\n\t42: FreezeRef\n\t43: Call object::id<Position>(&Position): ID\n\t44: Call type_name::get<Ty2>(): TypeName\n\t45: CopyLoc[9](loc4: u64)\n\t46: Pack[18](CollectPoolReward)\n\t47: Call event::emit<CollectPoolReward>(CollectPoolReward)\n\t48: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t49: MutBorrowFieldGeneric[23](Pool.id: UID)\n\t50: LdFalse\n\t51: PackGeneric[1](PoolRewardCustodianDfKey<Ty2>)\n\t52: Call dynamic_field::borrow_mut<PoolRewardCustodianDfKey<Ty2>, Balance<Ty2>>(&mut UID, PoolRewardCustodianDfKey<Ty2>): &mut Balance<Ty2>\n\t53: MoveLoc[9](loc4: u64)\n\t54: Call safe_withdraw<Ty2>(&mut Balance<Ty2>, u64): Balance<Ty2>\n\t55: Ret\n}\n\npublic set_protocol_fee_rate<Ty0, Ty1>(Arg0: &AdminCap, Arg1: &mut Pool<Ty0, Ty1>, Arg2: u64, Arg3: u64, Arg4: &Versioned, Arg5: &TxContext) {\nL6:\tloc0: bool\nL7:\tloc1: bool\nL8:\tloc2: bool\nL9:\tloc3: bool\nL10:\tloc4: bool\nB0:\n\t0: MoveLoc[4](Arg4: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t3: FreezeRef\n\t4: Call check_lock<Ty0, Ty1>(&Pool<Ty0, Ty1>)\n\t5: CopyLoc[2](Arg2: u64)\n\t6: LdU64(0)\n\t7: Neq\n\t8: BrFalse(23)\nB1:\n\t9: CopyLoc[2](Arg2: u64)\n\t10: LdU64(4)\n\t11: Lt\n\t12: BrFalse(16)\nB2:\n\t13: LdTrue\n\t14: StLoc[8](loc2: bool)\n\t15: Branch(20)\nB3:\n\t16: CopyLoc[2](Arg2: u64)\n\t17: LdU64(10)\n\t18: Gt\n\t19: StLoc[8](loc2: bool)\nB4:\n\t20: MoveLoc[8](loc2: bool)\n\t21: StLoc[9](loc3: bool)\n\t22: Branch(25)\nB5:\n\t23: LdFalse\n\t24: StLoc[9](loc3: bool)\nB6:\n\t25: MoveLoc[9](loc3: bool)\n\t26: BrFalse(30)\nB7:\n\t27: LdTrue\n\t28: StLoc[10](loc4: bool)\n\t29: Branch(52)\nB8:\n\t30: CopyLoc[3](Arg3: u64)\n\t31: LdU64(0)\n\t32: Neq\n\t33: BrFalse(48)\nB9:\n\t34: CopyLoc[3](Arg3: u64)\n\t35: LdU64(4)\n\t36: Lt\n\t37: BrFalse(41)\nB10:\n\t38: LdTrue\n\t39: StLoc[6](loc0: bool)\n\t40: Branch(45)\nB11:\n\t41: CopyLoc[3](Arg3: u64)\n\t42: LdU64(10)\n\t43: Gt\n\t44: StLoc[6](loc0: bool)\nB12:\n\t45: MoveLoc[6](loc0: bool)\n\t46: StLoc[7](loc1: bool)\n\t47: Branch(50)\nB13:\n\t48: LdFalse\n\t49: StLoc[7](loc1: bool)\nB14:\n\t50: MoveLoc[7](loc1: bool)\n\t51: StLoc[10](loc4: bool)\nB15:\n\t52: MoveLoc[10](loc4: bool)\n\t53: BrFalse(60)\nB16:\n\t54: MoveLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t55: Pop\n\t56: MoveLoc[5](Arg5: &TxContext)\n\t57: Pop\n\t58: LdConst[7](u64: 7)\n\t59: Abort\nB17:\n\t60: CopyLoc[2](Arg2: u64)\n\t61: CopyLoc[3](Arg3: u64)\n\t62: LdU8(4)\n\t63: Shl\n\t64: Add\n\t65: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t66: MutBorrowFieldGeneric[9](Pool.protocol_fee_rate: u64)\n\t67: WriteRef\n\t68: MoveLoc[5](Arg5: &TxContext)\n\t69: Call tx_context::sender(&TxContext): address\n\t70: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t71: FreezeRef\n\t72: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t73: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t74: ImmBorrowFieldGeneric[9](Pool.protocol_fee_rate: u64)\n\t75: ReadRef\n\t76: LdU64(16)\n\t77: Mod\n\t78: MoveLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t79: ImmBorrowFieldGeneric[9](Pool.protocol_fee_rate: u64)\n\t80: ReadRef\n\t81: LdU8(4)\n\t82: Shr\n\t83: MoveLoc[2](Arg2: u64)\n\t84: MoveLoc[3](Arg3: u64)\n\t85: Pack[13](SetProtocolFeeRate)\n\t86: Call event::emit<SetProtocolFeeRate>(SetProtocolFeeRate)\n\t87: Ret\n}\n\npublic increase_observation_cardinality_next<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: u64, Arg2: &Versioned, Arg3: &TxContext) {\nL4:\tloc0: u64\nL5:\tloc1: u64\nB0:\n\t0: MoveLoc[2](Arg2: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t3: FreezeRef\n\t4: Call check_lock<Ty0, Ty1>(&Pool<Ty0, Ty1>)\n\t5: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t6: ImmBorrowFieldGeneric[6](Pool.observation_cardinality_next: u64)\n\t7: ReadRef\n\t8: StLoc[5](loc1: u64)\n\t9: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t10: MutBorrowFieldGeneric[18](Pool.observations: vector<Observation>)\n\t11: CopyLoc[5](loc1: u64)\n\t12: MoveLoc[1](Arg1: u64)\n\t13: Call oracle::grow(&mut vector<Observation>, u64, u64): u64\n\t14: StLoc[4](loc0: u64)\n\t15: CopyLoc[4](loc0: u64)\n\t16: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t17: MutBorrowFieldGeneric[6](Pool.observation_cardinality_next: u64)\n\t18: WriteRef\n\t19: MoveLoc[3](Arg3: &TxContext)\n\t20: Call tx_context::sender(&TxContext): address\n\t21: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t22: FreezeRef\n\t23: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t24: MoveLoc[5](loc1: u64)\n\t25: MoveLoc[4](loc0: u64)\n\t26: Pack[15](IncreaseObservationCardinalityNext)\n\t27: Call event::emit<IncreaseObservationCardinalityNext>(IncreaseObservationCardinalityNext)\n\t28: Ret\n}\n\npublic snapshot_cumulatives_inside<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>, Arg1: I32, Arg2: I32, Arg3: &Clock): I64 * u256 * u64 {\nL4:\tloc0: bool\nL5:\tloc1: I64\nL6:\tloc2: u256\nL7:\tloc3: u64\nL8:\tloc4: I64\nL9:\tloc5: u256\nL10:\tloc6: u64\nL11:\tloc7: u64\nL12:\tloc8: u64\nL13:\tloc9: u256\nL14:\tloc10: u256\nL15:\tloc11: u256\nL16:\tloc12: I64\nL17:\tloc13: I64\nL18:\tloc14: u64\nB0:\n\t0: CopyLoc[1](Arg1: I32)\n\t1: CopyLoc[2](Arg2: I32)\n\t2: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t3: ImmBorrowFieldGeneric[7](Pool.tick_spacing: u32)\n\t4: ReadRef\n\t5: Call tick::check_ticks(I32, I32, u32)\n\t6: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t7: ImmBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t8: CopyLoc[1](Arg1: I32)\n\t9: Call tick::is_initialized(&Table<I32, TickInfo>, I32): bool\n\t10: Not\n\t11: BrFalse(15)\nB1:\n\t12: LdTrue\n\t13: StLoc[4](loc0: bool)\n\t14: Branch(21)\nB2:\n\t15: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t16: ImmBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t17: CopyLoc[2](Arg2: I32)\n\t18: Call tick::is_initialized(&Table<I32, TickInfo>, I32): bool\n\t19: Not\n\t20: StLoc[4](loc0: bool)\nB3:\n\t21: MoveLoc[4](loc0: bool)\n\t22: BrFalse(29)\nB4:\n\t23: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t24: Pop\n\t25: MoveLoc[3](Arg3: &Clock)\n\t26: Pop\n\t27: LdConst[8](u64: 8)\n\t28: Abort\nB5:\n\t29: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t30: ImmBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t31: CopyLoc[1](Arg1: I32)\n\t32: Call tick::get_tick_cumulative_out_side(&Table<I32, TickInfo>, I32): I64\n\t33: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t34: ImmBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t35: CopyLoc[2](Arg2: I32)\n\t36: Call tick::get_tick_cumulative_out_side(&Table<I32, TickInfo>, I32): I64\n\t37: StLoc[17](loc13: I64)\n\t38: StLoc[16](loc12: I64)\n\t39: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t40: ImmBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t41: CopyLoc[1](Arg1: I32)\n\t42: Call tick::get_seconds_per_liquidity_out_side(&Table<I32, TickInfo>, I32): u256\n\t43: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t44: ImmBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t45: CopyLoc[2](Arg2: I32)\n\t46: Call tick::get_seconds_per_liquidity_out_side(&Table<I32, TickInfo>, I32): u256\n\t47: StLoc[15](loc11: u256)\n\t48: StLoc[14](loc10: u256)\n\t49: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t50: ImmBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t51: CopyLoc[1](Arg1: I32)\n\t52: Call tick::get_seconds_out_side(&Table<I32, TickInfo>, I32): u64\n\t53: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t54: ImmBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t55: CopyLoc[2](Arg2: I32)\n\t56: Call tick::get_seconds_out_side(&Table<I32, TickInfo>, I32): u64\n\t57: StLoc[12](loc8: u64)\n\t58: StLoc[11](loc7: u64)\n\t59: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t60: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t61: ReadRef\n\t62: MoveLoc[1](Arg1: I32)\n\t63: Call i32::lt(I32, I32): bool\n\t64: BrFalse(82)\nB6:\n\t65: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t66: Pop\n\t67: MoveLoc[3](Arg3: &Clock)\n\t68: Pop\n\t69: MoveLoc[16](loc12: I64)\n\t70: MoveLoc[17](loc13: I64)\n\t71: Call i64::sub(I64, I64): I64\n\t72: MoveLoc[14](loc10: u256)\n\t73: MoveLoc[15](loc11: u256)\n\t74: Sub\n\t75: MoveLoc[11](loc7: u64)\n\t76: MoveLoc[12](loc8: u64)\n\t77: Sub\n\t78: StLoc[10](loc6: u64)\n\t79: StLoc[9](loc5: u256)\n\t80: StLoc[8](loc4: I64)\n\t81: Branch(150)\nB7:\n\t82: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t83: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t84: ReadRef\n\t85: MoveLoc[2](Arg2: I32)\n\t86: Call i32::lt(I32, I32): bool\n\t87: BrFalse(128)\nB8:\n\t88: MoveLoc[3](Arg3: &Clock)\n\t89: Call clock::timestamp_ms(&Clock): u64\n\t90: Call utils::to_seconds(u64): u64\n\t91: StLoc[18](loc14: u64)\n\t92: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t93: ImmBorrowFieldGeneric[18](Pool.observations: vector<Observation>)\n\t94: CopyLoc[18](loc14: u64)\n\t95: LdU64(0)\n\t96: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t97: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t98: ReadRef\n\t99: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t100: ImmBorrowFieldGeneric[4](Pool.observation_index: u64)\n\t101: ReadRef\n\t102: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t103: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t104: ReadRef\n\t105: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t106: ImmBorrowFieldGeneric[5](Pool.observation_cardinality: u64)\n\t107: ReadRef\n\t108: Call oracle::observe_single(&vector<Observation>, u64, u64, I32, u64, u128, u64): I64 * u256\n\t109: StLoc[13](loc9: u256)\n\t110: MoveLoc[16](loc12: I64)\n\t111: Call i64::sub(I64, I64): I64\n\t112: MoveLoc[17](loc13: I64)\n\t113: Call i64::sub(I64, I64): I64\n\t114: MoveLoc[13](loc9: u256)\n\t115: MoveLoc[14](loc10: u256)\n\t116: Sub\n\t117: MoveLoc[15](loc11: u256)\n\t118: Sub\n\t119: MoveLoc[18](loc14: u64)\n\t120: MoveLoc[11](loc7: u64)\n\t121: Sub\n\t122: MoveLoc[12](loc8: u64)\n\t123: Sub\n\t124: StLoc[7](loc3: u64)\n\t125: StLoc[6](loc2: u256)\n\t126: StLoc[5](loc1: I64)\n\t127: Branch(144)\nB9:\n\t128: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t129: Pop\n\t130: MoveLoc[3](Arg3: &Clock)\n\t131: Pop\n\t132: MoveLoc[17](loc13: I64)\n\t133: MoveLoc[16](loc12: I64)\n\t134: Call i64::sub(I64, I64): I64\n\t135: MoveLoc[15](loc11: u256)\n\t136: MoveLoc[14](loc10: u256)\n\t137: Sub\n\t138: MoveLoc[12](loc8: u64)\n\t139: MoveLoc[11](loc7: u64)\n\t140: Sub\n\t141: StLoc[7](loc3: u64)\n\t142: StLoc[6](loc2: u256)\n\t143: StLoc[5](loc1: I64)\nB10:\n\t144: MoveLoc[5](loc1: I64)\n\t145: MoveLoc[6](loc2: u256)\n\t146: MoveLoc[7](loc3: u64)\n\t147: StLoc[10](loc6: u64)\n\t148: StLoc[9](loc5: u256)\n\t149: StLoc[8](loc4: I64)\nB11:\n\t150: MoveLoc[8](loc4: I64)\n\t151: MoveLoc[9](loc5: u256)\n\t152: MoveLoc[10](loc6: u64)\n\t153: Ret\n}\n\npublic observe<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>, Arg1: vector<u64>, Arg2: &Clock): vector<I64> * vector<u256> {\nB0:\n\t0: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[18](Pool.observations: vector<Observation>)\n\t2: MoveLoc[2](Arg2: &Clock)\n\t3: Call clock::timestamp_ms(&Clock): u64\n\t4: Call utils::to_seconds(u64): u64\n\t5: MoveLoc[1](Arg1: vector<u64>)\n\t6: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t7: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t8: ReadRef\n\t9: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t10: ImmBorrowFieldGeneric[4](Pool.observation_index: u64)\n\t11: ReadRef\n\t12: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t13: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t14: ReadRef\n\t15: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t16: ImmBorrowFieldGeneric[5](Pool.observation_cardinality: u64)\n\t17: ReadRef\n\t18: Call oracle::observe(&vector<Observation>, u64, vector<u64>, I32, u64, u128, u64): vector<I64> * vector<u256>\n\t19: Ret\n}\n\npublic initialize_pool_reward<Ty0, Ty1, Ty2>(Arg0: &AdminCap, Arg1: &mut Pool<Ty0, Ty1>, Arg2: u64, Arg3: u64, Arg4: Balance<Ty2>, Arg5: &Versioned, Arg6: &Clock, Arg7: &TxContext) {\nL8:\tloc0: TypeName\nL9:\tloc1: u64\nL10:\tloc2: u64\nL11:\tloc3: TypeName\nL12:\tloc4: PoolRewardInfo\nB0:\n\t0: MoveLoc[5](Arg5: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t3: FreezeRef\n\t4: Call check_lock<Ty0, Ty1>(&Pool<Ty0, Ty1>)\n\t5: MoveLoc[6](Arg6: &Clock)\n\t6: Call clock::timestamp_ms(&Clock): u64\n\t7: Call utils::to_seconds(u64): u64\n\t8: StLoc[10](loc2: u64)\n\t9: CopyLoc[2](Arg2: u64)\n\t10: MoveLoc[10](loc2: u64)\n\t11: Le\n\t12: BrFalse(19)\nB1:\n\t13: MoveLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t14: Pop\n\t15: MoveLoc[7](Arg7: &TxContext)\n\t16: Pop\n\t17: LdConst[9](u64: 9)\n\t18: Abort\nB2:\n\t19: Call type_name::get<Ty2>(): TypeName\n\t20: StLoc[11](loc3: TypeName)\n\t21: CopyLoc[11](loc3: TypeName)\n\t22: StLoc[8](loc0: TypeName)\n\t23: CopyLoc[2](Arg2: u64)\n\t24: StLoc[9](loc1: u64)\n\t25: MoveLoc[8](loc0: TypeName)\n\t26: MoveLoc[9](loc1: u64)\n\t27: LdU64(0)\n\t28: LdU64(0)\n\t29: LdU64(0)\n\t30: LdU128(0)\n\t31: LdU128(0)\n\t32: Pack[2](PoolRewardInfo)\n\t33: StLoc[12](loc4: PoolRewardInfo)\n\t34: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t35: MutBorrowFieldGeneric[23](Pool.id: UID)\n\t36: LdFalse\n\t37: PackGeneric[1](PoolRewardCustodianDfKey<Ty2>)\n\t38: Call balance::zero<Ty2>(): Balance<Ty2>\n\t39: Call dynamic_field::add<PoolRewardCustodianDfKey<Ty2>, Balance<Ty2>>(&mut UID, PoolRewardCustodianDfKey<Ty2>, Balance<Ty2>)\n\t40: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t41: MutBorrowFieldGeneric[20](Pool.reward_infos: vector<PoolRewardInfo>)\n\t42: MoveLoc[12](loc4: PoolRewardInfo)\n\t43: VecPushBack(51)\n\t44: CopyLoc[7](Arg7: &TxContext)\n\t45: Call tx_context::sender(&TxContext): address\n\t46: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t47: FreezeRef\n\t48: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t49: MoveLoc[11](loc3: TypeName)\n\t50: MoveLoc[2](Arg2: u64)\n\t51: Pack[16](InitializePoolReward)\n\t52: Call event::emit<InitializePoolReward>(InitializePoolReward)\n\t53: MoveLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t54: MoveLoc[4](Arg4: Balance<Ty2>)\n\t55: MoveLoc[3](Arg3: u64)\n\t56: MoveLoc[7](Arg7: &TxContext)\n\t57: Call update_pool_reward_emission<Ty0, Ty1, Ty2>(&mut Pool<Ty0, Ty1>, Balance<Ty2>, u64, &TxContext)\n\t58: Ret\n}\n\npublic increase_pool_reward<Ty0, Ty1, Ty2>(Arg0: &AdminCap, Arg1: &mut Pool<Ty0, Ty1>, Arg2: Balance<Ty2>, Arg3: &Versioned, Arg4: &Clock, Arg5: &TxContext) {\nB0:\n\t0: MoveLoc[3](Arg3: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t3: FreezeRef\n\t4: Call check_lock<Ty0, Ty1>(&Pool<Ty0, Ty1>)\n\t5: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t6: MoveLoc[4](Arg4: &Clock)\n\t7: Call clock::timestamp_ms(&Clock): u64\n\t8: Call utils::to_seconds(u64): u64\n\t9: Call update_reward_infos<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, u64): vector<u128>\n\t10: Pop\n\t11: MoveLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t12: MoveLoc[2](Arg2: Balance<Ty2>)\n\t13: LdU64(0)\n\t14: MoveLoc[5](Arg5: &TxContext)\n\t15: Call update_pool_reward_emission<Ty0, Ty1, Ty2>(&mut Pool<Ty0, Ty1>, Balance<Ty2>, u64, &TxContext)\n\t16: Ret\n}\n\npublic extend_pool_reward_timestamp<Ty0, Ty1, Ty2>(Arg0: &AdminCap, Arg1: &mut Pool<Ty0, Ty1>, Arg2: u64, Arg3: &Versioned, Arg4: &Clock, Arg5: &TxContext) {\nB0:\n\t0: MoveLoc[3](Arg3: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t3: FreezeRef\n\t4: Call check_lock<Ty0, Ty1>(&Pool<Ty0, Ty1>)\n\t5: CopyLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t6: MoveLoc[4](Arg4: &Clock)\n\t7: Call clock::timestamp_ms(&Clock): u64\n\t8: Call utils::to_seconds(u64): u64\n\t9: Call update_reward_infos<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, u64): vector<u128>\n\t10: Pop\n\t11: MoveLoc[1](Arg1: &mut Pool<Ty0, Ty1>)\n\t12: Call balance::zero<Ty2>(): Balance<Ty2>\n\t13: MoveLoc[2](Arg2: u64)\n\t14: MoveLoc[5](Arg5: &TxContext)\n\t15: Call update_pool_reward_emission<Ty0, Ty1, Ty2>(&mut Pool<Ty0, Ty1>, Balance<Ty2>, u64, &TxContext)\n\t16: Ret\n}\n\nupdate_pool_reward_emission<Ty0, Ty1, Ty2>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: Balance<Ty2>, Arg2: u64, Arg3: &TxContext) {\nL4:\tloc0: u64\nL5:\tloc1: ID\nL6:\tloc2: &mut PoolRewardInfo\nL7:\tloc3: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t1: FreezeRef\n\t2: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t3: StLoc[5](loc1: ID)\n\t4: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t5: FreezeRef\n\t6: Call find_reward_info_index<Ty0, Ty1, Ty2>(&Pool<Ty0, Ty1>): u64\n\t7: StLoc[7](loc3: u64)\n\t8: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t9: MutBorrowFieldGeneric[20](Pool.reward_infos: vector<PoolRewardInfo>)\n\t10: MoveLoc[7](loc3: u64)\n\t11: VecMutBorrow(51)\n\t12: StLoc[6](loc2: &mut PoolRewardInfo)\n\t13: CopyLoc[6](loc2: &mut PoolRewardInfo)\n\t14: ImmBorrowField[23](PoolRewardInfo.ended_at_seconds: u64)\n\t15: ReadRef\n\t16: MoveLoc[2](Arg2: u64)\n\t17: Add\n\t18: StLoc[4](loc0: u64)\n\t19: CopyLoc[4](loc0: u64)\n\t20: CopyLoc[6](loc2: &mut PoolRewardInfo)\n\t21: ImmBorrowField[22](PoolRewardInfo.last_update_time: u64)\n\t22: ReadRef\n\t23: Le\n\t24: BrFalse(33)\nB1:\n\t25: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t26: Pop\n\t27: MoveLoc[6](loc2: &mut PoolRewardInfo)\n\t28: Pop\n\t29: MoveLoc[3](Arg3: &TxContext)\n\t30: Pop\n\t31: LdConst[9](u64: 9)\n\t32: Abort\nB2:\n\t33: CopyLoc[6](loc2: &mut PoolRewardInfo)\n\t34: ImmBorrowField[24](PoolRewardInfo.total_reward: u64)\n\t35: ReadRef\n\t36: ImmBorrowLoc[1](Arg1: Balance<Ty2>)\n\t37: Call balance::value<Ty2>(&Balance<Ty2>): u64\n\t38: Add\n\t39: CopyLoc[6](loc2: &mut PoolRewardInfo)\n\t40: MutBorrowField[24](PoolRewardInfo.total_reward: u64)\n\t41: WriteRef\n\t42: MoveLoc[4](loc0: u64)\n\t43: CopyLoc[6](loc2: &mut PoolRewardInfo)\n\t44: MutBorrowField[23](PoolRewardInfo.ended_at_seconds: u64)\n\t45: WriteRef\n\t46: CopyLoc[6](loc2: &mut PoolRewardInfo)\n\t47: ImmBorrowField[24](PoolRewardInfo.total_reward: u64)\n\t48: ReadRef\n\t49: CopyLoc[6](loc2: &mut PoolRewardInfo)\n\t50: ImmBorrowField[25](PoolRewardInfo.total_reward_allocated: u64)\n\t51: ReadRef\n\t52: Sub\n\t53: CastU128\n\t54: Call constants::get_q64(): u128\n\t55: CastU128\n\t56: CopyLoc[6](loc2: &mut PoolRewardInfo)\n\t57: ImmBorrowField[23](PoolRewardInfo.ended_at_seconds: u64)\n\t58: ReadRef\n\t59: CopyLoc[6](loc2: &mut PoolRewardInfo)\n\t60: ImmBorrowField[22](PoolRewardInfo.last_update_time: u64)\n\t61: ReadRef\n\t62: Sub\n\t63: CastU128\n\t64: Call full_math_u128::mul_div_floor(u128, u128, u128): u128\n\t65: CopyLoc[6](loc2: &mut PoolRewardInfo)\n\t66: MutBorrowField[26](PoolRewardInfo.reward_per_seconds: u128)\n\t67: WriteRef\n\t68: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t69: MutBorrowFieldGeneric[23](Pool.id: UID)\n\t70: LdFalse\n\t71: PackGeneric[1](PoolRewardCustodianDfKey<Ty2>)\n\t72: Call dynamic_field::borrow_mut<PoolRewardCustodianDfKey<Ty2>, Balance<Ty2>>(&mut UID, PoolRewardCustodianDfKey<Ty2>): &mut Balance<Ty2>\n\t73: MoveLoc[1](Arg1: Balance<Ty2>)\n\t74: Call balance::join<Ty2>(&mut Balance<Ty2>, Balance<Ty2>): u64\n\t75: Pop\n\t76: MoveLoc[3](Arg3: &TxContext)\n\t77: Call tx_context::sender(&TxContext): address\n\t78: MoveLoc[5](loc1: ID)\n\t79: CopyLoc[6](loc2: &mut PoolRewardInfo)\n\t80: ImmBorrowField[21](PoolRewardInfo.reward_coin_type: TypeName)\n\t81: ReadRef\n\t82: CopyLoc[6](loc2: &mut PoolRewardInfo)\n\t83: ImmBorrowField[24](PoolRewardInfo.total_reward: u64)\n\t84: ReadRef\n\t85: CopyLoc[6](loc2: &mut PoolRewardInfo)\n\t86: ImmBorrowField[23](PoolRewardInfo.ended_at_seconds: u64)\n\t87: ReadRef\n\t88: MoveLoc[6](loc2: &mut PoolRewardInfo)\n\t89: ImmBorrowField[26](PoolRewardInfo.reward_per_seconds: u128)\n\t90: ReadRef\n\t91: Pack[17](UpdatePoolRewardEmission)\n\t92: Call event::emit<UpdatePoolRewardEmission>(UpdatePoolRewardEmission)\n\t93: Ret\n}\n\nmodify_position<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: &mut Position, Arg2: I128, Arg3: &Clock): u64 * u64 {\nL4:\tloc0: u64\nL5:\tloc1: u64\nL6:\tloc2: u64\nL7:\tloc3: u64\nL8:\tloc4: u64\nL9:\tloc5: u64\nL10:\tloc6: bool\nL11:\tloc7: u128\nL12:\tloc8: u64\nL13:\tloc9: I32\nL14:\tloc10: I32\nB0:\n\t0: CopyLoc[2](Arg2: I128)\n\t1: Call i128::is_neg(I128): bool\n\t2: Not\n\t3: StLoc[10](loc6: bool)\n\t4: CopyLoc[1](Arg1: &mut Position)\n\t5: FreezeRef\n\t6: Call position::tick_lower_index(&Position): I32\n\t7: CopyLoc[1](Arg1: &mut Position)\n\t8: FreezeRef\n\t9: Call position::tick_upper_index(&Position): I32\n\t10: StLoc[14](loc10: I32)\n\t11: StLoc[13](loc9: I32)\n\t12: CopyLoc[2](Arg2: I128)\n\t13: Call i128::abs_u128(I128): u128\n\t14: StLoc[11](loc7: u128)\n\t15: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t16: MoveLoc[1](Arg1: &mut Position)\n\t17: CopyLoc[2](Arg2: I128)\n\t18: CopyLoc[3](Arg3: &Clock)\n\t19: Call update_position<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, &mut Position, I128, &Clock)\n\t20: CopyLoc[2](Arg2: I128)\n\t21: Call i128::zero(): I128\n\t22: Call i128::eq(I128, I128): bool\n\t23: Not\n\t24: BrFalse(131)\nB1:\n\t25: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t26: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t27: ReadRef\n\t28: CopyLoc[13](loc9: I32)\n\t29: Call i32::lt(I32, I32): bool\n\t30: BrFalse(46)\nB2:\n\t31: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t32: Pop\n\t33: MoveLoc[3](Arg3: &Clock)\n\t34: Pop\n\t35: MoveLoc[13](loc9: I32)\n\t36: Call tick_math::get_sqrt_price_at_tick(I32): u128\n\t37: MoveLoc[14](loc10: I32)\n\t38: Call tick_math::get_sqrt_price_at_tick(I32): u128\n\t39: MoveLoc[11](loc7: u128)\n\t40: MoveLoc[10](loc6: bool)\n\t41: Call sqrt_price_math::get_amount_x_delta(u128, u128, u128, bool): u64\n\t42: LdU64(0)\n\t43: StLoc[7](loc3: u64)\n\t44: StLoc[6](loc2: u64)\n\t45: Branch(126)\nB3:\n\t46: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t47: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t48: ReadRef\n\t49: CopyLoc[14](loc10: I32)\n\t50: Call i32::lt(I32, I32): bool\n\t51: BrFalse(108)\nB4:\n\t52: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t53: MutBorrowFieldGeneric[18](Pool.observations: vector<Observation>)\n\t54: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t55: ImmBorrowFieldGeneric[4](Pool.observation_index: u64)\n\t56: ReadRef\n\t57: MoveLoc[3](Arg3: &Clock)\n\t58: Call clock::timestamp_ms(&Clock): u64\n\t59: Call utils::to_seconds(u64): u64\n\t60: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t61: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t62: ReadRef\n\t63: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t64: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t65: ReadRef\n\t66: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t67: ImmBorrowFieldGeneric[5](Pool.observation_cardinality: u64)\n\t68: ReadRef\n\t69: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t70: ImmBorrowFieldGeneric[6](Pool.observation_cardinality_next: u64)\n\t71: ReadRef\n\t72: Call oracle::write(&mut vector<Observation>, u64, u64, I32, u128, u64, u64): u64 * u64\n\t73: StLoc[12](loc8: u64)\n\t74: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t75: MutBorrowFieldGeneric[4](Pool.observation_index: u64)\n\t76: WriteRef\n\t77: MoveLoc[12](loc8: u64)\n\t78: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t79: MutBorrowFieldGeneric[5](Pool.observation_cardinality: u64)\n\t80: WriteRef\n\t81: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t82: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t83: ReadRef\n\t84: MoveLoc[2](Arg2: I128)\n\t85: Call liquidity_math::add_delta(u128, I128): u128\n\t86: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t87: MutBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t88: WriteRef\n\t89: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t90: ImmBorrowFieldGeneric[2](Pool.sqrt_price: u128)\n\t91: ReadRef\n\t92: MoveLoc[14](loc10: I32)\n\t93: Call tick_math::get_sqrt_price_at_tick(I32): u128\n\t94: CopyLoc[11](loc7: u128)\n\t95: CopyLoc[10](loc6: bool)\n\t96: Call sqrt_price_math::get_amount_x_delta(u128, u128, u128, bool): u64\n\t97: MoveLoc[13](loc9: I32)\n\t98: Call tick_math::get_sqrt_price_at_tick(I32): u128\n\t99: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t100: ImmBorrowFieldGeneric[2](Pool.sqrt_price: u128)\n\t101: ReadRef\n\t102: MoveLoc[11](loc7: u128)\n\t103: MoveLoc[10](loc6: bool)\n\t104: Call sqrt_price_math::get_amount_y_delta(u128, u128, u128, bool): u64\n\t105: StLoc[5](loc1: u64)\n\t106: StLoc[4](loc0: u64)\n\t107: Branch(122)\nB5:\n\t108: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t109: Pop\n\t110: MoveLoc[3](Arg3: &Clock)\n\t111: Pop\n\t112: LdU64(0)\n\t113: MoveLoc[13](loc9: I32)\n\t114: Call tick_math::get_sqrt_price_at_tick(I32): u128\n\t115: MoveLoc[14](loc10: I32)\n\t116: Call tick_math::get_sqrt_price_at_tick(I32): u128\n\t117: MoveLoc[11](loc7: u128)\n\t118: MoveLoc[10](loc6: bool)\n\t119: Call sqrt_price_math::get_amount_y_delta(u128, u128, u128, bool): u64\n\t120: StLoc[5](loc1: u64)\n\t121: StLoc[4](loc0: u64)\nB6:\n\t122: MoveLoc[4](loc0: u64)\n\t123: MoveLoc[5](loc1: u64)\n\t124: StLoc[7](loc3: u64)\n\t125: StLoc[6](loc2: u64)\nB7:\n\t126: MoveLoc[6](loc2: u64)\n\t127: MoveLoc[7](loc3: u64)\n\t128: StLoc[9](loc5: u64)\n\t129: StLoc[8](loc4: u64)\n\t130: Branch(139)\nB8:\n\t131: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t132: Pop\n\t133: MoveLoc[3](Arg3: &Clock)\n\t134: Pop\n\t135: LdU64(0)\n\t136: LdU64(0)\n\t137: StLoc[9](loc5: u64)\n\t138: StLoc[8](loc4: u64)\nB9:\n\t139: MoveLoc[8](loc4: u64)\n\t140: MoveLoc[9](loc5: u64)\n\t141: Ret\n}\n\nupdate_position<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: &mut Position, Arg2: I128, Arg3: &Clock) {\nL4:\tloc0: bool\nL5:\tloc1: bool\nL6:\tloc2: u128\nL7:\tloc3: u128\nL8:\tloc4: bool\nL9:\tloc5: bool\nL10:\tloc6: bool\nL11:\tloc7: bool\nL12:\tloc8: vector<u128>\nL13:\tloc9: vector<u128>\nL14:\tloc10: u256\nL15:\tloc11: I64\nL16:\tloc12: I32\nL17:\tloc13: I32\nL18:\tloc14: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t1: CopyLoc[3](Arg3: &Clock)\n\t2: Call clock::timestamp_ms(&Clock): u64\n\t3: Call utils::to_seconds(u64): u64\n\t4: Call update_reward_infos<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, u64): vector<u128>\n\t5: StLoc[12](loc8: vector<u128>)\n\t6: CopyLoc[1](Arg1: &mut Position)\n\t7: FreezeRef\n\t8: Call position::tick_lower_index(&Position): I32\n\t9: CopyLoc[1](Arg1: &mut Position)\n\t10: FreezeRef\n\t11: Call position::tick_upper_index(&Position): I32\n\t12: StLoc[17](loc13: I32)\n\t13: StLoc[16](loc12: I32)\n\t14: CopyLoc[2](Arg2: I128)\n\t15: Call i128::zero(): I128\n\t16: Call i128::eq(I128, I128): bool\n\t17: Not\n\t18: BrFalse(111)\nB1:\n\t19: MoveLoc[3](Arg3: &Clock)\n\t20: Call clock::timestamp_ms(&Clock): u64\n\t21: Call utils::to_seconds(u64): u64\n\t22: StLoc[18](loc14: u64)\n\t23: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t24: ImmBorrowFieldGeneric[18](Pool.observations: vector<Observation>)\n\t25: CopyLoc[18](loc14: u64)\n\t26: LdU64(0)\n\t27: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t28: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t29: ReadRef\n\t30: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t31: ImmBorrowFieldGeneric[4](Pool.observation_index: u64)\n\t32: ReadRef\n\t33: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t34: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t35: ReadRef\n\t36: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t37: ImmBorrowFieldGeneric[5](Pool.observation_cardinality: u64)\n\t38: ReadRef\n\t39: Call oracle::observe_single(&vector<Observation>, u64, u64, I32, u64, u128, u64): I64 * u256\n\t40: StLoc[14](loc10: u256)\n\t41: StLoc[15](loc11: I64)\n\t42: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t43: MutBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t44: CopyLoc[16](loc12: I32)\n\t45: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t46: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t47: ReadRef\n\t48: CopyLoc[2](Arg2: I128)\n\t49: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t50: ImmBorrowFieldGeneric[11](Pool.fee_growth_global_x: u128)\n\t51: ReadRef\n\t52: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t53: ImmBorrowFieldGeneric[12](Pool.fee_growth_global_y: u128)\n\t54: ReadRef\n\t55: CopyLoc[12](loc8: vector<u128>)\n\t56: CopyLoc[14](loc10: u256)\n\t57: CopyLoc[15](loc11: I64)\n\t58: CopyLoc[18](loc14: u64)\n\t59: LdFalse\n\t60: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t61: ImmBorrowFieldGeneric[8](Pool.max_liquidity_per_tick: u128)\n\t62: ReadRef\n\t63: Call tick::update(&mut Table<I32, TickInfo>, I32, I32, I128, u128, u128, vector<u128>, u256, I64, u64, bool, u128): bool\n\t64: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t65: MutBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t66: CopyLoc[17](loc13: I32)\n\t67: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t68: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t69: ReadRef\n\t70: CopyLoc[2](Arg2: I128)\n\t71: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t72: ImmBorrowFieldGeneric[11](Pool.fee_growth_global_x: u128)\n\t73: ReadRef\n\t74: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t75: ImmBorrowFieldGeneric[12](Pool.fee_growth_global_y: u128)\n\t76: ReadRef\n\t77: CopyLoc[12](loc8: vector<u128>)\n\t78: MoveLoc[14](loc10: u256)\n\t79: MoveLoc[15](loc11: I64)\n\t80: MoveLoc[18](loc14: u64)\n\t81: LdTrue\n\t82: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t83: ImmBorrowFieldGeneric[8](Pool.max_liquidity_per_tick: u128)\n\t84: ReadRef\n\t85: Call tick::update(&mut Table<I32, TickInfo>, I32, I32, I128, u128, u128, vector<u128>, u256, I64, u64, bool, u128): bool\n\t86: StLoc[11](loc7: bool)\n\t87: StLoc[9](loc5: bool)\n\t88: CopyLoc[9](loc5: bool)\n\t89: BrFalse(97)\nB2:\n\t90: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t91: MutBorrowFieldGeneric[17](Pool.tick_bitmap: Table<I32, u256>)\n\t92: CopyLoc[16](loc12: I32)\n\t93: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t94: ImmBorrowFieldGeneric[7](Pool.tick_spacing: u32)\n\t95: ReadRef\n\t96: Call tick_bitmap::flip_tick(&mut Table<I32, u256>, I32, u32)\nB3:\n\t97: CopyLoc[11](loc7: bool)\n\t98: BrFalse(106)\nB4:\n\t99: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t100: MutBorrowFieldGeneric[17](Pool.tick_bitmap: Table<I32, u256>)\n\t101: CopyLoc[17](loc13: I32)\n\t102: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t103: ImmBorrowFieldGeneric[7](Pool.tick_spacing: u32)\n\t104: ReadRef\n\t105: Call tick_bitmap::flip_tick(&mut Table<I32, u256>, I32, u32)\nB5:\n\t106: MoveLoc[9](loc5: bool)\n\t107: MoveLoc[11](loc7: bool)\n\t108: StLoc[5](loc1: bool)\n\t109: StLoc[4](loc0: bool)\n\t110: Branch(117)\nB6:\n\t111: MoveLoc[3](Arg3: &Clock)\n\t112: Pop\n\t113: LdFalse\n\t114: LdFalse\n\t115: StLoc[5](loc1: bool)\n\t116: StLoc[4](loc0: bool)\nB7:\n\t117: MoveLoc[4](loc0: bool)\n\t118: MoveLoc[5](loc1: bool)\n\t119: StLoc[10](loc6: bool)\n\t120: StLoc[8](loc4: bool)\n\t121: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t122: ImmBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t123: CopyLoc[16](loc12: I32)\n\t124: CopyLoc[17](loc13: I32)\n\t125: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t126: ImmBorrowFieldGeneric[3](Pool.tick_index: I32)\n\t127: ReadRef\n\t128: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t129: ImmBorrowFieldGeneric[11](Pool.fee_growth_global_x: u128)\n\t130: ReadRef\n\t131: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t132: ImmBorrowFieldGeneric[12](Pool.fee_growth_global_y: u128)\n\t133: ReadRef\n\t134: MoveLoc[12](loc8: vector<u128>)\n\t135: Call tick::get_fee_and_reward_growths_inside(&Table<I32, TickInfo>, I32, I32, I32, u128, u128, vector<u128>): u128 * u128 * vector<u128>\n\t136: StLoc[13](loc9: vector<u128>)\n\t137: StLoc[7](loc3: u128)\n\t138: StLoc[6](loc2: u128)\n\t139: MoveLoc[1](Arg1: &mut Position)\n\t140: CopyLoc[2](Arg2: I128)\n\t141: MoveLoc[6](loc2: u128)\n\t142: MoveLoc[7](loc3: u128)\n\t143: MoveLoc[13](loc9: vector<u128>)\n\t144: Call position::update(&mut Position, I128, u128, u128, vector<u128>)\n\t145: MoveLoc[2](Arg2: I128)\n\t146: Call i128::zero(): I128\n\t147: Call i128::lt(I128, I128): bool\n\t148: BrFalse(165)\nB8:\n\t149: MoveLoc[8](loc4: bool)\n\t150: BrFalse(155)\nB9:\n\t151: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t152: MutBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t153: MoveLoc[16](loc12: I32)\n\t154: Call tick::clear(&mut Table<I32, TickInfo>, I32)\nB10:\n\t155: MoveLoc[10](loc6: bool)\n\t156: BrFalse(162)\nB11:\n\t157: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t158: MutBorrowFieldGeneric[16](Pool.ticks: Table<I32, TickInfo>)\n\t159: MoveLoc[17](loc13: I32)\n\t160: Call tick::clear(&mut Table<I32, TickInfo>, I32)\n\t161: Branch(164)\nB12:\n\t162: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t163: Pop\nB13:\n\t164: Branch(167)\nB14:\n\t165: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t166: Pop\nB15:\n\t167: Ret\n}\n\nupdate_reward_infos<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: u64): vector<u128> {\nL2:\tloc0: bool\nL3:\tloc1: u64\nL4:\tloc2: u64\nL5:\tloc3: u64\nL6:\tloc4: u256\nL7:\tloc5: u256\nL8:\tloc6: vector<u128>\nL9:\tloc7: &mut PoolRewardInfo\nB0:\n\t0: VecPack(3, 0)\n\t1: StLoc[8](loc6: vector<u128>)\n\t2: LdU64(0)\n\t3: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t4: ImmBorrowFieldGeneric[20](Pool.reward_infos: vector<PoolRewardInfo>)\n\t5: VecLen(51)\n\t6: StLoc[5](loc3: u64)\n\t7: StLoc[3](loc1: u64)\nB1:\n\t8: CopyLoc[3](loc1: u64)\n\t9: CopyLoc[5](loc3: u64)\n\t10: Lt\n\t11: BrFalse(100)\nB2:\n\t12: Branch(13)\nB3:\n\t13: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t14: MutBorrowFieldGeneric[20](Pool.reward_infos: vector<PoolRewardInfo>)\n\t15: CopyLoc[3](loc1: u64)\n\t16: VecMutBorrow(51)\n\t17: StLoc[9](loc7: &mut PoolRewardInfo)\n\t18: MoveLoc[3](loc1: u64)\n\t19: LdU64(1)\n\t20: Add\n\t21: StLoc[3](loc1: u64)\n\t22: CopyLoc[1](Arg1: u64)\n\t23: CopyLoc[9](loc7: &mut PoolRewardInfo)\n\t24: ImmBorrowField[22](PoolRewardInfo.last_update_time: u64)\n\t25: ReadRef\n\t26: Gt\n\t27: BrFalse(94)\nB4:\n\t28: CopyLoc[1](Arg1: u64)\n\t29: CopyLoc[9](loc7: &mut PoolRewardInfo)\n\t30: ImmBorrowField[23](PoolRewardInfo.ended_at_seconds: u64)\n\t31: ReadRef\n\t32: Call math::min(u64, u64): u64\n\t33: StLoc[4](loc2: u64)\n\t34: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t35: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t36: ReadRef\n\t37: LdU128(0)\n\t38: Neq\n\t39: BrFalse(47)\nB5:\n\t40: CopyLoc[4](loc2: u64)\n\t41: CopyLoc[9](loc7: &mut PoolRewardInfo)\n\t42: ImmBorrowField[22](PoolRewardInfo.last_update_time: u64)\n\t43: ReadRef\n\t44: Gt\n\t45: StLoc[2](loc0: bool)\n\t46: Branch(49)\nB6:\n\t47: LdFalse\n\t48: StLoc[2](loc0: bool)\nB7:\n\t49: MoveLoc[2](loc0: bool)\n\t50: BrFalse(90)\nB8:\n\t51: MoveLoc[4](loc2: u64)\n\t52: CopyLoc[9](loc7: &mut PoolRewardInfo)\n\t53: ImmBorrowField[22](PoolRewardInfo.last_update_time: u64)\n\t54: ReadRef\n\t55: Sub\n\t56: CastU128\n\t57: CopyLoc[9](loc7: &mut PoolRewardInfo)\n\t58: ImmBorrowField[26](PoolRewardInfo.reward_per_seconds: u128)\n\t59: ReadRef\n\t60: Call full_math_u128::full_mul(u128, u128): u256\n\t61: StLoc[6](loc4: u256)\n\t62: CopyLoc[6](loc4: u256)\n\t63: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t64: ImmBorrowFieldGeneric[15](Pool.liquidity: u128)\n\t65: ReadRef\n\t66: CastU256\n\t67: Div\n\t68: StLoc[7](loc5: u256)\n\t69: CopyLoc[9](loc7: &mut PoolRewardInfo)\n\t70: ImmBorrowField[27](PoolRewardInfo.reward_growth_global: u128)\n\t71: ReadRef\n\t72: MoveLoc[7](loc5: u256)\n\t73: CastU128\n\t74: Call full_math_u128::wrapping_add(u128, u128): u128\n\t75: CopyLoc[9](loc7: &mut PoolRewardInfo)\n\t76: MutBorrowField[27](PoolRewardInfo.reward_growth_global: u128)\n\t77: WriteRef\n\t78: CopyLoc[9](loc7: &mut PoolRewardInfo)\n\t79: ImmBorrowField[25](PoolRewardInfo.total_reward_allocated: u64)\n\t80: ReadRef\n\t81: MoveLoc[6](loc4: u256)\n\t82: Call constants::get_q64(): u128\n\t83: CastU256\n\t84: Div\n\t85: CastU64\n\t86: Add\n\t87: CopyLoc[9](loc7: &mut PoolRewardInfo)\n\t88: MutBorrowField[25](PoolRewardInfo.total_reward_allocated: u64)\n\t89: WriteRef\nB9:\n\t90: CopyLoc[1](Arg1: u64)\n\t91: CopyLoc[9](loc7: &mut PoolRewardInfo)\n\t92: MutBorrowField[22](PoolRewardInfo.last_update_time: u64)\n\t93: WriteRef\nB10:\n\t94: MutBorrowLoc[8](loc6: vector<u128>)\n\t95: MoveLoc[9](loc7: &mut PoolRewardInfo)\n\t96: ImmBorrowField[27](PoolRewardInfo.reward_growth_global: u128)\n\t97: ReadRef\n\t98: VecPushBack(3)\n\t99: Branch(8)\nB11:\n\t100: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t101: Pop\n\t102: MoveLoc[8](loc6: vector<u128>)\n\t103: Ret\n}\n\nfind_reward_info_index<Ty0, Ty1, Ty2>(Arg0: &Pool<Ty0, Ty1>): u64 {\nL1:\tloc0: u64\nL2:\tloc1: bool\nL3:\tloc2: u64\nL4:\tloc3: u64\nB0:\n\t0: LdU64(0)\n\t1: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t2: ImmBorrowFieldGeneric[20](Pool.reward_infos: vector<PoolRewardInfo>)\n\t3: VecLen(51)\n\t4: StLoc[4](loc3: u64)\n\t5: StLoc[3](loc2: u64)\n\t6: LdFalse\n\t7: CopyLoc[3](loc2: u64)\n\t8: StLoc[1](loc0: u64)\n\t9: StLoc[2](loc1: bool)\nB1:\n\t10: CopyLoc[3](loc2: u64)\n\t11: CopyLoc[4](loc3: u64)\n\t12: Lt\n\t13: BrFalse(36)\nB2:\n\t14: Branch(15)\nB3:\n\t15: CopyLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t16: ImmBorrowFieldGeneric[20](Pool.reward_infos: vector<PoolRewardInfo>)\n\t17: CopyLoc[3](loc2: u64)\n\t18: VecImmBorrow(51)\n\t19: ImmBorrowField[21](PoolRewardInfo.reward_coin_type: TypeName)\n\t20: ReadRef\n\t21: Call type_name::get<Ty2>(): TypeName\n\t22: Eq\n\t23: BrFalse(31)\nB4:\n\t24: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t25: Pop\n\t26: LdTrue\n\t27: MoveLoc[3](loc2: u64)\n\t28: StLoc[1](loc0: u64)\n\t29: StLoc[2](loc1: bool)\n\t30: Branch(36)\nB5:\n\t31: MoveLoc[3](loc2: u64)\n\t32: LdU64(1)\n\t33: Add\n\t34: StLoc[3](loc2: u64)\n\t35: Branch(10)\nB6:\n\t36: MoveLoc[2](loc1: bool)\n\t37: Not\n\t38: BrFalse(41)\nB7:\n\t39: LdConst[10](u64: 10)\n\t40: Abort\nB8:\n\t41: MoveLoc[1](loc0: u64)\n\t42: Ret\n}\n\ncheck_pool_match<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>, Arg1: ID) {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t2: MoveLoc[1](Arg1: ID)\n\t3: Neq\n\t4: BrFalse(7)\nB1:\n\t5: LdConst[0](u64: 0)\n\t6: Abort\nB2:\n\t7: Ret\n}\n\ncheck_lock<Ty0, Ty1>(Arg0: &Pool<Ty0, Ty1>) {\nB0:\n\t0: MoveLoc[0](Arg0: &Pool<Ty0, Ty1>)\n\t1: ImmBorrowFieldGeneric[19](Pool.locked: bool)\n\t2: ReadRef\n\t3: BrFalse(6)\nB1:\n\t4: LdConst[3](u64: 3)\n\t5: Abort\nB2:\n\t6: Ret\n}\n\ntake<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: u64, Arg2: u64): Balance<Ty0> * Balance<Ty1> {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t1: MutBorrowFieldGeneric[21](Pool.reserve_x: Balance<Ty0>)\n\t2: MoveLoc[1](Arg1: u64)\n\t3: Call safe_withdraw<Ty0>(&mut Balance<Ty0>, u64): Balance<Ty0>\n\t4: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t5: MutBorrowFieldGeneric[22](Pool.reserve_y: Balance<Ty1>)\n\t6: MoveLoc[2](Arg2: u64)\n\t7: Call safe_withdraw<Ty1>(&mut Balance<Ty1>, u64): Balance<Ty1>\n\t8: Ret\n}\n\nput<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: Balance<Ty0>, Arg2: Balance<Ty1>) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t1: MutBorrowFieldGeneric[21](Pool.reserve_x: Balance<Ty0>)\n\t2: MoveLoc[1](Arg1: Balance<Ty0>)\n\t3: Call balance::join<Ty0>(&mut Balance<Ty0>, Balance<Ty0>): u64\n\t4: Pop\n\t5: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t6: MutBorrowFieldGeneric[22](Pool.reserve_y: Balance<Ty1>)\n\t7: MoveLoc[2](Arg2: Balance<Ty1>)\n\t8: Call balance::join<Ty1>(&mut Balance<Ty1>, Balance<Ty1>): u64\n\t9: Pop\n\t10: Ret\n}\n\nsafe_withdraw<Ty0>(Arg0: &mut Balance<Ty0>, Arg1: u64): Balance<Ty0> {\nL2:\tloc0: u64\nB0:\n\t0: MoveLoc[1](Arg1: u64)\n\t1: CopyLoc[0](Arg0: &mut Balance<Ty0>)\n\t2: FreezeRef\n\t3: Call balance::value<Ty0>(&Balance<Ty0>): u64\n\t4: Call math::min(u64, u64): u64\n\t5: StLoc[2](loc0: u64)\n\t6: MoveLoc[0](Arg0: &mut Balance<Ty0>)\n\t7: MoveLoc[2](loc0: u64)\n\t8: Call balance::split<Ty0>(&mut Balance<Ty0>, u64): Balance<Ty0>\n\t9: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n\t4 => u64: 4\n\t5 => u64: 5\n\t6 => u64: 6\n\t7 => u64: 7\n\t8 => u64: 8\n\t9 => u64: 9\n\t10 => u64: 10\n\t11 => u64: 11\n]\n}\n",
      "pool_manager": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.pool_manager {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::admin_cap;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::pool;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::utils;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::versioned;\nuse 0000000000000000000000000000000000000000000000000000000000000001::type_name;\nuse 0000000000000000000000000000000000000000000000000000000000000002::balance;\nuse 0000000000000000000000000000000000000000000000000000000000000002::clock;\nuse 0000000000000000000000000000000000000000000000000000000000000002::coin;\nuse 0000000000000000000000000000000000000000000000000000000000000002::dynamic_object_field;\nuse 0000000000000000000000000000000000000000000000000000000000000002::event;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::table;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct PoolDfKey has copy, drop, store {\n\tcoin_type_x: TypeName,\n\tcoin_type_y: TypeName,\n\tfee_rate: u64\n}\n\nstruct PoolRegistry has store, key {\n\tid: UID,\n\tfee_amount_tick_spacing: Table<u64, u32>,\n\tnum_pools: u64\n}\n\nstruct PoolCreated has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tcoin_type_x: TypeName,\n\tcoin_type_y: TypeName,\n\tfee_rate: u64,\n\ttick_spacing: u32\n}\n\nstruct FeeRateEnabled has copy, drop, store {\n\tsender: address,\n\tfee_rate: u64,\n\ttick_spacing: u32\n}\n\ninit(Arg0: &mut TxContext) {\nL1:\tloc0: &mut TxContext\nL2:\tloc1: &mut TxContext\nL3:\tloc2: &mut TxContext\nL4:\tloc3: &mut TxContext\nL5:\tloc4: PoolRegistry\nB0:\n\t0: CopyLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: CopyLoc[0](Arg0: &mut TxContext)\n\t3: Call table::new<u64, u32>(&mut TxContext): Table<u64, u32>\n\t4: LdU64(0)\n\t5: Pack[1](PoolRegistry)\n\t6: StLoc[5](loc4: PoolRegistry)\n\t7: MutBorrowLoc[5](loc4: PoolRegistry)\n\t8: CopyLoc[0](Arg0: &mut TxContext)\n\t9: StLoc[3](loc2: &mut TxContext)\n\t10: LdU64(100)\n\t11: LdU32(2)\n\t12: MoveLoc[3](loc2: &mut TxContext)\n\t13: FreezeRef\n\t14: Call enable_fee_rate_internal(&mut PoolRegistry, u64, u32, &TxContext)\n\t15: MutBorrowLoc[5](loc4: PoolRegistry)\n\t16: CopyLoc[0](Arg0: &mut TxContext)\n\t17: StLoc[4](loc3: &mut TxContext)\n\t18: LdU64(500)\n\t19: LdU32(10)\n\t20: MoveLoc[4](loc3: &mut TxContext)\n\t21: FreezeRef\n\t22: Call enable_fee_rate_internal(&mut PoolRegistry, u64, u32, &TxContext)\n\t23: MutBorrowLoc[5](loc4: PoolRegistry)\n\t24: CopyLoc[0](Arg0: &mut TxContext)\n\t25: StLoc[1](loc0: &mut TxContext)\n\t26: LdU64(3000)\n\t27: LdU32(60)\n\t28: MoveLoc[1](loc0: &mut TxContext)\n\t29: FreezeRef\n\t30: Call enable_fee_rate_internal(&mut PoolRegistry, u64, u32, &TxContext)\n\t31: MutBorrowLoc[5](loc4: PoolRegistry)\n\t32: MoveLoc[0](Arg0: &mut TxContext)\n\t33: StLoc[2](loc1: &mut TxContext)\n\t34: LdU64(10000)\n\t35: LdU32(200)\n\t36: MoveLoc[2](loc1: &mut TxContext)\n\t37: FreezeRef\n\t38: Call enable_fee_rate_internal(&mut PoolRegistry, u64, u32, &TxContext)\n\t39: MoveLoc[5](loc4: PoolRegistry)\n\t40: Call transfer::share_object<PoolRegistry>(PoolRegistry)\n\t41: Ret\n}\n\npool_key<Ty0, Ty1>(Arg0: u64): PoolDfKey {\nB0:\n\t0: Call type_name::get<Ty0>(): TypeName\n\t1: Call type_name::get<Ty1>(): TypeName\n\t2: MoveLoc[0](Arg0: u64)\n\t3: Pack[0](PoolDfKey)\n\t4: Ret\n}\n\npublic check_exists<Ty0, Ty1>(Arg0: &PoolRegistry, Arg1: u64) {\nB0:\n\t0: MoveLoc[0](Arg0: &PoolRegistry)\n\t1: ImmBorrowField[0](PoolRegistry.id: UID)\n\t2: MoveLoc[1](Arg1: u64)\n\t3: Call pool_key<Ty0, Ty1>(u64): PoolDfKey\n\t4: Call dynamic_object_field::exists_<PoolDfKey>(&UID, PoolDfKey): bool\n\t5: Not\n\t6: BrFalse(9)\nB1:\n\t7: LdConst[4](u64: 5)\n\t8: Abort\nB2:\n\t9: Ret\n}\n\npublic borrow_pool<Ty0, Ty1>(Arg0: &PoolRegistry, Arg1: u64): &Pool<Ty0, Ty1> {\nB0:\n\t0: CopyLoc[0](Arg0: &PoolRegistry)\n\t1: CopyLoc[1](Arg1: u64)\n\t2: Call check_exists<Ty0, Ty1>(&PoolRegistry, u64)\n\t3: MoveLoc[0](Arg0: &PoolRegistry)\n\t4: ImmBorrowField[0](PoolRegistry.id: UID)\n\t5: MoveLoc[1](Arg1: u64)\n\t6: Call pool_key<Ty0, Ty1>(u64): PoolDfKey\n\t7: Call dynamic_object_field::borrow<PoolDfKey, Pool<Ty0, Ty1>>(&UID, PoolDfKey): &Pool<Ty0, Ty1>\n\t8: Ret\n}\n\npublic borrow_mut_pool<Ty0, Ty1>(Arg0: &mut PoolRegistry, Arg1: u64): &mut Pool<Ty0, Ty1> {\nL2:\tloc0: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut PoolRegistry)\n\t1: CopyLoc[1](Arg1: u64)\n\t2: StLoc[2](loc0: u64)\n\t3: FreezeRef\n\t4: MoveLoc[2](loc0: u64)\n\t5: Call check_exists<Ty0, Ty1>(&PoolRegistry, u64)\n\t6: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t7: MutBorrowField[0](PoolRegistry.id: UID)\n\t8: MoveLoc[1](Arg1: u64)\n\t9: Call pool_key<Ty0, Ty1>(u64): PoolDfKey\n\t10: Call dynamic_object_field::borrow_mut<PoolDfKey, Pool<Ty0, Ty1>>(&mut UID, PoolDfKey): &mut Pool<Ty0, Ty1>\n\t11: Ret\n}\n\ncreate_pool_<Ty0, Ty1>(Arg0: &mut PoolRegistry, Arg1: u64, Arg2: &mut TxContext) {\nL3:\tloc0: PoolDfKey\nL4:\tloc1: Pool<Ty0, Ty1>\nL5:\tloc2: u32\nB0:\n\t0: CopyLoc[0](Arg0: &mut PoolRegistry)\n\t1: ImmBorrowField[1](PoolRegistry.fee_amount_tick_spacing: Table<u64, u32>)\n\t2: CopyLoc[1](Arg1: u64)\n\t3: Call table::borrow<u64, u32>(&Table<u64, u32>, u64): &u32\n\t4: ReadRef\n\t5: StLoc[5](loc2: u32)\n\t6: CopyLoc[1](Arg1: u64)\n\t7: Call pool_key<Ty0, Ty1>(u64): PoolDfKey\n\t8: StLoc[3](loc0: PoolDfKey)\n\t9: CopyLoc[0](Arg0: &mut PoolRegistry)\n\t10: ImmBorrowField[0](PoolRegistry.id: UID)\n\t11: CopyLoc[3](loc0: PoolDfKey)\n\t12: Call dynamic_object_field::exists_<PoolDfKey>(&UID, PoolDfKey): bool\n\t13: BrFalse(20)\nB1:\n\t14: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t15: Pop\n\t16: MoveLoc[2](Arg2: &mut TxContext)\n\t17: Pop\n\t18: LdConst[0](u64: 1)\n\t19: Abort\nB2:\n\t20: CopyLoc[1](Arg1: u64)\n\t21: CopyLoc[5](loc2: u32)\n\t22: CopyLoc[2](Arg2: &mut TxContext)\n\t23: Call pool::create<Ty0, Ty1>(u64, u32, &mut TxContext): Pool<Ty0, Ty1>\n\t24: StLoc[4](loc1: Pool<Ty0, Ty1>)\n\t25: MoveLoc[2](Arg2: &mut TxContext)\n\t26: FreezeRef\n\t27: Call tx_context::sender(&TxContext): address\n\t28: ImmBorrowLoc[4](loc1: Pool<Ty0, Ty1>)\n\t29: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t30: ImmBorrowLoc[4](loc1: Pool<Ty0, Ty1>)\n\t31: Call pool::coin_type_x<Ty0, Ty1>(&Pool<Ty0, Ty1>): TypeName\n\t32: ImmBorrowLoc[4](loc1: Pool<Ty0, Ty1>)\n\t33: Call pool::coin_type_y<Ty0, Ty1>(&Pool<Ty0, Ty1>): TypeName\n\t34: MoveLoc[1](Arg1: u64)\n\t35: MoveLoc[5](loc2: u32)\n\t36: Pack[2](PoolCreated)\n\t37: Call event::emit<PoolCreated>(PoolCreated)\n\t38: CopyLoc[0](Arg0: &mut PoolRegistry)\n\t39: MutBorrowField[0](PoolRegistry.id: UID)\n\t40: MoveLoc[3](loc0: PoolDfKey)\n\t41: MoveLoc[4](loc1: Pool<Ty0, Ty1>)\n\t42: Call dynamic_object_field::add<PoolDfKey, Pool<Ty0, Ty1>>(&mut UID, PoolDfKey, Pool<Ty0, Ty1>)\n\t43: CopyLoc[0](Arg0: &mut PoolRegistry)\n\t44: ImmBorrowField[2](PoolRegistry.num_pools: u64)\n\t45: ReadRef\n\t46: LdU64(1)\n\t47: Add\n\t48: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t49: MutBorrowField[2](PoolRegistry.num_pools: u64)\n\t50: WriteRef\n\t51: Ret\n}\n\npublic create_pool<Ty0, Ty1>(Arg0: &mut PoolRegistry, Arg1: u64, Arg2: &Versioned, Arg3: &mut TxContext) {\nB0:\n\t0: MoveLoc[2](Arg2: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[0](Arg0: &mut PoolRegistry)\n\t3: ImmBorrowField[1](PoolRegistry.fee_amount_tick_spacing: Table<u64, u32>)\n\t4: CopyLoc[1](Arg1: u64)\n\t5: Call table::contains<u64, u32>(&Table<u64, u32>, u64): bool\n\t6: Not\n\t7: BrFalse(14)\nB1:\n\t8: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t9: Pop\n\t10: MoveLoc[3](Arg3: &mut TxContext)\n\t11: Pop\n\t12: LdConst[5](u64: 6)\n\t13: Abort\nB2:\n\t14: Call utils::is_ordered<Ty0, Ty1>(): bool\n\t15: BrFalse(21)\nB3:\n\t16: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t17: MoveLoc[1](Arg1: u64)\n\t18: MoveLoc[3](Arg3: &mut TxContext)\n\t19: Call create_pool_<Ty0, Ty1>(&mut PoolRegistry, u64, &mut TxContext)\n\t20: Branch(25)\nB4:\n\t21: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t22: MoveLoc[1](Arg1: u64)\n\t23: MoveLoc[3](Arg3: &mut TxContext)\n\t24: Call create_pool_<Ty1, Ty0>(&mut PoolRegistry, u64, &mut TxContext)\nB5:\n\t25: Ret\n}\n\npublic create_and_initialize_pool<Ty0, Ty1>(Arg0: &mut PoolRegistry, Arg1: u64, Arg2: u128, Arg3: &Versioned, Arg4: &Clock, Arg5: &mut TxContext) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut PoolRegistry)\n\t1: CopyLoc[1](Arg1: u64)\n\t2: CopyLoc[3](Arg3: &Versioned)\n\t3: CopyLoc[5](Arg5: &mut TxContext)\n\t4: Call create_pool<Ty0, Ty1>(&mut PoolRegistry, u64, &Versioned, &mut TxContext)\n\t5: Call utils::is_ordered<Ty0, Ty1>(): bool\n\t6: BrFalse(17)\nB1:\n\t7: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t8: MoveLoc[1](Arg1: u64)\n\t9: Call borrow_mut_pool<Ty0, Ty1>(&mut PoolRegistry, u64): &mut Pool<Ty0, Ty1>\n\t10: MoveLoc[2](Arg2: u128)\n\t11: MoveLoc[3](Arg3: &Versioned)\n\t12: MoveLoc[4](Arg4: &Clock)\n\t13: MoveLoc[5](Arg5: &mut TxContext)\n\t14: FreezeRef\n\t15: Call pool::initialize<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, u128, &Versioned, &Clock, &TxContext)\n\t16: Branch(26)\nB2:\n\t17: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t18: MoveLoc[1](Arg1: u64)\n\t19: Call borrow_mut_pool<Ty1, Ty0>(&mut PoolRegistry, u64): &mut Pool<Ty1, Ty0>\n\t20: MoveLoc[2](Arg2: u128)\n\t21: MoveLoc[3](Arg3: &Versioned)\n\t22: MoveLoc[4](Arg4: &Clock)\n\t23: MoveLoc[5](Arg5: &mut TxContext)\n\t24: FreezeRef\n\t25: Call pool::initialize<Ty1, Ty0>(&mut Pool<Ty1, Ty0>, u128, &Versioned, &Clock, &TxContext)\nB3:\n\t26: Ret\n}\n\npublic enable_fee_rate(Arg0: &AdminCap, Arg1: &mut PoolRegistry, Arg2: u64, Arg3: u32, Arg4: &Versioned, Arg5: &TxContext) {\nL6:\tloc0: bool\nB0:\n\t0: MoveLoc[4](Arg4: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: CopyLoc[2](Arg2: u64)\n\t3: LdU64(1000000)\n\t4: Ge\n\t5: BrFalse(12)\nB1:\n\t6: MoveLoc[1](Arg1: &mut PoolRegistry)\n\t7: Pop\n\t8: MoveLoc[5](Arg5: &TxContext)\n\t9: Pop\n\t10: LdConst[1](u64: 2)\n\t11: Abort\nB2:\n\t12: CopyLoc[3](Arg3: u32)\n\t13: LdU32(0)\n\t14: Eq\n\t15: BrFalse(19)\nB3:\n\t16: LdTrue\n\t17: StLoc[6](loc0: bool)\n\t18: Branch(23)\nB4:\n\t19: CopyLoc[3](Arg3: u32)\n\t20: LdU32(4194304)\n\t21: Ge\n\t22: StLoc[6](loc0: bool)\nB5:\n\t23: MoveLoc[6](loc0: bool)\n\t24: BrFalse(31)\nB6:\n\t25: MoveLoc[1](Arg1: &mut PoolRegistry)\n\t26: Pop\n\t27: MoveLoc[5](Arg5: &TxContext)\n\t28: Pop\n\t29: LdConst[2](u64: 3)\n\t30: Abort\nB7:\n\t31: CopyLoc[1](Arg1: &mut PoolRegistry)\n\t32: ImmBorrowField[1](PoolRegistry.fee_amount_tick_spacing: Table<u64, u32>)\n\t33: CopyLoc[2](Arg2: u64)\n\t34: Call table::contains<u64, u32>(&Table<u64, u32>, u64): bool\n\t35: BrFalse(42)\nB8:\n\t36: MoveLoc[1](Arg1: &mut PoolRegistry)\n\t37: Pop\n\t38: MoveLoc[5](Arg5: &TxContext)\n\t39: Pop\n\t40: LdConst[3](u64: 4)\n\t41: Abort\nB9:\n\t42: MoveLoc[1](Arg1: &mut PoolRegistry)\n\t43: MoveLoc[2](Arg2: u64)\n\t44: MoveLoc[3](Arg3: u32)\n\t45: MoveLoc[5](Arg5: &TxContext)\n\t46: Call enable_fee_rate_internal(&mut PoolRegistry, u64, u32, &TxContext)\n\t47: Ret\n}\n\npublic set_protocol_fee_rate<Ty0, Ty1>(Arg0: &AdminCap, Arg1: &mut PoolRegistry, Arg2: u64, Arg3: u64, Arg4: u64, Arg5: &Versioned, Arg6: &mut TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: &AdminCap)\n\t1: MoveLoc[1](Arg1: &mut PoolRegistry)\n\t2: MoveLoc[2](Arg2: u64)\n\t3: Call borrow_mut_pool<Ty0, Ty1>(&mut PoolRegistry, u64): &mut Pool<Ty0, Ty1>\n\t4: MoveLoc[3](Arg3: u64)\n\t5: MoveLoc[4](Arg4: u64)\n\t6: MoveLoc[5](Arg5: &Versioned)\n\t7: MoveLoc[6](Arg6: &mut TxContext)\n\t8: FreezeRef\n\t9: Call pool::set_protocol_fee_rate<Ty0, Ty1>(&AdminCap, &mut Pool<Ty0, Ty1>, u64, u64, &Versioned, &TxContext)\n\t10: Ret\n}\n\npublic collect_protocol_fee<Ty0, Ty1>(Arg0: &AdminCap, Arg1: &mut PoolRegistry, Arg2: u64, Arg3: u64, Arg4: u64, Arg5: &Versioned, Arg6: &mut TxContext): Coin<Ty0> * Coin<Ty1> {\nL7:\tloc0: Balance<Ty1>\nB0:\n\t0: MoveLoc[0](Arg0: &AdminCap)\n\t1: MoveLoc[1](Arg1: &mut PoolRegistry)\n\t2: MoveLoc[2](Arg2: u64)\n\t3: Call borrow_mut_pool<Ty0, Ty1>(&mut PoolRegistry, u64): &mut Pool<Ty0, Ty1>\n\t4: MoveLoc[3](Arg3: u64)\n\t5: MoveLoc[4](Arg4: u64)\n\t6: MoveLoc[5](Arg5: &Versioned)\n\t7: CopyLoc[6](Arg6: &mut TxContext)\n\t8: FreezeRef\n\t9: Call pool::collect_protocol_fee<Ty0, Ty1>(&AdminCap, &mut Pool<Ty0, Ty1>, u64, u64, &Versioned, &TxContext): Balance<Ty0> * Balance<Ty1>\n\t10: StLoc[7](loc0: Balance<Ty1>)\n\t11: CopyLoc[6](Arg6: &mut TxContext)\n\t12: Call coin::from_balance<Ty0>(Balance<Ty0>, &mut TxContext): Coin<Ty0>\n\t13: MoveLoc[7](loc0: Balance<Ty1>)\n\t14: MoveLoc[6](Arg6: &mut TxContext)\n\t15: Call coin::from_balance<Ty1>(Balance<Ty1>, &mut TxContext): Coin<Ty1>\n\t16: Ret\n}\n\npublic initialize_pool_reward<Ty0, Ty1, Ty2>(Arg0: &AdminCap, Arg1: &mut PoolRegistry, Arg2: u64, Arg3: u64, Arg4: u64, Arg5: Coin<Ty2>, Arg6: &Versioned, Arg7: &Clock, Arg8: &TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: &AdminCap)\n\t1: MoveLoc[1](Arg1: &mut PoolRegistry)\n\t2: MoveLoc[2](Arg2: u64)\n\t3: Call borrow_mut_pool<Ty0, Ty1>(&mut PoolRegistry, u64): &mut Pool<Ty0, Ty1>\n\t4: MoveLoc[3](Arg3: u64)\n\t5: MoveLoc[4](Arg4: u64)\n\t6: MoveLoc[5](Arg5: Coin<Ty2>)\n\t7: Call coin::into_balance<Ty2>(Coin<Ty2>): Balance<Ty2>\n\t8: MoveLoc[6](Arg6: &Versioned)\n\t9: MoveLoc[7](Arg7: &Clock)\n\t10: MoveLoc[8](Arg8: &TxContext)\n\t11: Call pool::initialize_pool_reward<Ty0, Ty1, Ty2>(&AdminCap, &mut Pool<Ty0, Ty1>, u64, u64, Balance<Ty2>, &Versioned, &Clock, &TxContext)\n\t12: Ret\n}\n\npublic increase_pool_reward<Ty0, Ty1, Ty2>(Arg0: &AdminCap, Arg1: &mut PoolRegistry, Arg2: u64, Arg3: Coin<Ty2>, Arg4: &Versioned, Arg5: &Clock, Arg6: &TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: &AdminCap)\n\t1: MoveLoc[1](Arg1: &mut PoolRegistry)\n\t2: MoveLoc[2](Arg2: u64)\n\t3: Call borrow_mut_pool<Ty0, Ty1>(&mut PoolRegistry, u64): &mut Pool<Ty0, Ty1>\n\t4: MoveLoc[3](Arg3: Coin<Ty2>)\n\t5: Call coin::into_balance<Ty2>(Coin<Ty2>): Balance<Ty2>\n\t6: MoveLoc[4](Arg4: &Versioned)\n\t7: MoveLoc[5](Arg5: &Clock)\n\t8: MoveLoc[6](Arg6: &TxContext)\n\t9: Call pool::increase_pool_reward<Ty0, Ty1, Ty2>(&AdminCap, &mut Pool<Ty0, Ty1>, Balance<Ty2>, &Versioned, &Clock, &TxContext)\n\t10: Ret\n}\n\npublic extend_pool_reward_timestamp<Ty0, Ty1, Ty2>(Arg0: &AdminCap, Arg1: &mut PoolRegistry, Arg2: u64, Arg3: u64, Arg4: &Versioned, Arg5: &Clock, Arg6: &TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: &AdminCap)\n\t1: MoveLoc[1](Arg1: &mut PoolRegistry)\n\t2: MoveLoc[2](Arg2: u64)\n\t3: Call borrow_mut_pool<Ty0, Ty1>(&mut PoolRegistry, u64): &mut Pool<Ty0, Ty1>\n\t4: MoveLoc[3](Arg3: u64)\n\t5: MoveLoc[4](Arg4: &Versioned)\n\t6: MoveLoc[5](Arg5: &Clock)\n\t7: MoveLoc[6](Arg6: &TxContext)\n\t8: Call pool::extend_pool_reward_timestamp<Ty0, Ty1, Ty2>(&AdminCap, &mut Pool<Ty0, Ty1>, u64, &Versioned, &Clock, &TxContext)\n\t9: Ret\n}\n\nenable_fee_rate_internal(Arg0: &mut PoolRegistry, Arg1: u64, Arg2: u32, Arg3: &TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t1: MutBorrowField[1](PoolRegistry.fee_amount_tick_spacing: Table<u64, u32>)\n\t2: CopyLoc[1](Arg1: u64)\n\t3: CopyLoc[2](Arg2: u32)\n\t4: Call table::add<u64, u32>(&mut Table<u64, u32>, u64, u32)\n\t5: MoveLoc[3](Arg3: &TxContext)\n\t6: Call tx_context::sender(&TxContext): address\n\t7: MoveLoc[1](Arg1: u64)\n\t8: MoveLoc[2](Arg2: u32)\n\t9: Pack[3](FeeRateEnabled)\n\t10: Call event::emit<FeeRateEnabled>(FeeRateEnabled)\n\t11: Ret\n}\n\nConstants [\n\t0 => u64: 1\n\t1 => u64: 2\n\t2 => u64: 3\n\t3 => u64: 4\n\t4 => u64: 5\n\t5 => u64: 6\n]\n}\n",
      "position": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.position {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::constants;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::full_math_u128;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::full_math_u64;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i128;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i32;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::liquidity_math;\nuse 0000000000000000000000000000000000000000000000000000000000000001::string;\nuse 0000000000000000000000000000000000000000000000000000000000000001::type_name;\nuse 0000000000000000000000000000000000000000000000000000000000000002::display;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::package;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct POSITION has drop {\n\tdummy_field: bool\n}\n\nstruct Position has store, key {\n\tid: UID,\n\tpool_id: ID,\n\tfee_rate: u64,\n\tcoin_type_x: TypeName,\n\tcoin_type_y: TypeName,\n\ttick_lower_index: I32,\n\ttick_upper_index: I32,\n\tliquidity: u128,\n\tfee_growth_inside_x_last: u128,\n\tfee_growth_inside_y_last: u128,\n\tcoins_owed_x: u64,\n\tcoins_owed_y: u64,\n\treward_infos: vector<PositionRewardInfo>\n}\n\nstruct PositionRewardInfo has copy, drop, store {\n\treward_growth_inside_last: u128,\n\tcoins_owed_reward: u64\n}\n\ninit(Arg0: POSITION, Arg1: &mut TxContext) {\nL2:\tloc0: Display<Position>\nL3:\tloc1: Publisher\nB0:\n\t0: MoveLoc[0](Arg0: POSITION)\n\t1: CopyLoc[1](Arg1: &mut TxContext)\n\t2: Call package::claim<POSITION>(POSITION, &mut TxContext): Publisher\n\t3: StLoc[3](loc1: Publisher)\n\t4: ImmBorrowLoc[3](loc1: Publisher)\n\t5: CopyLoc[1](Arg1: &mut TxContext)\n\t6: Call display::new<Position>(&Publisher, &mut TxContext): Display<Position>\n\t7: StLoc[2](loc0: Display<Position>)\n\t8: MutBorrowLoc[2](loc0: Display<Position>)\n\t9: LdConst[2](vector<u8>: \"nam..)\n\t10: Call string::utf8(vector<u8>): String\n\t11: LdConst[3](vector<u8>: \"Flo..)\n\t12: Call string::utf8(vector<u8>): String\n\t13: Call display::add<Position>(&mut Display<Position>, String, String)\n\t14: MutBorrowLoc[2](loc0: Display<Position>)\n\t15: LdConst[4](vector<u8>: \"des..)\n\t16: Call string::utf8(vector<u8>): String\n\t17: LdConst[5](vector<u8>: \"Thi..)\n\t18: Call string::utf8(vector<u8>): String\n\t19: Call display::add<Position>(&mut Display<Position>, String, String)\n\t20: MutBorrowLoc[2](loc0: Display<Position>)\n\t21: LdConst[6](vector<u8>: \"ima..)\n\t22: Call string::utf8(vector<u8>): String\n\t23: LdConst[7](vector<u8>: \"htt..)\n\t24: Call string::utf8(vector<u8>): String\n\t25: Call display::add<Position>(&mut Display<Position>, String, String)\n\t26: MutBorrowLoc[2](loc0: Display<Position>)\n\t27: Call display::update_version<Position>(&mut Display<Position>)\n\t28: MoveLoc[2](loc0: Display<Position>)\n\t29: CopyLoc[1](Arg1: &mut TxContext)\n\t30: FreezeRef\n\t31: Call tx_context::sender(&TxContext): address\n\t32: Call transfer::public_transfer<Display<Position>>(Display<Position>, address)\n\t33: MoveLoc[3](loc1: Publisher)\n\t34: MoveLoc[1](Arg1: &mut TxContext)\n\t35: FreezeRef\n\t36: Call tx_context::sender(&TxContext): address\n\t37: Call transfer::public_transfer<Publisher>(Publisher, address)\n\t38: Ret\n}\n\npublic pool_id(Arg0: &Position): ID {\nB0:\n\t0: MoveLoc[0](Arg0: &Position)\n\t1: ImmBorrowField[0](Position.pool_id: ID)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic fee_rate(Arg0: &Position): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Position)\n\t1: ImmBorrowField[1](Position.fee_rate: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic liquidity(Arg0: &Position): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: &Position)\n\t1: ImmBorrowField[2](Position.liquidity: u128)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic tick_lower_index(Arg0: &Position): I32 {\nB0:\n\t0: MoveLoc[0](Arg0: &Position)\n\t1: ImmBorrowField[3](Position.tick_lower_index: I32)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic tick_upper_index(Arg0: &Position): I32 {\nB0:\n\t0: MoveLoc[0](Arg0: &Position)\n\t1: ImmBorrowField[4](Position.tick_upper_index: I32)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic coins_owed_x(Arg0: &Position): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Position)\n\t1: ImmBorrowField[5](Position.coins_owed_x: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic coins_owed_y(Arg0: &Position): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Position)\n\t1: ImmBorrowField[6](Position.coins_owed_y: u64)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic fee_growth_inside_x_last(Arg0: &Position): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: &Position)\n\t1: ImmBorrowField[7](Position.fee_growth_inside_x_last: u128)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic fee_growth_inside_y_last(Arg0: &Position): u128 {\nB0:\n\t0: MoveLoc[0](Arg0: &Position)\n\t1: ImmBorrowField[8](Position.fee_growth_inside_y_last: u128)\n\t2: ReadRef\n\t3: Ret\n}\n\npublic reward_length(Arg0: &Position): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: &Position)\n\t1: ImmBorrowField[9](Position.reward_infos: vector<PositionRewardInfo>)\n\t2: VecLen(30)\n\t3: Ret\n}\n\npublic reward_growth_inside_last(Arg0: &Position, Arg1: u64): u128 {\nL2:\tloc0: u128\nL3:\tloc1: u64\nB0:\n\t0: CopyLoc[0](Arg0: &Position)\n\t1: ImmBorrowField[9](Position.reward_infos: vector<PositionRewardInfo>)\n\t2: VecLen(30)\n\t3: StLoc[3](loc1: u64)\n\t4: CopyLoc[1](Arg1: u64)\n\t5: MoveLoc[3](loc1: u64)\n\t6: Ge\n\t7: BrFalse(13)\nB1:\n\t8: MoveLoc[0](Arg0: &Position)\n\t9: Pop\n\t10: LdU128(0)\n\t11: StLoc[2](loc0: u128)\n\t12: Branch(20)\nB2:\n\t13: MoveLoc[0](Arg0: &Position)\n\t14: ImmBorrowField[9](Position.reward_infos: vector<PositionRewardInfo>)\n\t15: MoveLoc[1](Arg1: u64)\n\t16: VecImmBorrow(30)\n\t17: ImmBorrowField[10](PositionRewardInfo.reward_growth_inside_last: u128)\n\t18: ReadRef\n\t19: StLoc[2](loc0: u128)\nB3:\n\t20: MoveLoc[2](loc0: u128)\n\t21: Ret\n}\n\npublic coins_owed_reward(Arg0: &Position, Arg1: u64): u64 {\nL2:\tloc0: u64\nL3:\tloc1: u64\nB0:\n\t0: CopyLoc[0](Arg0: &Position)\n\t1: ImmBorrowField[9](Position.reward_infos: vector<PositionRewardInfo>)\n\t2: VecLen(30)\n\t3: StLoc[3](loc1: u64)\n\t4: CopyLoc[1](Arg1: u64)\n\t5: MoveLoc[3](loc1: u64)\n\t6: Ge\n\t7: BrFalse(13)\nB1:\n\t8: MoveLoc[0](Arg0: &Position)\n\t9: Pop\n\t10: LdU64(0)\n\t11: StLoc[2](loc0: u64)\n\t12: Branch(20)\nB2:\n\t13: MoveLoc[0](Arg0: &Position)\n\t14: ImmBorrowField[9](Position.reward_infos: vector<PositionRewardInfo>)\n\t15: MoveLoc[1](Arg1: u64)\n\t16: VecImmBorrow(30)\n\t17: ImmBorrowField[11](PositionRewardInfo.coins_owed_reward: u64)\n\t18: ReadRef\n\t19: StLoc[2](loc0: u64)\nB3:\n\t20: MoveLoc[2](loc0: u64)\n\t21: Ret\n}\n\npublic is_empty(Arg0: &Position): bool {\nL1:\tloc0: bool\nL2:\tloc1: bool\nL3:\tloc2: u64\nL4:\tloc3: bool\nL5:\tloc4: u64\nB0:\n\t0: LdTrue\n\t1: StLoc[4](loc3: bool)\n\t2: LdU64(0)\n\t3: CopyLoc[0](Arg0: &Position)\n\t4: ImmBorrowField[9](Position.reward_infos: vector<PositionRewardInfo>)\n\t5: VecLen(30)\n\t6: StLoc[5](loc4: u64)\n\t7: StLoc[3](loc2: u64)\nB1:\n\t8: CopyLoc[3](loc2: u64)\n\t9: CopyLoc[5](loc4: u64)\n\t10: Lt\n\t11: BrFalse(30)\nB2:\n\t12: Branch(13)\nB3:\n\t13: CopyLoc[0](Arg0: &Position)\n\t14: ImmBorrowField[9](Position.reward_infos: vector<PositionRewardInfo>)\n\t15: CopyLoc[3](loc2: u64)\n\t16: VecImmBorrow(30)\n\t17: ImmBorrowField[11](PositionRewardInfo.coins_owed_reward: u64)\n\t18: ReadRef\n\t19: LdU64(0)\n\t20: Neq\n\t21: BrFalse(25)\nB4:\n\t22: LdFalse\n\t23: StLoc[4](loc3: bool)\n\t24: Branch(30)\nB5:\n\t25: MoveLoc[3](loc2: u64)\n\t26: LdU64(1)\n\t27: Add\n\t28: StLoc[3](loc2: u64)\n\t29: Branch(8)\nB6:\n\t30: CopyLoc[0](Arg0: &Position)\n\t31: ImmBorrowField[2](Position.liquidity: u128)\n\t32: ReadRef\n\t33: LdU128(0)\n\t34: Eq\n\t35: BrFalse(43)\nB7:\n\t36: CopyLoc[0](Arg0: &Position)\n\t37: ImmBorrowField[5](Position.coins_owed_x: u64)\n\t38: ReadRef\n\t39: LdU64(0)\n\t40: Eq\n\t41: StLoc[1](loc0: bool)\n\t42: Branch(45)\nB8:\n\t43: LdFalse\n\t44: StLoc[1](loc0: bool)\nB9:\n\t45: MoveLoc[1](loc0: bool)\n\t46: BrFalse(54)\nB10:\n\t47: MoveLoc[0](Arg0: &Position)\n\t48: ImmBorrowField[6](Position.coins_owed_y: u64)\n\t49: ReadRef\n\t50: LdU64(0)\n\t51: Eq\n\t52: StLoc[2](loc1: bool)\n\t53: Branch(58)\nB11:\n\t54: MoveLoc[0](Arg0: &Position)\n\t55: Pop\n\t56: LdFalse\n\t57: StLoc[2](loc1: bool)\nB12:\n\t58: MoveLoc[2](loc1: bool)\n\t59: MoveLoc[4](loc3: bool)\n\t60: And\n\t61: Ret\n}\n\ntry_borrow_mut_reward_info(Arg0: &mut Position, Arg1: u64): &mut PositionRewardInfo {\nL2:\tloc0: u64\nB0:\n\t0: CopyLoc[0](Arg0: &mut Position)\n\t1: ImmBorrowField[9](Position.reward_infos: vector<PositionRewardInfo>)\n\t2: VecLen(30)\n\t3: StLoc[2](loc0: u64)\n\t4: CopyLoc[1](Arg1: u64)\n\t5: MoveLoc[2](loc0: u64)\n\t6: Ge\n\t7: BrFalse(14)\nB1:\n\t8: CopyLoc[0](Arg0: &mut Position)\n\t9: MutBorrowField[9](Position.reward_infos: vector<PositionRewardInfo>)\n\t10: LdU128(0)\n\t11: LdU64(0)\n\t12: Pack[2](PositionRewardInfo)\n\t13: VecPushBack(30)\nB2:\n\t14: MoveLoc[0](Arg0: &mut Position)\n\t15: MutBorrowField[9](Position.reward_infos: vector<PositionRewardInfo>)\n\t16: MoveLoc[1](Arg1: u64)\n\t17: VecMutBorrow(30)\n\t18: Ret\n}\n\npublic(friend) open(Arg0: ID, Arg1: u64, Arg2: TypeName, Arg3: TypeName, Arg4: I32, Arg5: I32, Arg6: &mut TxContext): Position {\nB0:\n\t0: MoveLoc[6](Arg6: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: MoveLoc[0](Arg0: ID)\n\t3: MoveLoc[1](Arg1: u64)\n\t4: MoveLoc[2](Arg2: TypeName)\n\t5: MoveLoc[3](Arg3: TypeName)\n\t6: MoveLoc[4](Arg4: I32)\n\t7: MoveLoc[5](Arg5: I32)\n\t8: LdU128(0)\n\t9: LdU128(0)\n\t10: LdU128(0)\n\t11: LdU64(0)\n\t12: LdU64(0)\n\t13: VecPack(30, 0)\n\t14: Pack[1](Position)\n\t15: Ret\n}\n\npublic(friend) close(Arg0: Position) {\nB0:\n\t0: MoveLoc[0](Arg0: Position)\n\t1: Unpack[1](Position)\n\t2: Pop\n\t3: Pop\n\t4: Pop\n\t5: Pop\n\t6: Pop\n\t7: Pop\n\t8: Pop\n\t9: Pop\n\t10: Pop\n\t11: Pop\n\t12: Pop\n\t13: Pop\n\t14: Call object::delete(UID)\n\t15: Ret\n}\n\npublic(friend) increase_debt(Arg0: &mut Position, Arg1: u64, Arg2: u64) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Position)\n\t1: ImmBorrowField[5](Position.coins_owed_x: u64)\n\t2: ReadRef\n\t3: MoveLoc[1](Arg1: u64)\n\t4: Add\n\t5: CopyLoc[0](Arg0: &mut Position)\n\t6: MutBorrowField[5](Position.coins_owed_x: u64)\n\t7: WriteRef\n\t8: CopyLoc[0](Arg0: &mut Position)\n\t9: ImmBorrowField[6](Position.coins_owed_y: u64)\n\t10: ReadRef\n\t11: MoveLoc[2](Arg2: u64)\n\t12: Add\n\t13: MoveLoc[0](Arg0: &mut Position)\n\t14: MutBorrowField[6](Position.coins_owed_y: u64)\n\t15: WriteRef\n\t16: Ret\n}\n\npublic(friend) decrease_debt(Arg0: &mut Position, Arg1: u64, Arg2: u64) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Position)\n\t1: ImmBorrowField[5](Position.coins_owed_x: u64)\n\t2: ReadRef\n\t3: MoveLoc[1](Arg1: u64)\n\t4: Sub\n\t5: CopyLoc[0](Arg0: &mut Position)\n\t6: MutBorrowField[5](Position.coins_owed_x: u64)\n\t7: WriteRef\n\t8: CopyLoc[0](Arg0: &mut Position)\n\t9: ImmBorrowField[6](Position.coins_owed_y: u64)\n\t10: ReadRef\n\t11: MoveLoc[2](Arg2: u64)\n\t12: Sub\n\t13: MoveLoc[0](Arg0: &mut Position)\n\t14: MutBorrowField[6](Position.coins_owed_y: u64)\n\t15: WriteRef\n\t16: Ret\n}\n\npublic(friend) decrease_reward_debt(Arg0: &mut Position, Arg1: u64, Arg2: u64) {\nL3:\tloc0: &mut PositionRewardInfo\nB0:\n\t0: MoveLoc[0](Arg0: &mut Position)\n\t1: MoveLoc[1](Arg1: u64)\n\t2: Call try_borrow_mut_reward_info(&mut Position, u64): &mut PositionRewardInfo\n\t3: StLoc[3](loc0: &mut PositionRewardInfo)\n\t4: CopyLoc[3](loc0: &mut PositionRewardInfo)\n\t5: ImmBorrowField[11](PositionRewardInfo.coins_owed_reward: u64)\n\t6: ReadRef\n\t7: MoveLoc[2](Arg2: u64)\n\t8: Sub\n\t9: MoveLoc[3](loc0: &mut PositionRewardInfo)\n\t10: MutBorrowField[11](PositionRewardInfo.coins_owed_reward: u64)\n\t11: WriteRef\n\t12: Ret\n}\n\npublic(friend) update(Arg0: &mut Position, Arg1: I128, Arg2: u128, Arg3: u128, Arg4: vector<u128>) {\nL5:\tloc0: u128\nL6:\tloc1: bool\nL7:\tloc2: bool\nL8:\tloc3: u128\nL9:\tloc4: u128\nL10:\tloc5: u128\nB0:\n\t0: CopyLoc[1](Arg1: I128)\n\t1: Call i128::zero(): I128\n\t2: Call i128::eq(I128, I128): bool\n\t3: BrFalse(19)\nB1:\n\t4: CopyLoc[0](Arg0: &mut Position)\n\t5: ImmBorrowField[2](Position.liquidity: u128)\n\t6: ReadRef\n\t7: LdU128(0)\n\t8: Eq\n\t9: BrFalse(14)\nB2:\n\t10: MoveLoc[0](Arg0: &mut Position)\n\t11: Pop\n\t12: LdConst[0](u64: 0)\n\t13: Abort\nB3:\n\t14: CopyLoc[0](Arg0: &mut Position)\n\t15: ImmBorrowField[2](Position.liquidity: u128)\n\t16: ReadRef\n\t17: StLoc[5](loc0: u128)\n\t18: Branch(25)\nB4:\n\t19: CopyLoc[0](Arg0: &mut Position)\n\t20: ImmBorrowField[2](Position.liquidity: u128)\n\t21: ReadRef\n\t22: MoveLoc[1](Arg1: I128)\n\t23: Call liquidity_math::add_delta(u128, I128): u128\n\t24: StLoc[5](loc0: u128)\nB5:\n\t25: MoveLoc[5](loc0: u128)\n\t26: StLoc[10](loc5: u128)\n\t27: CopyLoc[2](Arg2: u128)\n\t28: CopyLoc[0](Arg0: &mut Position)\n\t29: ImmBorrowField[7](Position.fee_growth_inside_x_last: u128)\n\t30: ReadRef\n\t31: Call full_math_u128::wrapping_sub(u128, u128): u128\n\t32: CopyLoc[0](Arg0: &mut Position)\n\t33: ImmBorrowField[2](Position.liquidity: u128)\n\t34: ReadRef\n\t35: Call constants::get_q64(): u128\n\t36: Call full_math_u128::mul_div_floor(u128, u128, u128): u128\n\t37: StLoc[8](loc3: u128)\n\t38: CopyLoc[3](Arg3: u128)\n\t39: CopyLoc[0](Arg0: &mut Position)\n\t40: ImmBorrowField[8](Position.fee_growth_inside_y_last: u128)\n\t41: ReadRef\n\t42: Call full_math_u128::wrapping_sub(u128, u128): u128\n\t43: CopyLoc[0](Arg0: &mut Position)\n\t44: ImmBorrowField[2](Position.liquidity: u128)\n\t45: ReadRef\n\t46: Call constants::get_q64(): u128\n\t47: Call full_math_u128::mul_div_floor(u128, u128, u128): u128\n\t48: StLoc[9](loc4: u128)\n\t49: CopyLoc[8](loc3: u128)\n\t50: Call constants::get_max_u64(): u64\n\t51: CastU128\n\t52: Gt\n\t53: BrFalse(57)\nB6:\n\t54: LdTrue\n\t55: StLoc[6](loc1: bool)\n\t56: Branch(62)\nB7:\n\t57: CopyLoc[9](loc4: u128)\n\t58: Call constants::get_max_u64(): u64\n\t59: CastU128\n\t60: Gt\n\t61: StLoc[6](loc1: bool)\nB8:\n\t62: MoveLoc[6](loc1: bool)\n\t63: BrFalse(68)\nB9:\n\t64: MoveLoc[0](Arg0: &mut Position)\n\t65: Pop\n\t66: LdConst[1](u64: 1)\n\t67: Abort\nB10:\n\t68: CopyLoc[0](Arg0: &mut Position)\n\t69: ImmBorrowField[5](Position.coins_owed_x: u64)\n\t70: ReadRef\n\t71: CopyLoc[8](loc3: u128)\n\t72: CastU64\n\t73: Call full_math_u64::add_check(u64, u64): bool\n\t74: Not\n\t75: BrFalse(79)\nB11:\n\t76: LdTrue\n\t77: StLoc[7](loc2: bool)\n\t78: Branch(87)\nB12:\n\t79: CopyLoc[0](Arg0: &mut Position)\n\t80: ImmBorrowField[5](Position.coins_owed_x: u64)\n\t81: ReadRef\n\t82: CopyLoc[8](loc3: u128)\n\t83: CastU64\n\t84: Call full_math_u64::add_check(u64, u64): bool\n\t85: Not\n\t86: StLoc[7](loc2: bool)\nB13:\n\t87: MoveLoc[7](loc2: bool)\n\t88: BrFalse(93)\nB14:\n\t89: MoveLoc[0](Arg0: &mut Position)\n\t90: Pop\n\t91: LdConst[1](u64: 1)\n\t92: Abort\nB15:\n\t93: CopyLoc[0](Arg0: &mut Position)\n\t94: MoveLoc[4](Arg4: vector<u128>)\n\t95: Call update_reward_infos(&mut Position, vector<u128>)\n\t96: MoveLoc[10](loc5: u128)\n\t97: CopyLoc[0](Arg0: &mut Position)\n\t98: MutBorrowField[2](Position.liquidity: u128)\n\t99: WriteRef\n\t100: MoveLoc[2](Arg2: u128)\n\t101: CopyLoc[0](Arg0: &mut Position)\n\t102: MutBorrowField[7](Position.fee_growth_inside_x_last: u128)\n\t103: WriteRef\n\t104: MoveLoc[3](Arg3: u128)\n\t105: CopyLoc[0](Arg0: &mut Position)\n\t106: MutBorrowField[8](Position.fee_growth_inside_y_last: u128)\n\t107: WriteRef\n\t108: CopyLoc[0](Arg0: &mut Position)\n\t109: ImmBorrowField[5](Position.coins_owed_x: u64)\n\t110: ReadRef\n\t111: MoveLoc[8](loc3: u128)\n\t112: CastU64\n\t113: Add\n\t114: CopyLoc[0](Arg0: &mut Position)\n\t115: MutBorrowField[5](Position.coins_owed_x: u64)\n\t116: WriteRef\n\t117: CopyLoc[0](Arg0: &mut Position)\n\t118: ImmBorrowField[6](Position.coins_owed_y: u64)\n\t119: ReadRef\n\t120: MoveLoc[9](loc4: u128)\n\t121: CastU64\n\t122: Add\n\t123: MoveLoc[0](Arg0: &mut Position)\n\t124: MutBorrowField[6](Position.coins_owed_y: u64)\n\t125: WriteRef\n\t126: Ret\n}\n\nupdate_reward_infos(Arg0: &mut Position, Arg1: vector<u128>) {\nL2:\tloc0: bool\nL3:\tloc1: u128\nL4:\tloc2: u64\nL5:\tloc3: u128\nL6:\tloc4: u64\nL7:\tloc5: u128\nL8:\tloc6: &mut PositionRewardInfo\nB0:\n\t0: LdU64(0)\n\t1: ImmBorrowLoc[1](Arg1: vector<u128>)\n\t2: VecLen(5)\n\t3: StLoc[6](loc4: u64)\n\t4: StLoc[4](loc2: u64)\nB1:\n\t5: CopyLoc[4](loc2: u64)\n\t6: CopyLoc[6](loc4: u64)\n\t7: Lt\n\t8: BrFalse(74)\nB2:\n\t9: Branch(10)\nB3:\n\t10: CopyLoc[0](Arg0: &mut Position)\n\t11: ImmBorrowField[2](Position.liquidity: u128)\n\t12: ReadRef\n\t13: StLoc[5](loc3: u128)\n\t14: ImmBorrowLoc[1](Arg1: vector<u128>)\n\t15: CopyLoc[4](loc2: u64)\n\t16: VecImmBorrow(5)\n\t17: ReadRef\n\t18: StLoc[7](loc5: u128)\n\t19: CopyLoc[0](Arg0: &mut Position)\n\t20: CopyLoc[4](loc2: u64)\n\t21: Call try_borrow_mut_reward_info(&mut Position, u64): &mut PositionRewardInfo\n\t22: StLoc[8](loc6: &mut PositionRewardInfo)\n\t23: CopyLoc[7](loc5: u128)\n\t24: CopyLoc[8](loc6: &mut PositionRewardInfo)\n\t25: ImmBorrowField[10](PositionRewardInfo.reward_growth_inside_last: u128)\n\t26: ReadRef\n\t27: Call full_math_u128::wrapping_sub(u128, u128): u128\n\t28: MoveLoc[5](loc3: u128)\n\t29: Call constants::get_q64(): u128\n\t30: Call full_math_u128::mul_div_floor(u128, u128, u128): u128\n\t31: StLoc[3](loc1: u128)\n\t32: CopyLoc[3](loc1: u128)\n\t33: Call constants::get_max_u64(): u64\n\t34: CastU128\n\t35: Gt\n\t36: BrFalse(40)\nB4:\n\t37: LdTrue\n\t38: StLoc[2](loc0: bool)\n\t39: Branch(48)\nB5:\n\t40: CopyLoc[8](loc6: &mut PositionRewardInfo)\n\t41: ImmBorrowField[11](PositionRewardInfo.coins_owed_reward: u64)\n\t42: ReadRef\n\t43: CopyLoc[3](loc1: u128)\n\t44: CastU64\n\t45: Call full_math_u64::add_check(u64, u64): bool\n\t46: Not\n\t47: StLoc[2](loc0: bool)\nB6:\n\t48: MoveLoc[2](loc0: bool)\n\t49: BrFalse(56)\nB7:\n\t50: MoveLoc[0](Arg0: &mut Position)\n\t51: Pop\n\t52: MoveLoc[8](loc6: &mut PositionRewardInfo)\n\t53: Pop\n\t54: LdConst[1](u64: 1)\n\t55: Abort\nB8:\n\t56: MoveLoc[7](loc5: u128)\n\t57: CopyLoc[8](loc6: &mut PositionRewardInfo)\n\t58: MutBorrowField[10](PositionRewardInfo.reward_growth_inside_last: u128)\n\t59: WriteRef\n\t60: CopyLoc[8](loc6: &mut PositionRewardInfo)\n\t61: ImmBorrowField[11](PositionRewardInfo.coins_owed_reward: u64)\n\t62: ReadRef\n\t63: MoveLoc[3](loc1: u128)\n\t64: CastU64\n\t65: Add\n\t66: MoveLoc[8](loc6: &mut PositionRewardInfo)\n\t67: MutBorrowField[11](PositionRewardInfo.coins_owed_reward: u64)\n\t68: WriteRef\n\t69: MoveLoc[4](loc2: u64)\n\t70: LdU64(1)\n\t71: Add\n\t72: StLoc[4](loc2: u64)\n\t73: Branch(5)\nB9:\n\t74: MoveLoc[0](Arg0: &mut Position)\n\t75: Pop\n\t76: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => vector<u8>: \"name\" // interpreted as UTF8 string\n\t3 => vector<u8>: \"FlowX CLMM Liquidity Positions\" // interpreted as UTF8 string\n\t4 => vector<u8>: \"description\" // interpreted as UTF8 string\n\t5 => vector<u8>: \"This NFT represents a liquidity position in FlowX CLMM. The owner of this NFT can modify or redeem the position.\" // interpreted as UTF8 string\n\t6 => vector<u8>: \"image_url\" // interpreted as UTF8 string\n\t7 => vector<u8>: \"https://ipfs.io/ipfs/QmV3S91uDAPJAcqMNed3R6JyAXKnbidgNdHGhnwU5LyUDZ\" // interpreted as UTF8 string\n]\n}\n",
      "position_manager": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.position_manager {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i128;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i32;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::liquidity_math;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::pool;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::pool_manager;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::position;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::tick;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::tick_math;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::utils;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::versioned;\nuse 0000000000000000000000000000000000000000000000000000000000000001::type_name;\nuse 0000000000000000000000000000000000000000000000000000000000000002::balance;\nuse 0000000000000000000000000000000000000000000000000000000000000002::clock;\nuse 0000000000000000000000000000000000000000000000000000000000000002::coin;\nuse 0000000000000000000000000000000000000000000000000000000000000002::event;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct PositionRegistry has store, key {\n\tid: UID,\n\tnum_positions: u64\n}\n\nstruct Open has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tposition_id: ID,\n\ttick_lower_index: I32,\n\ttick_upper_index: I32\n}\n\nstruct Close has copy, drop, store {\n\tsender: address,\n\tposition_id: ID\n}\n\nstruct IncreaseLiquidity has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tposition_id: ID,\n\tliquidity: u128,\n\tamount_x: u64,\n\tamount_y: u64\n}\n\nstruct DecreaseLiquidity has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tposition_id: ID,\n\tliquidity: u128,\n\tamount_x: u64,\n\tamount_y: u64\n}\n\nstruct Collect has copy, drop, store {\n\tsender: address,\n\tpool_id: ID,\n\tposition_id: ID,\n\tamount_x: u64,\n\tamount_y: u64\n}\n\ninit(Arg0: &mut TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: LdU64(0)\n\t3: Pack[0](PositionRegistry)\n\t4: Call transfer::share_object<PositionRegistry>(PositionRegistry)\n\t5: Ret\n}\n\npublic open_position<Ty0, Ty1>(Arg0: &mut PositionRegistry, Arg1: &PoolRegistry, Arg2: u64, Arg3: I32, Arg4: I32, Arg5: &Versioned, Arg6: &mut TxContext): Position {\nL7:\tloc0: &Pool<Ty0, Ty1>\nL8:\tloc1: Position\nB0:\n\t0: MoveLoc[5](Arg5: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: Call utils::check_order<Ty0, Ty1>()\n\t3: MoveLoc[1](Arg1: &PoolRegistry)\n\t4: MoveLoc[2](Arg2: u64)\n\t5: Call pool_manager::borrow_pool<Ty0, Ty1>(&PoolRegistry, u64): &Pool<Ty0, Ty1>\n\t6: StLoc[7](loc0: &Pool<Ty0, Ty1>)\n\t7: CopyLoc[3](Arg3: I32)\n\t8: CopyLoc[4](Arg4: I32)\n\t9: CopyLoc[7](loc0: &Pool<Ty0, Ty1>)\n\t10: Call pool::tick_spacing<Ty0, Ty1>(&Pool<Ty0, Ty1>): u32\n\t11: Call tick::check_ticks(I32, I32, u32)\n\t12: CopyLoc[7](loc0: &Pool<Ty0, Ty1>)\n\t13: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t14: CopyLoc[7](loc0: &Pool<Ty0, Ty1>)\n\t15: Call pool::swap_fee_rate<Ty0, Ty1>(&Pool<Ty0, Ty1>): u64\n\t16: CopyLoc[7](loc0: &Pool<Ty0, Ty1>)\n\t17: Call pool::coin_type_x<Ty0, Ty1>(&Pool<Ty0, Ty1>): TypeName\n\t18: CopyLoc[7](loc0: &Pool<Ty0, Ty1>)\n\t19: Call pool::coin_type_y<Ty0, Ty1>(&Pool<Ty0, Ty1>): TypeName\n\t20: CopyLoc[3](Arg3: I32)\n\t21: CopyLoc[4](Arg4: I32)\n\t22: CopyLoc[6](Arg6: &mut TxContext)\n\t23: Call position::open(ID, u64, TypeName, TypeName, I32, I32, &mut TxContext): Position\n\t24: StLoc[8](loc1: Position)\n\t25: CopyLoc[0](Arg0: &mut PositionRegistry)\n\t26: ImmBorrowField[0](PositionRegistry.num_positions: u64)\n\t27: ReadRef\n\t28: LdU64(1)\n\t29: Add\n\t30: MoveLoc[0](Arg0: &mut PositionRegistry)\n\t31: MutBorrowField[0](PositionRegistry.num_positions: u64)\n\t32: WriteRef\n\t33: MoveLoc[6](Arg6: &mut TxContext)\n\t34: FreezeRef\n\t35: Call tx_context::sender(&TxContext): address\n\t36: MoveLoc[7](loc0: &Pool<Ty0, Ty1>)\n\t37: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t38: ImmBorrowLoc[8](loc1: Position)\n\t39: Call object::id<Position>(&Position): ID\n\t40: MoveLoc[3](Arg3: I32)\n\t41: MoveLoc[4](Arg4: I32)\n\t42: Pack[1](Open)\n\t43: Call event::emit<Open>(Open)\n\t44: MoveLoc[8](loc1: Position)\n\t45: Ret\n}\n\npublic close_position(Arg0: &mut PositionRegistry, Arg1: Position, Arg2: &Versioned, Arg3: &TxContext) {\nB0:\n\t0: MoveLoc[2](Arg2: &Versioned)\n\t1: Call versioned::check_version(&Versioned)\n\t2: ImmBorrowLoc[1](Arg1: Position)\n\t3: Call position::is_empty(&Position): bool\n\t4: Not\n\t5: BrFalse(12)\nB1:\n\t6: MoveLoc[0](Arg0: &mut PositionRegistry)\n\t7: Pop\n\t8: MoveLoc[3](Arg3: &TxContext)\n\t9: Pop\n\t10: LdConst[0](u64: 0)\n\t11: Abort\nB2:\n\t12: MoveLoc[3](Arg3: &TxContext)\n\t13: Call tx_context::sender(&TxContext): address\n\t14: ImmBorrowLoc[1](Arg1: Position)\n\t15: Call object::id<Position>(&Position): ID\n\t16: Pack[2](Close)\n\t17: Call event::emit<Close>(Close)\n\t18: MoveLoc[1](Arg1: Position)\n\t19: Call position::close(Position)\n\t20: CopyLoc[0](Arg0: &mut PositionRegistry)\n\t21: ImmBorrowField[0](PositionRegistry.num_positions: u64)\n\t22: ReadRef\n\t23: LdU64(1)\n\t24: Sub\n\t25: MoveLoc[0](Arg0: &mut PositionRegistry)\n\t26: MutBorrowField[0](PositionRegistry.num_positions: u64)\n\t27: WriteRef\n\t28: Ret\n}\n\npublic increase_liquidity<Ty0, Ty1>(Arg0: &mut PoolRegistry, Arg1: &mut Position, Arg2: Coin<Ty0>, Arg3: Coin<Ty1>, Arg4: u64, Arg5: u64, Arg6: u64, Arg7: &Versioned, Arg8: &Clock, Arg9: &mut TxContext) {\nL10:\tloc0: bool\nL11:\tloc1: u64\nL12:\tloc2: u64\nL13:\tloc3: u64\nL14:\tloc4: u64\nL15:\tloc5: u128\nL16:\tloc6: &mut Pool<Ty0, Ty1>\nL17:\tloc7: u128\nL18:\tloc8: u128\nL19:\tloc9: u128\nB0:\n\t0: Call utils::check_order<Ty0, Ty1>()\n\t1: CopyLoc[8](Arg8: &Clock)\n\t2: MoveLoc[6](Arg6: u64)\n\t3: Call utils::check_deadline(&Clock, u64)\n\t4: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t5: CopyLoc[1](Arg1: &mut Position)\n\t6: FreezeRef\n\t7: Call position::fee_rate(&Position): u64\n\t8: Call pool_manager::borrow_mut_pool<Ty0, Ty1>(&mut PoolRegistry, u64): &mut Pool<Ty0, Ty1>\n\t9: StLoc[16](loc6: &mut Pool<Ty0, Ty1>)\n\t10: CopyLoc[16](loc6: &mut Pool<Ty0, Ty1>)\n\t11: FreezeRef\n\t12: Call pool::sqrt_price_current<Ty0, Ty1>(&Pool<Ty0, Ty1>): u128\n\t13: CopyLoc[1](Arg1: &mut Position)\n\t14: FreezeRef\n\t15: Call position::tick_lower_index(&Position): I32\n\t16: Call tick_math::get_sqrt_price_at_tick(I32): u128\n\t17: CopyLoc[1](Arg1: &mut Position)\n\t18: FreezeRef\n\t19: Call position::tick_upper_index(&Position): I32\n\t20: Call tick_math::get_sqrt_price_at_tick(I32): u128\n\t21: StLoc[18](loc8: u128)\n\t22: StLoc[17](loc7: u128)\n\t23: StLoc[19](loc9: u128)\n\t24: CopyLoc[19](loc9: u128)\n\t25: CopyLoc[17](loc7: u128)\n\t26: CopyLoc[18](loc8: u128)\n\t27: ImmBorrowLoc[2](Arg2: Coin<Ty0>)\n\t28: Call coin::value<Ty0>(&Coin<Ty0>): u64\n\t29: ImmBorrowLoc[3](Arg3: Coin<Ty1>)\n\t30: Call coin::value<Ty1>(&Coin<Ty1>): u64\n\t31: Call liquidity_math::get_liquidity_for_amounts(u128, u128, u128, u64, u64): u128\n\t32: StLoc[15](loc5: u128)\n\t33: MoveLoc[19](loc9: u128)\n\t34: MoveLoc[17](loc7: u128)\n\t35: MoveLoc[18](loc8: u128)\n\t36: CopyLoc[15](loc5: u128)\n\t37: LdTrue\n\t38: Call liquidity_math::get_amounts_for_liquidity(u128, u128, u128, u128, bool): u64 * u64\n\t39: StLoc[14](loc4: u64)\n\t40: StLoc[12](loc2: u64)\n\t41: CopyLoc[12](loc2: u64)\n\t42: MoveLoc[4](Arg4: u64)\n\t43: Lt\n\t44: BrFalse(48)\nB1:\n\t45: LdTrue\n\t46: StLoc[10](loc0: bool)\n\t47: Branch(52)\nB2:\n\t48: CopyLoc[14](loc4: u64)\n\t49: MoveLoc[5](Arg5: u64)\n\t50: Lt\n\t51: StLoc[10](loc0: bool)\nB3:\n\t52: MoveLoc[10](loc0: bool)\n\t53: BrFalse(66)\nB4:\n\t54: MoveLoc[7](Arg7: &Versioned)\n\t55: Pop\n\t56: MoveLoc[1](Arg1: &mut Position)\n\t57: Pop\n\t58: MoveLoc[16](loc6: &mut Pool<Ty0, Ty1>)\n\t59: Pop\n\t60: MoveLoc[9](Arg9: &mut TxContext)\n\t61: Pop\n\t62: MoveLoc[8](Arg8: &Clock)\n\t63: Pop\n\t64: LdConst[1](u64: 1)\n\t65: Abort\nB5:\n\t66: CopyLoc[16](loc6: &mut Pool<Ty0, Ty1>)\n\t67: CopyLoc[1](Arg1: &mut Position)\n\t68: CopyLoc[15](loc5: u128)\n\t69: Call i128::from(u128): I128\n\t70: MutBorrowLoc[2](Arg2: Coin<Ty0>)\n\t71: MoveLoc[12](loc2: u64)\n\t72: CopyLoc[9](Arg9: &mut TxContext)\n\t73: Call coin::split<Ty0>(&mut Coin<Ty0>, u64, &mut TxContext): Coin<Ty0>\n\t74: Call coin::into_balance<Ty0>(Coin<Ty0>): Balance<Ty0>\n\t75: MutBorrowLoc[3](Arg3: Coin<Ty1>)\n\t76: MoveLoc[14](loc4: u64)\n\t77: CopyLoc[9](Arg9: &mut TxContext)\n\t78: Call coin::split<Ty1>(&mut Coin<Ty1>, u64, &mut TxContext): Coin<Ty1>\n\t79: Call coin::into_balance<Ty1>(Coin<Ty1>): Balance<Ty1>\n\t80: MoveLoc[7](Arg7: &Versioned)\n\t81: MoveLoc[8](Arg8: &Clock)\n\t82: CopyLoc[9](Arg9: &mut TxContext)\n\t83: FreezeRef\n\t84: Call pool::modify_liquidity<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, &mut Position, I128, Balance<Ty0>, Balance<Ty1>, &Versioned, &Clock, &TxContext): u64 * u64\n\t85: StLoc[13](loc3: u64)\n\t86: StLoc[11](loc1: u64)\n\t87: MoveLoc[2](Arg2: Coin<Ty0>)\n\t88: CopyLoc[9](Arg9: &mut TxContext)\n\t89: FreezeRef\n\t90: Call tx_context::sender(&TxContext): address\n\t91: Call utils::refund<Ty0>(Coin<Ty0>, address)\n\t92: MoveLoc[3](Arg3: Coin<Ty1>)\n\t93: CopyLoc[9](Arg9: &mut TxContext)\n\t94: FreezeRef\n\t95: Call tx_context::sender(&TxContext): address\n\t96: Call utils::refund<Ty1>(Coin<Ty1>, address)\n\t97: MoveLoc[9](Arg9: &mut TxContext)\n\t98: FreezeRef\n\t99: Call tx_context::sender(&TxContext): address\n\t100: MoveLoc[16](loc6: &mut Pool<Ty0, Ty1>)\n\t101: FreezeRef\n\t102: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t103: MoveLoc[1](Arg1: &mut Position)\n\t104: FreezeRef\n\t105: Call object::id<Position>(&Position): ID\n\t106: MoveLoc[15](loc5: u128)\n\t107: MoveLoc[11](loc1: u64)\n\t108: MoveLoc[13](loc3: u64)\n\t109: Pack[3](IncreaseLiquidity)\n\t110: Call event::emit<IncreaseLiquidity>(IncreaseLiquidity)\n\t111: Ret\n}\n\npublic decrease_liquidity<Ty0, Ty1>(Arg0: &mut PoolRegistry, Arg1: &mut Position, Arg2: u128, Arg3: u64, Arg4: u64, Arg5: u64, Arg6: &Versioned, Arg7: &Clock, Arg8: &TxContext) {\nL9:\tloc0: bool\nL10:\tloc1: u64\nL11:\tloc2: u64\nL12:\tloc3: &mut Pool<Ty0, Ty1>\nB0:\n\t0: Call utils::check_order<Ty0, Ty1>()\n\t1: CopyLoc[7](Arg7: &Clock)\n\t2: MoveLoc[5](Arg5: u64)\n\t3: Call utils::check_deadline(&Clock, u64)\n\t4: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t5: CopyLoc[1](Arg1: &mut Position)\n\t6: FreezeRef\n\t7: Call position::fee_rate(&Position): u64\n\t8: Call pool_manager::borrow_mut_pool<Ty0, Ty1>(&mut PoolRegistry, u64): &mut Pool<Ty0, Ty1>\n\t9: StLoc[12](loc3: &mut Pool<Ty0, Ty1>)\n\t10: CopyLoc[12](loc3: &mut Pool<Ty0, Ty1>)\n\t11: CopyLoc[1](Arg1: &mut Position)\n\t12: CopyLoc[2](Arg2: u128)\n\t13: Call i128::neg_from(u128): I128\n\t14: Call balance::zero<Ty0>(): Balance<Ty0>\n\t15: Call balance::zero<Ty1>(): Balance<Ty1>\n\t16: MoveLoc[6](Arg6: &Versioned)\n\t17: MoveLoc[7](Arg7: &Clock)\n\t18: CopyLoc[8](Arg8: &TxContext)\n\t19: Call pool::modify_liquidity<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, &mut Position, I128, Balance<Ty0>, Balance<Ty1>, &Versioned, &Clock, &TxContext): u64 * u64\n\t20: StLoc[11](loc2: u64)\n\t21: StLoc[10](loc1: u64)\n\t22: CopyLoc[10](loc1: u64)\n\t23: MoveLoc[3](Arg3: u64)\n\t24: Lt\n\t25: BrFalse(29)\nB1:\n\t26: LdTrue\n\t27: StLoc[9](loc0: bool)\n\t28: Branch(33)\nB2:\n\t29: CopyLoc[11](loc2: u64)\n\t30: MoveLoc[4](Arg4: u64)\n\t31: Lt\n\t32: StLoc[9](loc0: bool)\nB3:\n\t33: MoveLoc[9](loc0: bool)\n\t34: BrFalse(43)\nB4:\n\t35: MoveLoc[1](Arg1: &mut Position)\n\t36: Pop\n\t37: MoveLoc[12](loc3: &mut Pool<Ty0, Ty1>)\n\t38: Pop\n\t39: MoveLoc[8](Arg8: &TxContext)\n\t40: Pop\n\t41: LdConst[1](u64: 1)\n\t42: Abort\nB5:\n\t43: MoveLoc[8](Arg8: &TxContext)\n\t44: Call tx_context::sender(&TxContext): address\n\t45: MoveLoc[12](loc3: &mut Pool<Ty0, Ty1>)\n\t46: FreezeRef\n\t47: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t48: MoveLoc[1](Arg1: &mut Position)\n\t49: FreezeRef\n\t50: Call object::id<Position>(&Position): ID\n\t51: MoveLoc[2](Arg2: u128)\n\t52: MoveLoc[10](loc1: u64)\n\t53: MoveLoc[11](loc2: u64)\n\t54: Pack[4](DecreaseLiquidity)\n\t55: Call event::emit<DecreaseLiquidity>(DecreaseLiquidity)\n\t56: Ret\n}\n\npublic collect<Ty0, Ty1>(Arg0: &mut PoolRegistry, Arg1: &mut Position, Arg2: u64, Arg3: u64, Arg4: &Versioned, Arg5: &Clock, Arg6: &mut TxContext): Coin<Ty0> * Coin<Ty1> {\nL7:\tloc0: bool\nL8:\tloc1: Balance<Ty0>\nL9:\tloc2: Balance<Ty1>\nL10:\tloc3: &mut Pool<Ty0, Ty1>\nB0:\n\t0: Call utils::check_order<Ty0, Ty1>()\n\t1: CopyLoc[2](Arg2: u64)\n\t2: LdU64(0)\n\t3: Eq\n\t4: BrFalse(10)\nB1:\n\t5: CopyLoc[3](Arg3: u64)\n\t6: LdU64(0)\n\t7: Eq\n\t8: StLoc[7](loc0: bool)\n\t9: Branch(12)\nB2:\n\t10: LdFalse\n\t11: StLoc[7](loc0: bool)\nB3:\n\t12: MoveLoc[7](loc0: bool)\n\t13: BrFalse(26)\nB4:\n\t14: MoveLoc[4](Arg4: &Versioned)\n\t15: Pop\n\t16: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t17: Pop\n\t18: MoveLoc[1](Arg1: &mut Position)\n\t19: Pop\n\t20: MoveLoc[6](Arg6: &mut TxContext)\n\t21: Pop\n\t22: MoveLoc[5](Arg5: &Clock)\n\t23: Pop\n\t24: LdConst[2](u64: 2)\n\t25: Abort\nB5:\n\t26: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t27: CopyLoc[1](Arg1: &mut Position)\n\t28: FreezeRef\n\t29: Call position::fee_rate(&Position): u64\n\t30: Call pool_manager::borrow_mut_pool<Ty0, Ty1>(&mut PoolRegistry, u64): &mut Pool<Ty0, Ty1>\n\t31: StLoc[10](loc3: &mut Pool<Ty0, Ty1>)\n\t32: CopyLoc[1](Arg1: &mut Position)\n\t33: FreezeRef\n\t34: Call position::liquidity(&Position): u128\n\t35: LdU128(0)\n\t36: Gt\n\t37: BrFalse(51)\nB6:\n\t38: CopyLoc[10](loc3: &mut Pool<Ty0, Ty1>)\n\t39: CopyLoc[1](Arg1: &mut Position)\n\t40: Call i128::zero(): I128\n\t41: Call balance::zero<Ty0>(): Balance<Ty0>\n\t42: Call balance::zero<Ty1>(): Balance<Ty1>\n\t43: CopyLoc[4](Arg4: &Versioned)\n\t44: MoveLoc[5](Arg5: &Clock)\n\t45: CopyLoc[6](Arg6: &mut TxContext)\n\t46: FreezeRef\n\t47: Call pool::modify_liquidity<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, &mut Position, I128, Balance<Ty0>, Balance<Ty1>, &Versioned, &Clock, &TxContext): u64 * u64\n\t48: Pop\n\t49: Pop\n\t50: Branch(53)\nB7:\n\t51: MoveLoc[5](Arg5: &Clock)\n\t52: Pop\nB8:\n\t53: CopyLoc[10](loc3: &mut Pool<Ty0, Ty1>)\n\t54: CopyLoc[1](Arg1: &mut Position)\n\t55: MoveLoc[2](Arg2: u64)\n\t56: MoveLoc[3](Arg3: u64)\n\t57: MoveLoc[4](Arg4: &Versioned)\n\t58: CopyLoc[6](Arg6: &mut TxContext)\n\t59: FreezeRef\n\t60: Call pool::collect<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, &mut Position, u64, u64, &Versioned, &TxContext): Balance<Ty0> * Balance<Ty1>\n\t61: StLoc[9](loc2: Balance<Ty1>)\n\t62: StLoc[8](loc1: Balance<Ty0>)\n\t63: CopyLoc[6](Arg6: &mut TxContext)\n\t64: FreezeRef\n\t65: Call tx_context::sender(&TxContext): address\n\t66: MoveLoc[10](loc3: &mut Pool<Ty0, Ty1>)\n\t67: FreezeRef\n\t68: Call object::id<Pool<Ty0, Ty1>>(&Pool<Ty0, Ty1>): ID\n\t69: MoveLoc[1](Arg1: &mut Position)\n\t70: FreezeRef\n\t71: Call object::id<Position>(&Position): ID\n\t72: ImmBorrowLoc[8](loc1: Balance<Ty0>)\n\t73: Call balance::value<Ty0>(&Balance<Ty0>): u64\n\t74: ImmBorrowLoc[9](loc2: Balance<Ty1>)\n\t75: Call balance::value<Ty1>(&Balance<Ty1>): u64\n\t76: Pack[5](Collect)\n\t77: Call event::emit<Collect>(Collect)\n\t78: MoveLoc[8](loc1: Balance<Ty0>)\n\t79: CopyLoc[6](Arg6: &mut TxContext)\n\t80: Call coin::from_balance<Ty0>(Balance<Ty0>, &mut TxContext): Coin<Ty0>\n\t81: MoveLoc[9](loc2: Balance<Ty1>)\n\t82: MoveLoc[6](Arg6: &mut TxContext)\n\t83: Call coin::from_balance<Ty1>(Balance<Ty1>, &mut TxContext): Coin<Ty1>\n\t84: Ret\n}\n\npublic collect_pool_reward<Ty0, Ty1, Ty2>(Arg0: &mut PoolRegistry, Arg1: &mut Position, Arg2: u64, Arg3: &Versioned, Arg4: &Clock, Arg5: &mut TxContext): Coin<Ty2> {\nL6:\tloc0: &mut Pool<Ty0, Ty1>\nB0:\n\t0: Call utils::check_order<Ty0, Ty1>()\n\t1: CopyLoc[2](Arg2: u64)\n\t2: LdU64(0)\n\t3: Eq\n\t4: BrFalse(17)\nB1:\n\t5: MoveLoc[3](Arg3: &Versioned)\n\t6: Pop\n\t7: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t8: Pop\n\t9: MoveLoc[1](Arg1: &mut Position)\n\t10: Pop\n\t11: MoveLoc[5](Arg5: &mut TxContext)\n\t12: Pop\n\t13: MoveLoc[4](Arg4: &Clock)\n\t14: Pop\n\t15: LdConst[2](u64: 2)\n\t16: Abort\nB2:\n\t17: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t18: CopyLoc[1](Arg1: &mut Position)\n\t19: FreezeRef\n\t20: Call position::fee_rate(&Position): u64\n\t21: Call pool_manager::borrow_mut_pool<Ty0, Ty1>(&mut PoolRegistry, u64): &mut Pool<Ty0, Ty1>\n\t22: StLoc[6](loc0: &mut Pool<Ty0, Ty1>)\n\t23: CopyLoc[1](Arg1: &mut Position)\n\t24: FreezeRef\n\t25: Call position::liquidity(&Position): u128\n\t26: LdU128(0)\n\t27: Gt\n\t28: BrFalse(42)\nB3:\n\t29: CopyLoc[6](loc0: &mut Pool<Ty0, Ty1>)\n\t30: CopyLoc[1](Arg1: &mut Position)\n\t31: Call i128::zero(): I128\n\t32: Call balance::zero<Ty0>(): Balance<Ty0>\n\t33: Call balance::zero<Ty1>(): Balance<Ty1>\n\t34: CopyLoc[3](Arg3: &Versioned)\n\t35: MoveLoc[4](Arg4: &Clock)\n\t36: CopyLoc[5](Arg5: &mut TxContext)\n\t37: FreezeRef\n\t38: Call pool::modify_liquidity<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, &mut Position, I128, Balance<Ty0>, Balance<Ty1>, &Versioned, &Clock, &TxContext): u64 * u64\n\t39: Pop\n\t40: Pop\n\t41: Branch(44)\nB4:\n\t42: MoveLoc[4](Arg4: &Clock)\n\t43: Pop\nB5:\n\t44: MoveLoc[6](loc0: &mut Pool<Ty0, Ty1>)\n\t45: MoveLoc[1](Arg1: &mut Position)\n\t46: MoveLoc[2](Arg2: u64)\n\t47: MoveLoc[3](Arg3: &Versioned)\n\t48: CopyLoc[5](Arg5: &mut TxContext)\n\t49: FreezeRef\n\t50: Call pool::collect_pool_reward<Ty0, Ty1, Ty2>(&mut Pool<Ty0, Ty1>, &mut Position, u64, &Versioned, &TxContext): Balance<Ty2>\n\t51: MoveLoc[5](Arg5: &mut TxContext)\n\t52: Call coin::from_balance<Ty2>(Balance<Ty2>, &mut TxContext): Coin<Ty2>\n\t53: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n]\n}\n",
      "sqrt_price_math": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.sqrt_price_math {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::constants;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::full_math_u128;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::math_u256;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::tick_math;\n\npublic get_next_sqrt_price_from_amount_x_rouding_up(Arg0: u128, Arg1: u128, Arg2: u64, Arg3: bool): u128 {\nL4:\tloc0: u128\nL5:\tloc1: bool\nL6:\tloc2: u256\nL7:\tloc3: u128\nL8:\tloc4: u256\nL9:\tloc5: bool\nL10:\tloc6: u256\nB0:\n\t0: CopyLoc[2](Arg2: u64)\n\t1: LdU64(0)\n\t2: Eq\n\t3: BrFalse(6)\nB1:\n\t4: MoveLoc[0](Arg0: u128)\n\t5: Ret\nB2:\n\t6: CopyLoc[0](Arg0: u128)\n\t7: CopyLoc[1](Arg1: u128)\n\t8: Call full_math_u128::full_mul(u128, u128): u256\n\t9: Call math_u256::checked_shlw(u256): u256 * bool\n\t10: StLoc[9](loc5: bool)\n\t11: StLoc[8](loc4: u256)\n\t12: MoveLoc[9](loc5: bool)\n\t13: BrFalse(16)\nB3:\n\t14: LdConst[0](u64: 0)\n\t15: Abort\nB4:\n\t16: MoveLoc[1](Arg1: u128)\n\t17: CastU256\n\t18: LdU8(64)\n\t19: Shl\n\t20: StLoc[6](loc2: u256)\n\t21: MoveLoc[0](Arg0: u128)\n\t22: MoveLoc[2](Arg2: u64)\n\t23: CastU128\n\t24: Call full_math_u128::full_mul(u128, u128): u256\n\t25: StLoc[10](loc6: u256)\n\t26: MoveLoc[3](Arg3: bool)\n\t27: BrFalse(37)\nB5:\n\t28: MoveLoc[8](loc4: u256)\n\t29: MoveLoc[6](loc2: u256)\n\t30: MoveLoc[10](loc6: u256)\n\t31: Add\n\t32: LdTrue\n\t33: Call math_u256::div_round(u256, u256, bool): u256\n\t34: CastU128\n\t35: StLoc[4](loc0: u128)\n\t36: Branch(51)\nB6:\n\t37: CopyLoc[6](loc2: u256)\n\t38: CopyLoc[10](loc6: u256)\n\t39: Le\n\t40: BrFalse(43)\nB7:\n\t41: LdConst[2](u64: 2)\n\t42: Abort\nB8:\n\t43: MoveLoc[8](loc4: u256)\n\t44: MoveLoc[6](loc2: u256)\n\t45: MoveLoc[10](loc6: u256)\n\t46: Sub\n\t47: LdTrue\n\t48: Call math_u256::div_round(u256, u256, bool): u256\n\t49: CastU128\n\t50: StLoc[4](loc0: u128)\nB9:\n\t51: MoveLoc[4](loc0: u128)\n\t52: StLoc[7](loc3: u128)\n\t53: CopyLoc[7](loc3: u128)\n\t54: Call tick_math::max_sqrt_price(): u128\n\t55: Gt\n\t56: BrFalse(60)\nB10:\n\t57: LdTrue\n\t58: StLoc[5](loc1: bool)\n\t59: Branch(64)\nB11:\n\t60: CopyLoc[7](loc3: u128)\n\t61: Call tick_math::min_sqrt_price(): u128\n\t62: Lt\n\t63: StLoc[5](loc1: bool)\nB12:\n\t64: MoveLoc[5](loc1: bool)\n\t65: BrFalse(68)\nB13:\n\t66: LdConst[2](u64: 2)\n\t67: Abort\nB14:\n\t68: MoveLoc[7](loc3: u128)\n\t69: Ret\n}\n\npublic get_next_sqrt_price_from_amount_y_rouding_down(Arg0: u128, Arg1: u128, Arg2: u64, Arg3: bool): u128 {\nL4:\tloc0: u128\nL5:\tloc1: bool\nL6:\tloc2: u128\nL7:\tloc3: u128\nB0:\n\t0: MoveLoc[2](Arg2: u64)\n\t1: CastU256\n\t2: LdU8(64)\n\t3: Shl\n\t4: MoveLoc[1](Arg1: u128)\n\t5: CastU256\n\t6: CopyLoc[3](Arg3: bool)\n\t7: Not\n\t8: Call math_u256::div_round(u256, u256, bool): u256\n\t9: CastU128\n\t10: StLoc[7](loc3: u128)\n\t11: MoveLoc[3](Arg3: bool)\n\t12: BrFalse(18)\nB1:\n\t13: MoveLoc[0](Arg0: u128)\n\t14: MoveLoc[7](loc3: u128)\n\t15: Add\n\t16: StLoc[4](loc0: u128)\n\t17: Branch(28)\nB2:\n\t18: CopyLoc[0](Arg0: u128)\n\t19: CopyLoc[7](loc3: u128)\n\t20: Le\n\t21: BrFalse(24)\nB3:\n\t22: LdConst[3](u64: 3)\n\t23: Abort\nB4:\n\t24: MoveLoc[0](Arg0: u128)\n\t25: MoveLoc[7](loc3: u128)\n\t26: Sub\n\t27: StLoc[4](loc0: u128)\nB5:\n\t28: MoveLoc[4](loc0: u128)\n\t29: StLoc[6](loc2: u128)\n\t30: CopyLoc[6](loc2: u128)\n\t31: Call tick_math::max_sqrt_price(): u128\n\t32: Gt\n\t33: BrFalse(37)\nB6:\n\t34: LdTrue\n\t35: StLoc[5](loc1: bool)\n\t36: Branch(41)\nB7:\n\t37: CopyLoc[6](loc2: u128)\n\t38: Call tick_math::min_sqrt_price(): u128\n\t39: Lt\n\t40: StLoc[5](loc1: bool)\nB8:\n\t41: MoveLoc[5](loc1: bool)\n\t42: BrFalse(45)\nB9:\n\t43: LdConst[2](u64: 2)\n\t44: Abort\nB10:\n\t45: MoveLoc[6](loc2: u128)\n\t46: Ret\n}\n\npublic get_next_sqrt_price_from_input(Arg0: u128, Arg1: u128, Arg2: u64, Arg3: bool): u128 {\nL4:\tloc0: bool\nL5:\tloc1: u128\nB0:\n\t0: CopyLoc[0](Arg0: u128)\n\t1: LdU128(0)\n\t2: Gt\n\t3: BrFalse(9)\nB1:\n\t4: CopyLoc[1](Arg1: u128)\n\t5: LdU128(0)\n\t6: Gt\n\t7: StLoc[4](loc0: bool)\n\t8: Branch(11)\nB2:\n\t9: LdFalse\n\t10: StLoc[4](loc0: bool)\nB3:\n\t11: MoveLoc[4](loc0: bool)\n\t12: BrFalse(14)\nB4:\n\t13: Branch(16)\nB5:\n\t14: LdConst[4](u64: 4)\n\t15: Abort\nB6:\n\t16: MoveLoc[3](Arg3: bool)\n\t17: BrFalse(25)\nB7:\n\t18: MoveLoc[0](Arg0: u128)\n\t19: MoveLoc[1](Arg1: u128)\n\t20: MoveLoc[2](Arg2: u64)\n\t21: LdTrue\n\t22: Call get_next_sqrt_price_from_amount_x_rouding_up(u128, u128, u64, bool): u128\n\t23: StLoc[5](loc1: u128)\n\t24: Branch(31)\nB8:\n\t25: MoveLoc[0](Arg0: u128)\n\t26: MoveLoc[1](Arg1: u128)\n\t27: MoveLoc[2](Arg2: u64)\n\t28: LdTrue\n\t29: Call get_next_sqrt_price_from_amount_y_rouding_down(u128, u128, u64, bool): u128\n\t30: StLoc[5](loc1: u128)\nB9:\n\t31: MoveLoc[5](loc1: u128)\n\t32: Ret\n}\n\npublic get_next_sqrt_price_from_output(Arg0: u128, Arg1: u128, Arg2: u64, Arg3: bool): u128 {\nL4:\tloc0: bool\nL5:\tloc1: u128\nB0:\n\t0: CopyLoc[0](Arg0: u128)\n\t1: LdU128(0)\n\t2: Gt\n\t3: BrFalse(9)\nB1:\n\t4: CopyLoc[1](Arg1: u128)\n\t5: LdU128(0)\n\t6: Gt\n\t7: StLoc[4](loc0: bool)\n\t8: Branch(11)\nB2:\n\t9: LdFalse\n\t10: StLoc[4](loc0: bool)\nB3:\n\t11: MoveLoc[4](loc0: bool)\n\t12: BrFalse(14)\nB4:\n\t13: Branch(16)\nB5:\n\t14: LdConst[4](u64: 4)\n\t15: Abort\nB6:\n\t16: MoveLoc[3](Arg3: bool)\n\t17: BrFalse(25)\nB7:\n\t18: MoveLoc[0](Arg0: u128)\n\t19: MoveLoc[1](Arg1: u128)\n\t20: MoveLoc[2](Arg2: u64)\n\t21: LdFalse\n\t22: Call get_next_sqrt_price_from_amount_y_rouding_down(u128, u128, u64, bool): u128\n\t23: StLoc[5](loc1: u128)\n\t24: Branch(31)\nB8:\n\t25: MoveLoc[0](Arg0: u128)\n\t26: MoveLoc[1](Arg1: u128)\n\t27: MoveLoc[2](Arg2: u64)\n\t28: LdFalse\n\t29: Call get_next_sqrt_price_from_amount_x_rouding_up(u128, u128, u64, bool): u128\n\t30: StLoc[5](loc1: u128)\nB9:\n\t31: MoveLoc[5](loc1: u128)\n\t32: Ret\n}\n\npublic get_amount_x_delta(Arg0: u128, Arg1: u128, Arg2: u128, Arg3: bool): u64 {\nL4:\tloc0: bool\nL5:\tloc1: u128\nL6:\tloc2: bool\nL7:\tloc3: u256\nL8:\tloc4: u256\nL9:\tloc5: bool\nL10:\tloc6: u128\nB0:\n\t0: CopyLoc[0](Arg0: u128)\n\t1: LdU128(0)\n\t2: Eq\n\t3: BrFalse(7)\nB1:\n\t4: LdTrue\n\t5: StLoc[4](loc0: bool)\n\t6: Branch(11)\nB2:\n\t7: CopyLoc[1](Arg1: u128)\n\t8: LdU128(0)\n\t9: Eq\n\t10: StLoc[4](loc0: bool)\nB3:\n\t11: MoveLoc[4](loc0: bool)\n\t12: BrFalse(15)\nB4:\n\t13: LdConst[1](u64: 1)\n\t14: Abort\nB5:\n\t15: CopyLoc[0](Arg0: u128)\n\t16: CopyLoc[1](Arg1: u128)\n\t17: Gt\n\t18: BrFalse(24)\nB6:\n\t19: CopyLoc[0](Arg0: u128)\n\t20: CopyLoc[1](Arg1: u128)\n\t21: Sub\n\t22: StLoc[5](loc1: u128)\n\t23: Branch(28)\nB7:\n\t24: CopyLoc[1](Arg1: u128)\n\t25: CopyLoc[0](Arg0: u128)\n\t26: Sub\n\t27: StLoc[5](loc1: u128)\nB8:\n\t28: MoveLoc[5](loc1: u128)\n\t29: StLoc[10](loc6: u128)\n\t30: CopyLoc[10](loc6: u128)\n\t31: LdU128(0)\n\t32: Eq\n\t33: BrFalse(37)\nB9:\n\t34: LdTrue\n\t35: StLoc[6](loc2: bool)\n\t36: Branch(41)\nB10:\n\t37: CopyLoc[2](Arg2: u128)\n\t38: LdU128(0)\n\t39: Eq\n\t40: StLoc[6](loc2: bool)\nB11:\n\t41: MoveLoc[6](loc2: bool)\n\t42: BrFalse(45)\nB12:\n\t43: LdU64(0)\n\t44: Ret\nB13:\n\t45: MoveLoc[2](Arg2: u128)\n\t46: MoveLoc[10](loc6: u128)\n\t47: Call full_math_u128::full_mul(u128, u128): u256\n\t48: Call math_u256::checked_shlw(u256): u256 * bool\n\t49: StLoc[9](loc5: bool)\n\t50: StLoc[8](loc4: u256)\n\t51: MoveLoc[9](loc5: bool)\n\t52: BrFalse(55)\nB14:\n\t53: LdConst[0](u64: 0)\n\t54: Abort\nB15:\n\t55: MoveLoc[0](Arg0: u128)\n\t56: MoveLoc[1](Arg1: u128)\n\t57: Call full_math_u128::full_mul(u128, u128): u256\n\t58: StLoc[7](loc3: u256)\n\t59: MoveLoc[8](loc4: u256)\n\t60: MoveLoc[7](loc3: u256)\n\t61: MoveLoc[3](Arg3: bool)\n\t62: Call math_u256::div_round(u256, u256, bool): u256\n\t63: CastU64\n\t64: Ret\n}\n\npublic get_amount_y_delta(Arg0: u128, Arg1: u128, Arg2: u128, Arg3: bool): u64 {\nL4:\tloc0: u128\nL5:\tloc1: bool\nL6:\tloc2: u128\nB0:\n\t0: CopyLoc[0](Arg0: u128)\n\t1: CopyLoc[1](Arg1: u128)\n\t2: Gt\n\t3: BrFalse(9)\nB1:\n\t4: MoveLoc[0](Arg0: u128)\n\t5: MoveLoc[1](Arg1: u128)\n\t6: Sub\n\t7: StLoc[4](loc0: u128)\n\t8: Branch(13)\nB2:\n\t9: MoveLoc[1](Arg1: u128)\n\t10: MoveLoc[0](Arg0: u128)\n\t11: Sub\n\t12: StLoc[4](loc0: u128)\nB3:\n\t13: MoveLoc[4](loc0: u128)\n\t14: StLoc[6](loc2: u128)\n\t15: CopyLoc[6](loc2: u128)\n\t16: LdU128(0)\n\t17: Eq\n\t18: BrFalse(22)\nB4:\n\t19: LdTrue\n\t20: StLoc[5](loc1: bool)\n\t21: Branch(26)\nB5:\n\t22: CopyLoc[2](Arg2: u128)\n\t23: LdU128(0)\n\t24: Eq\n\t25: StLoc[5](loc1: bool)\nB6:\n\t26: MoveLoc[5](loc1: bool)\n\t27: BrFalse(30)\nB7:\n\t28: LdU64(0)\n\t29: Ret\nB8:\n\t30: MoveLoc[2](Arg2: u128)\n\t31: MoveLoc[6](loc2: u128)\n\t32: Call full_math_u128::full_mul(u128, u128): u256\n\t33: Call constants::get_q64(): u128\n\t34: CastU256\n\t35: MoveLoc[3](Arg3: bool)\n\t36: Call math_u256::div_round(u256, u256, bool): u256\n\t37: CastU64\n\t38: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n\t4 => u64: 4\n]\n}\n",
      "swap_math": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.swap_math {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::constants;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::full_math_u64;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::sqrt_price_math;\n\npublic compute_swap_step(Arg0: u128, Arg1: u128, Arg2: u128, Arg3: u64, Arg4: u64, Arg5: bool): u128 * u64 * u64 * u64 {\nL6:\tloc0: u64\nL7:\tloc1: u64\nL8:\tloc2: bool\nL9:\tloc3: bool\nL10:\tloc4: u64\nL11:\tloc5: u128\nL12:\tloc6: u64\nL13:\tloc7: u128\nL14:\tloc8: u64\nL15:\tloc9: bool\nL16:\tloc10: u64\nL17:\tloc11: u64\nL18:\tloc12: bool\nL19:\tloc13: u64\nL20:\tloc14: u64\nL21:\tloc15: u64\nL22:\tloc16: u64\nL23:\tloc17: bool\nL24:\tloc18: u128\nL25:\tloc19: bool\nB0:\n\t0: CopyLoc[0](Arg0: u128)\n\t1: CopyLoc[1](Arg1: u128)\n\t2: Ge\n\t3: StLoc[25](loc19: bool)\n\t4: LdU64(0)\n\t5: StLoc[19](loc13: u64)\n\t6: LdU64(0)\n\t7: StLoc[20](loc14: u64)\n\t8: LdU64(0)\n\t9: Pop\n\t10: LdU128(0)\n\t11: Pop\n\t12: CopyLoc[5](Arg5: bool)\n\t13: BrFalse(54)\nB1:\n\t14: CopyLoc[3](Arg3: u64)\n\t15: Call constants::get_fee_rate_denominator_value(): u64\n\t16: CopyLoc[4](Arg4: u64)\n\t17: Sub\n\t18: Call constants::get_fee_rate_denominator_value(): u64\n\t19: Call full_math_u64::mul_div_floor(u64, u64, u64): u64\n\t20: StLoc[21](loc15: u64)\n\t21: CopyLoc[25](loc19: bool)\n\t22: BrFalse(30)\nB2:\n\t23: CopyLoc[1](Arg1: u128)\n\t24: CopyLoc[0](Arg0: u128)\n\t25: CopyLoc[2](Arg2: u128)\n\t26: LdTrue\n\t27: Call sqrt_price_math::get_amount_x_delta(u128, u128, u128, bool): u64\n\t28: StLoc[6](loc0: u64)\n\t29: Branch(36)\nB3:\n\t30: CopyLoc[0](Arg0: u128)\n\t31: CopyLoc[1](Arg1: u128)\n\t32: CopyLoc[2](Arg2: u128)\n\t33: LdTrue\n\t34: Call sqrt_price_math::get_amount_y_delta(u128, u128, u128, bool): u64\n\t35: StLoc[6](loc0: u64)\nB4:\n\t36: MoveLoc[6](loc0: u64)\n\t37: StLoc[19](loc13: u64)\n\t38: CopyLoc[21](loc15: u64)\n\t39: CopyLoc[19](loc13: u64)\n\t40: Ge\n\t41: BrFalse(45)\nB5:\n\t42: CopyLoc[1](Arg1: u128)\n\t43: StLoc[11](loc5: u128)\n\t44: Branch(51)\nB6:\n\t45: CopyLoc[0](Arg0: u128)\n\t46: CopyLoc[2](Arg2: u128)\n\t47: MoveLoc[21](loc15: u64)\n\t48: CopyLoc[25](loc19: bool)\n\t49: Call sqrt_price_math::get_next_sqrt_price_from_input(u128, u128, u64, bool): u128\n\t50: StLoc[11](loc5: u128)\nB7:\n\t51: MoveLoc[11](loc5: u128)\n\t52: StLoc[24](loc18: u128)\n\t53: Branch(86)\nB8:\n\t54: CopyLoc[25](loc19: bool)\n\t55: BrFalse(63)\nB9:\n\t56: CopyLoc[1](Arg1: u128)\n\t57: CopyLoc[0](Arg0: u128)\n\t58: CopyLoc[2](Arg2: u128)\n\t59: LdFalse\n\t60: Call sqrt_price_math::get_amount_y_delta(u128, u128, u128, bool): u64\n\t61: StLoc[12](loc6: u64)\n\t62: Branch(69)\nB10:\n\t63: CopyLoc[0](Arg0: u128)\n\t64: CopyLoc[1](Arg1: u128)\n\t65: CopyLoc[2](Arg2: u128)\n\t66: LdFalse\n\t67: Call sqrt_price_math::get_amount_x_delta(u128, u128, u128, bool): u64\n\t68: StLoc[12](loc6: u64)\nB11:\n\t69: MoveLoc[12](loc6: u64)\n\t70: StLoc[20](loc14: u64)\n\t71: CopyLoc[3](Arg3: u64)\n\t72: CopyLoc[20](loc14: u64)\n\t73: Ge\n\t74: BrFalse(78)\nB12:\n\t75: CopyLoc[1](Arg1: u128)\n\t76: StLoc[13](loc7: u128)\n\t77: Branch(84)\nB13:\n\t78: CopyLoc[0](Arg0: u128)\n\t79: CopyLoc[2](Arg2: u128)\n\t80: CopyLoc[3](Arg3: u64)\n\t81: CopyLoc[25](loc19: bool)\n\t82: Call sqrt_price_math::get_next_sqrt_price_from_output(u128, u128, u64, bool): u128\n\t83: StLoc[13](loc7: u128)\nB14:\n\t84: MoveLoc[13](loc7: u128)\n\t85: StLoc[24](loc18: u128)\nB15:\n\t86: CopyLoc[1](Arg1: u128)\n\t87: CopyLoc[24](loc18: u128)\n\t88: Eq\n\t89: StLoc[23](loc17: bool)\n\t90: MoveLoc[25](loc19: bool)\n\t91: BrFalse(129)\nB16:\n\t92: CopyLoc[23](loc17: bool)\n\t93: CopyLoc[5](Arg5: bool)\n\t94: And\n\t95: BrFalse(99)\nB17:\n\t96: MoveLoc[19](loc13: u64)\n\t97: StLoc[14](loc8: u64)\n\t98: Branch(105)\nB18:\n\t99: CopyLoc[24](loc18: u128)\n\t100: CopyLoc[0](Arg0: u128)\n\t101: CopyLoc[2](Arg2: u128)\n\t102: LdTrue\n\t103: Call sqrt_price_math::get_amount_x_delta(u128, u128, u128, bool): u64\n\t104: StLoc[14](loc8: u64)\nB19:\n\t105: MoveLoc[14](loc8: u64)\n\t106: StLoc[19](loc13: u64)\n\t107: MoveLoc[23](loc17: bool)\n\t108: BrFalse(113)\nB20:\n\t109: CopyLoc[5](Arg5: bool)\n\t110: Not\n\t111: StLoc[15](loc9: bool)\n\t112: Branch(115)\nB21:\n\t113: LdFalse\n\t114: StLoc[15](loc9: bool)\nB22:\n\t115: MoveLoc[15](loc9: bool)\n\t116: BrFalse(120)\nB23:\n\t117: MoveLoc[20](loc14: u64)\n\t118: StLoc[16](loc10: u64)\n\t119: Branch(126)\nB24:\n\t120: CopyLoc[24](loc18: u128)\n\t121: MoveLoc[0](Arg0: u128)\n\t122: MoveLoc[2](Arg2: u128)\n\t123: LdFalse\n\t124: Call sqrt_price_math::get_amount_y_delta(u128, u128, u128, bool): u64\n\t125: StLoc[16](loc10: u64)\nB25:\n\t126: MoveLoc[16](loc10: u64)\n\t127: StLoc[20](loc14: u64)\n\t128: Branch(165)\nB26:\n\t129: CopyLoc[23](loc17: bool)\n\t130: CopyLoc[5](Arg5: bool)\n\t131: And\n\t132: BrFalse(136)\nB27:\n\t133: MoveLoc[19](loc13: u64)\n\t134: StLoc[17](loc11: u64)\n\t135: Branch(142)\nB28:\n\t136: CopyLoc[0](Arg0: u128)\n\t137: CopyLoc[24](loc18: u128)\n\t138: CopyLoc[2](Arg2: u128)\n\t139: LdTrue\n\t140: Call sqrt_price_math::get_amount_y_delta(u128, u128, u128, bool): u64\n\t141: StLoc[17](loc11: u64)\nB29:\n\t142: MoveLoc[17](loc11: u64)\n\t143: StLoc[19](loc13: u64)\n\t144: MoveLoc[23](loc17: bool)\n\t145: BrFalse(150)\nB30:\n\t146: CopyLoc[5](Arg5: bool)\n\t147: Not\n\t148: StLoc[18](loc12: bool)\n\t149: Branch(152)\nB31:\n\t150: LdFalse\n\t151: StLoc[18](loc12: bool)\nB32:\n\t152: MoveLoc[18](loc12: bool)\n\t153: BrFalse(157)\nB33:\n\t154: MoveLoc[20](loc14: u64)\n\t155: StLoc[7](loc1: u64)\n\t156: Branch(163)\nB34:\n\t157: MoveLoc[0](Arg0: u128)\n\t158: CopyLoc[24](loc18: u128)\n\t159: MoveLoc[2](Arg2: u128)\n\t160: LdFalse\n\t161: Call sqrt_price_math::get_amount_x_delta(u128, u128, u128, bool): u64\n\t162: StLoc[7](loc1: u64)\nB35:\n\t163: MoveLoc[7](loc1: u64)\n\t164: StLoc[20](loc14: u64)\nB36:\n\t165: CopyLoc[5](Arg5: bool)\n\t166: Not\n\t167: BrFalse(173)\nB37:\n\t168: CopyLoc[20](loc14: u64)\n\t169: CopyLoc[3](Arg3: u64)\n\t170: Gt\n\t171: StLoc[8](loc2: bool)\n\t172: Branch(175)\nB38:\n\t173: LdFalse\n\t174: StLoc[8](loc2: bool)\nB39:\n\t175: MoveLoc[8](loc2: bool)\n\t176: BrFalse(179)\nB40:\n\t177: CopyLoc[3](Arg3: u64)\n\t178: StLoc[20](loc14: u64)\nB41:\n\t179: MoveLoc[5](Arg5: bool)\n\t180: BrFalse(186)\nB42:\n\t181: CopyLoc[24](loc18: u128)\n\t182: MoveLoc[1](Arg1: u128)\n\t183: Neq\n\t184: StLoc[9](loc3: bool)\n\t185: Branch(188)\nB43:\n\t186: LdFalse\n\t187: StLoc[9](loc3: bool)\nB44:\n\t188: MoveLoc[9](loc3: bool)\n\t189: BrFalse(195)\nB45:\n\t190: MoveLoc[3](Arg3: u64)\n\t191: CopyLoc[19](loc13: u64)\n\t192: Sub\n\t193: StLoc[10](loc4: u64)\n\t194: Branch(202)\nB46:\n\t195: CopyLoc[19](loc13: u64)\n\t196: CopyLoc[4](Arg4: u64)\n\t197: Call constants::get_fee_rate_denominator_value(): u64\n\t198: MoveLoc[4](Arg4: u64)\n\t199: Sub\n\t200: Call full_math_u64::mul_div_round(u64, u64, u64): u64\n\t201: StLoc[10](loc4: u64)\nB47:\n\t202: MoveLoc[10](loc4: u64)\n\t203: StLoc[22](loc16: u64)\n\t204: MoveLoc[24](loc18: u128)\n\t205: MoveLoc[19](loc13: u64)\n\t206: MoveLoc[20](loc14: u64)\n\t207: MoveLoc[22](loc16: u64)\n\t208: Ret\n}\n\n}\n",
      "swap_router": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.swap_router {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::pool;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::pool_manager;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::tick_math;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::utils;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::versioned;\nuse 0000000000000000000000000000000000000000000000000000000000000002::balance;\nuse 0000000000000000000000000000000000000000000000000000000000000002::clock;\nuse 0000000000000000000000000000000000000000000000000000000000000002::coin;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\npublic swap_exact_x_to_y<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: Coin<Ty0>, Arg2: u128, Arg3: &Versioned, Arg4: &Clock, Arg5: &TxContext): Balance<Ty1> {\nL6:\tloc0: u64\nL7:\tloc1: SwapReceipt\nL8:\tloc2: Balance<Ty1>\nB0:\n\t0: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t1: LdTrue\n\t2: LdTrue\n\t3: ImmBorrowLoc[1](Arg1: Coin<Ty0>)\n\t4: Call coin::value<Ty0>(&Coin<Ty0>): u64\n\t5: MoveLoc[2](Arg2: u128)\n\t6: LdTrue\n\t7: Call get_sqrt_price_limit(u128, bool): u128\n\t8: CopyLoc[3](Arg3: &Versioned)\n\t9: MoveLoc[4](Arg4: &Clock)\n\t10: CopyLoc[5](Arg5: &TxContext)\n\t11: Call pool::swap<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, bool, bool, u64, u128, &Versioned, &Clock, &TxContext): Balance<Ty0> * Balance<Ty1> * SwapReceipt\n\t12: StLoc[7](loc1: SwapReceipt)\n\t13: StLoc[8](loc2: Balance<Ty1>)\n\t14: Call balance::destroy_zero<Ty0>(Balance<Ty0>)\n\t15: ImmBorrowLoc[7](loc1: SwapReceipt)\n\t16: Call pool::swap_receipt_debts(&SwapReceipt): u64 * u64\n\t17: Pop\n\t18: StLoc[6](loc0: u64)\n\t19: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t20: MoveLoc[7](loc1: SwapReceipt)\n\t21: MutBorrowLoc[1](Arg1: Coin<Ty0>)\n\t22: Call coin::balance_mut<Ty0>(&mut Coin<Ty0>): &mut Balance<Ty0>\n\t23: MoveLoc[6](loc0: u64)\n\t24: Call balance::split<Ty0>(&mut Balance<Ty0>, u64): Balance<Ty0>\n\t25: Call balance::zero<Ty1>(): Balance<Ty1>\n\t26: MoveLoc[3](Arg3: &Versioned)\n\t27: CopyLoc[5](Arg5: &TxContext)\n\t28: Call pool::pay<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, SwapReceipt, Balance<Ty0>, Balance<Ty1>, &Versioned, &TxContext)\n\t29: MoveLoc[1](Arg1: Coin<Ty0>)\n\t30: MoveLoc[5](Arg5: &TxContext)\n\t31: Call tx_context::sender(&TxContext): address\n\t32: Call utils::refund<Ty0>(Coin<Ty0>, address)\n\t33: MoveLoc[8](loc2: Balance<Ty1>)\n\t34: Ret\n}\n\npublic swap_exact_y_to_x<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: Coin<Ty1>, Arg2: u128, Arg3: &Versioned, Arg4: &Clock, Arg5: &TxContext): Balance<Ty0> {\nL6:\tloc0: u64\nL7:\tloc1: SwapReceipt\nL8:\tloc2: Balance<Ty0>\nL9:\tloc3: Balance<Ty1>\nB0:\n\t0: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t1: LdFalse\n\t2: LdTrue\n\t3: ImmBorrowLoc[1](Arg1: Coin<Ty1>)\n\t4: Call coin::value<Ty1>(&Coin<Ty1>): u64\n\t5: MoveLoc[2](Arg2: u128)\n\t6: LdFalse\n\t7: Call get_sqrt_price_limit(u128, bool): u128\n\t8: CopyLoc[3](Arg3: &Versioned)\n\t9: MoveLoc[4](Arg4: &Clock)\n\t10: CopyLoc[5](Arg5: &TxContext)\n\t11: Call pool::swap<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, bool, bool, u64, u128, &Versioned, &Clock, &TxContext): Balance<Ty0> * Balance<Ty1> * SwapReceipt\n\t12: StLoc[7](loc1: SwapReceipt)\n\t13: StLoc[9](loc3: Balance<Ty1>)\n\t14: StLoc[8](loc2: Balance<Ty0>)\n\t15: MoveLoc[9](loc3: Balance<Ty1>)\n\t16: Call balance::destroy_zero<Ty1>(Balance<Ty1>)\n\t17: ImmBorrowLoc[7](loc1: SwapReceipt)\n\t18: Call pool::swap_receipt_debts(&SwapReceipt): u64 * u64\n\t19: StLoc[6](loc0: u64)\n\t20: Pop\n\t21: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t22: MoveLoc[7](loc1: SwapReceipt)\n\t23: Call balance::zero<Ty0>(): Balance<Ty0>\n\t24: MutBorrowLoc[1](Arg1: Coin<Ty1>)\n\t25: Call coin::balance_mut<Ty1>(&mut Coin<Ty1>): &mut Balance<Ty1>\n\t26: MoveLoc[6](loc0: u64)\n\t27: Call balance::split<Ty1>(&mut Balance<Ty1>, u64): Balance<Ty1>\n\t28: MoveLoc[3](Arg3: &Versioned)\n\t29: CopyLoc[5](Arg5: &TxContext)\n\t30: Call pool::pay<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, SwapReceipt, Balance<Ty0>, Balance<Ty1>, &Versioned, &TxContext)\n\t31: MoveLoc[1](Arg1: Coin<Ty1>)\n\t32: MoveLoc[5](Arg5: &TxContext)\n\t33: Call tx_context::sender(&TxContext): address\n\t34: Call utils::refund<Ty1>(Coin<Ty1>, address)\n\t35: MoveLoc[8](loc2: Balance<Ty0>)\n\t36: Ret\n}\n\npublic swap_exact_input<Ty0, Ty1>(Arg0: &mut PoolRegistry, Arg1: u64, Arg2: Coin<Ty0>, Arg3: u64, Arg4: u128, Arg5: u64, Arg6: &Versioned, Arg7: &Clock, Arg8: &mut TxContext): Coin<Ty1> {\nL9:\tloc0: Balance<Ty1>\nL10:\tloc1: Balance<Ty1>\nB0:\n\t0: CopyLoc[7](Arg7: &Clock)\n\t1: MoveLoc[5](Arg5: u64)\n\t2: Call utils::check_deadline(&Clock, u64)\n\t3: Call utils::is_ordered<Ty0, Ty1>(): bool\n\t4: BrFalse(17)\nB1:\n\t5: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t6: MoveLoc[1](Arg1: u64)\n\t7: Call pool_manager::borrow_mut_pool<Ty0, Ty1>(&mut PoolRegistry, u64): &mut Pool<Ty0, Ty1>\n\t8: MoveLoc[2](Arg2: Coin<Ty0>)\n\t9: MoveLoc[4](Arg4: u128)\n\t10: MoveLoc[6](Arg6: &Versioned)\n\t11: MoveLoc[7](Arg7: &Clock)\n\t12: CopyLoc[8](Arg8: &mut TxContext)\n\t13: FreezeRef\n\t14: Call swap_exact_x_to_y<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, Coin<Ty0>, u128, &Versioned, &Clock, &TxContext): Balance<Ty1>\n\t15: StLoc[9](loc0: Balance<Ty1>)\n\t16: Branch(28)\nB2:\n\t17: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t18: MoveLoc[1](Arg1: u64)\n\t19: Call pool_manager::borrow_mut_pool<Ty1, Ty0>(&mut PoolRegistry, u64): &mut Pool<Ty1, Ty0>\n\t20: MoveLoc[2](Arg2: Coin<Ty0>)\n\t21: MoveLoc[4](Arg4: u128)\n\t22: MoveLoc[6](Arg6: &Versioned)\n\t23: MoveLoc[7](Arg7: &Clock)\n\t24: CopyLoc[8](Arg8: &mut TxContext)\n\t25: FreezeRef\n\t26: Call swap_exact_y_to_x<Ty1, Ty0>(&mut Pool<Ty1, Ty0>, Coin<Ty0>, u128, &Versioned, &Clock, &TxContext): Balance<Ty1>\n\t27: StLoc[9](loc0: Balance<Ty1>)\nB3:\n\t28: MoveLoc[9](loc0: Balance<Ty1>)\n\t29: StLoc[10](loc1: Balance<Ty1>)\n\t30: ImmBorrowLoc[10](loc1: Balance<Ty1>)\n\t31: Call balance::value<Ty1>(&Balance<Ty1>): u64\n\t32: MoveLoc[3](Arg3: u64)\n\t33: Lt\n\t34: BrFalse(39)\nB4:\n\t35: MoveLoc[8](Arg8: &mut TxContext)\n\t36: Pop\n\t37: LdConst[0](u64: 1)\n\t38: Abort\nB5:\n\t39: MoveLoc[10](loc1: Balance<Ty1>)\n\t40: MoveLoc[8](Arg8: &mut TxContext)\n\t41: Call coin::from_balance<Ty1>(Balance<Ty1>, &mut TxContext): Coin<Ty1>\n\t42: Ret\n}\n\npublic swap_x_to_exact_y<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: Coin<Ty0>, Arg2: u64, Arg3: u128, Arg4: &Versioned, Arg5: &Clock, Arg6: &mut TxContext): Balance<Ty1> {\nL7:\tloc0: u64\nL8:\tloc1: u128\nL9:\tloc2: &Versioned\nL10:\tloc3: &Clock\nL11:\tloc4: &mut TxContext\nL12:\tloc5: u64\nL13:\tloc6: SwapReceipt\nL14:\tloc7: Balance<Ty1>\nB0:\n\t0: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t1: MoveLoc[2](Arg2: u64)\n\t2: MoveLoc[3](Arg3: u128)\n\t3: LdTrue\n\t4: Call get_sqrt_price_limit(u128, bool): u128\n\t5: CopyLoc[4](Arg4: &Versioned)\n\t6: MoveLoc[5](Arg5: &Clock)\n\t7: CopyLoc[6](Arg6: &mut TxContext)\n\t8: StLoc[11](loc4: &mut TxContext)\n\t9: StLoc[10](loc3: &Clock)\n\t10: StLoc[9](loc2: &Versioned)\n\t11: StLoc[8](loc1: u128)\n\t12: StLoc[7](loc0: u64)\n\t13: LdTrue\n\t14: LdFalse\n\t15: MoveLoc[7](loc0: u64)\n\t16: MoveLoc[8](loc1: u128)\n\t17: MoveLoc[9](loc2: &Versioned)\n\t18: MoveLoc[10](loc3: &Clock)\n\t19: MoveLoc[11](loc4: &mut TxContext)\n\t20: FreezeRef\n\t21: Call pool::swap<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, bool, bool, u64, u128, &Versioned, &Clock, &TxContext): Balance<Ty0> * Balance<Ty1> * SwapReceipt\n\t22: StLoc[13](loc6: SwapReceipt)\n\t23: StLoc[14](loc7: Balance<Ty1>)\n\t24: Call balance::destroy_zero<Ty0>(Balance<Ty0>)\n\t25: ImmBorrowLoc[13](loc6: SwapReceipt)\n\t26: Call pool::swap_receipt_debts(&SwapReceipt): u64 * u64\n\t27: Pop\n\t28: StLoc[12](loc5: u64)\n\t29: CopyLoc[12](loc5: u64)\n\t30: ImmBorrowLoc[1](Arg1: Coin<Ty0>)\n\t31: Call coin::value<Ty0>(&Coin<Ty0>): u64\n\t32: Gt\n\t33: BrFalse(42)\nB1:\n\t34: MoveLoc[4](Arg4: &Versioned)\n\t35: Pop\n\t36: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t37: Pop\n\t38: MoveLoc[6](Arg6: &mut TxContext)\n\t39: Pop\n\t40: LdConst[1](u64: 2)\n\t41: Abort\nB2:\n\t42: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t43: MoveLoc[13](loc6: SwapReceipt)\n\t44: MutBorrowLoc[1](Arg1: Coin<Ty0>)\n\t45: MoveLoc[12](loc5: u64)\n\t46: CopyLoc[6](Arg6: &mut TxContext)\n\t47: Call coin::split<Ty0>(&mut Coin<Ty0>, u64, &mut TxContext): Coin<Ty0>\n\t48: Call coin::into_balance<Ty0>(Coin<Ty0>): Balance<Ty0>\n\t49: Call balance::zero<Ty1>(): Balance<Ty1>\n\t50: MoveLoc[4](Arg4: &Versioned)\n\t51: CopyLoc[6](Arg6: &mut TxContext)\n\t52: FreezeRef\n\t53: Call pool::pay<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, SwapReceipt, Balance<Ty0>, Balance<Ty1>, &Versioned, &TxContext)\n\t54: MoveLoc[1](Arg1: Coin<Ty0>)\n\t55: MoveLoc[6](Arg6: &mut TxContext)\n\t56: FreezeRef\n\t57: Call tx_context::sender(&TxContext): address\n\t58: Call utils::refund<Ty0>(Coin<Ty0>, address)\n\t59: MoveLoc[14](loc7: Balance<Ty1>)\n\t60: Ret\n}\n\npublic swap_y_to_exact_x<Ty0, Ty1>(Arg0: &mut Pool<Ty0, Ty1>, Arg1: Coin<Ty1>, Arg2: u64, Arg3: u128, Arg4: &Versioned, Arg5: &Clock, Arg6: &mut TxContext): Balance<Ty0> {\nL7:\tloc0: u64\nL8:\tloc1: u128\nL9:\tloc2: &Versioned\nL10:\tloc3: &Clock\nL11:\tloc4: &mut TxContext\nL12:\tloc5: u64\nL13:\tloc6: SwapReceipt\nL14:\tloc7: Balance<Ty0>\nL15:\tloc8: Balance<Ty1>\nB0:\n\t0: CopyLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t1: MoveLoc[2](Arg2: u64)\n\t2: MoveLoc[3](Arg3: u128)\n\t3: LdFalse\n\t4: Call get_sqrt_price_limit(u128, bool): u128\n\t5: CopyLoc[4](Arg4: &Versioned)\n\t6: MoveLoc[5](Arg5: &Clock)\n\t7: CopyLoc[6](Arg6: &mut TxContext)\n\t8: StLoc[11](loc4: &mut TxContext)\n\t9: StLoc[10](loc3: &Clock)\n\t10: StLoc[9](loc2: &Versioned)\n\t11: StLoc[8](loc1: u128)\n\t12: StLoc[7](loc0: u64)\n\t13: LdFalse\n\t14: LdFalse\n\t15: MoveLoc[7](loc0: u64)\n\t16: MoveLoc[8](loc1: u128)\n\t17: MoveLoc[9](loc2: &Versioned)\n\t18: MoveLoc[10](loc3: &Clock)\n\t19: MoveLoc[11](loc4: &mut TxContext)\n\t20: FreezeRef\n\t21: Call pool::swap<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, bool, bool, u64, u128, &Versioned, &Clock, &TxContext): Balance<Ty0> * Balance<Ty1> * SwapReceipt\n\t22: StLoc[13](loc6: SwapReceipt)\n\t23: StLoc[15](loc8: Balance<Ty1>)\n\t24: StLoc[14](loc7: Balance<Ty0>)\n\t25: MoveLoc[15](loc8: Balance<Ty1>)\n\t26: Call balance::destroy_zero<Ty1>(Balance<Ty1>)\n\t27: ImmBorrowLoc[13](loc6: SwapReceipt)\n\t28: Call pool::swap_receipt_debts(&SwapReceipt): u64 * u64\n\t29: StLoc[12](loc5: u64)\n\t30: Pop\n\t31: CopyLoc[12](loc5: u64)\n\t32: ImmBorrowLoc[1](Arg1: Coin<Ty1>)\n\t33: Call coin::value<Ty1>(&Coin<Ty1>): u64\n\t34: Gt\n\t35: BrFalse(44)\nB1:\n\t36: MoveLoc[4](Arg4: &Versioned)\n\t37: Pop\n\t38: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t39: Pop\n\t40: MoveLoc[6](Arg6: &mut TxContext)\n\t41: Pop\n\t42: LdConst[1](u64: 2)\n\t43: Abort\nB2:\n\t44: MoveLoc[0](Arg0: &mut Pool<Ty0, Ty1>)\n\t45: MoveLoc[13](loc6: SwapReceipt)\n\t46: Call balance::zero<Ty0>(): Balance<Ty0>\n\t47: MutBorrowLoc[1](Arg1: Coin<Ty1>)\n\t48: MoveLoc[12](loc5: u64)\n\t49: CopyLoc[6](Arg6: &mut TxContext)\n\t50: Call coin::split<Ty1>(&mut Coin<Ty1>, u64, &mut TxContext): Coin<Ty1>\n\t51: Call coin::into_balance<Ty1>(Coin<Ty1>): Balance<Ty1>\n\t52: MoveLoc[4](Arg4: &Versioned)\n\t53: CopyLoc[6](Arg6: &mut TxContext)\n\t54: FreezeRef\n\t55: Call pool::pay<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, SwapReceipt, Balance<Ty0>, Balance<Ty1>, &Versioned, &TxContext)\n\t56: MoveLoc[1](Arg1: Coin<Ty1>)\n\t57: MoveLoc[6](Arg6: &mut TxContext)\n\t58: FreezeRef\n\t59: Call tx_context::sender(&TxContext): address\n\t60: Call utils::refund<Ty1>(Coin<Ty1>, address)\n\t61: MoveLoc[14](loc7: Balance<Ty0>)\n\t62: Ret\n}\n\npublic swap_exact_output<Ty0, Ty1>(Arg0: &mut PoolRegistry, Arg1: u64, Arg2: Coin<Ty0>, Arg3: u64, Arg4: u128, Arg5: u64, Arg6: &Versioned, Arg7: &Clock, Arg8: &mut TxContext): Coin<Ty1> {\nL9:\tloc0: Balance<Ty1>\nB0:\n\t0: CopyLoc[7](Arg7: &Clock)\n\t1: MoveLoc[5](Arg5: u64)\n\t2: Call utils::check_deadline(&Clock, u64)\n\t3: Call utils::is_ordered<Ty0, Ty1>(): bool\n\t4: BrFalse(17)\nB1:\n\t5: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t6: MoveLoc[1](Arg1: u64)\n\t7: Call pool_manager::borrow_mut_pool<Ty0, Ty1>(&mut PoolRegistry, u64): &mut Pool<Ty0, Ty1>\n\t8: MoveLoc[2](Arg2: Coin<Ty0>)\n\t9: MoveLoc[3](Arg3: u64)\n\t10: MoveLoc[4](Arg4: u128)\n\t11: MoveLoc[6](Arg6: &Versioned)\n\t12: MoveLoc[7](Arg7: &Clock)\n\t13: CopyLoc[8](Arg8: &mut TxContext)\n\t14: Call swap_x_to_exact_y<Ty0, Ty1>(&mut Pool<Ty0, Ty1>, Coin<Ty0>, u64, u128, &Versioned, &Clock, &mut TxContext): Balance<Ty1>\n\t15: StLoc[9](loc0: Balance<Ty1>)\n\t16: Branch(28)\nB2:\n\t17: MoveLoc[0](Arg0: &mut PoolRegistry)\n\t18: MoveLoc[1](Arg1: u64)\n\t19: Call pool_manager::borrow_mut_pool<Ty1, Ty0>(&mut PoolRegistry, u64): &mut Pool<Ty1, Ty0>\n\t20: MoveLoc[2](Arg2: Coin<Ty0>)\n\t21: MoveLoc[3](Arg3: u64)\n\t22: MoveLoc[4](Arg4: u128)\n\t23: MoveLoc[6](Arg6: &Versioned)\n\t24: MoveLoc[7](Arg7: &Clock)\n\t25: CopyLoc[8](Arg8: &mut TxContext)\n\t26: Call swap_y_to_exact_x<Ty1, Ty0>(&mut Pool<Ty1, Ty0>, Coin<Ty0>, u64, u128, &Versioned, &Clock, &mut TxContext): Balance<Ty1>\n\t27: StLoc[9](loc0: Balance<Ty1>)\nB3:\n\t28: MoveLoc[9](loc0: Balance<Ty1>)\n\t29: MoveLoc[8](Arg8: &mut TxContext)\n\t30: Call coin::from_balance<Ty1>(Balance<Ty1>, &mut TxContext): Coin<Ty1>\n\t31: Ret\n}\n\nget_sqrt_price_limit(Arg0: u128, Arg1: bool): u128 {\nL2:\tloc0: u128\nL3:\tloc1: u128\nB0:\n\t0: CopyLoc[0](Arg0: u128)\n\t1: LdU128(0)\n\t2: Eq\n\t3: BrFalse(18)\nB1:\n\t4: MoveLoc[1](Arg1: bool)\n\t5: BrFalse(11)\nB2:\n\t6: Call tick_math::min_sqrt_price(): u128\n\t7: LdU128(1)\n\t8: Add\n\t9: StLoc[2](loc0: u128)\n\t10: Branch(15)\nB3:\n\t11: Call tick_math::max_sqrt_price(): u128\n\t12: LdU128(1)\n\t13: Sub\n\t14: StLoc[2](loc0: u128)\nB4:\n\t15: MoveLoc[2](loc0: u128)\n\t16: StLoc[3](loc1: u128)\n\t17: Branch(20)\nB5:\n\t18: MoveLoc[0](Arg0: u128)\n\t19: StLoc[3](loc1: u128)\nB6:\n\t20: MoveLoc[3](loc1: u128)\n\t21: Ret\n}\n\nConstants [\n\t0 => u64: 1\n\t1 => u64: 2\n]\n}\n",
      "tick": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.tick {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::constants;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::full_math_u128;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i128;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i32;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i64;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::liquidity_math;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::tick_math;\nuse 0000000000000000000000000000000000000000000000000000000000000002::table;\n\nstruct TickInfo has copy, drop, store {\n\tliquidity_gross: u128,\n\tliquidity_net: I128,\n\tfee_growth_outside_x: u128,\n\tfee_growth_outside_y: u128,\n\treward_growths_outside: vector<u128>,\n\ttick_cumulative_out_side: I64,\n\tseconds_per_liquidity_out_side: u256,\n\tseconds_out_side: u64\n}\n\npublic check_ticks(Arg0: I32, Arg1: I32, Arg2: u32) {\nL3:\tloc0: bool\nB0:\n\t0: CopyLoc[0](Arg0: I32)\n\t1: Call i32::abs_u32(I32): u32\n\t2: CopyLoc[2](Arg2: u32)\n\t3: Mod\n\t4: LdU32(0)\n\t5: Neq\n\t6: BrFalse(10)\nB1:\n\t7: LdTrue\n\t8: StLoc[3](loc0: bool)\n\t9: Branch(17)\nB2:\n\t10: CopyLoc[1](Arg1: I32)\n\t11: Call i32::abs_u32(I32): u32\n\t12: MoveLoc[2](Arg2: u32)\n\t13: Mod\n\t14: LdU32(0)\n\t15: Neq\n\t16: StLoc[3](loc0: bool)\nB3:\n\t17: MoveLoc[3](loc0: bool)\n\t18: BrFalse(21)\nB4:\n\t19: LdConst[4](u64: 4)\n\t20: Abort\nB5:\n\t21: CopyLoc[0](Arg0: I32)\n\t22: CopyLoc[1](Arg1: I32)\n\t23: Call i32::gte(I32, I32): bool\n\t24: BrFalse(27)\nB6:\n\t25: LdConst[1](u64: 1)\n\t26: Abort\nB7:\n\t27: MoveLoc[0](Arg0: I32)\n\t28: Call tick_math::min_tick(): I32\n\t29: Call i32::lt(I32, I32): bool\n\t30: BrFalse(33)\nB8:\n\t31: LdConst[2](u64: 2)\n\t32: Abort\nB9:\n\t33: MoveLoc[1](Arg1: I32)\n\t34: Call tick_math::max_tick(): I32\n\t35: Call i32::gt(I32, I32): bool\n\t36: BrFalse(39)\nB10:\n\t37: LdConst[3](u64: 3)\n\t38: Abort\nB11:\n\t39: Ret\n}\n\npublic is_initialized(Arg0: &Table<I32, TickInfo>, Arg1: I32): bool {\nB0:\n\t0: MoveLoc[0](Arg0: &Table<I32, TickInfo>)\n\t1: MoveLoc[1](Arg1: I32)\n\t2: Call table::contains<I32, TickInfo>(&Table<I32, TickInfo>, I32): bool\n\t3: Ret\n}\n\npublic get_fee_and_reward_growths_outside(Arg0: &Table<I32, TickInfo>, Arg1: I32): u128 * u128 * vector<u128> {\nL2:\tloc0: u128\nL3:\tloc1: u128\nL4:\tloc2: vector<u128>\nL5:\tloc3: &TickInfo\nB0:\n\t0: CopyLoc[0](Arg0: &Table<I32, TickInfo>)\n\t1: CopyLoc[1](Arg1: I32)\n\t2: Call is_initialized(&Table<I32, TickInfo>, I32): bool\n\t3: Not\n\t4: BrFalse(14)\nB1:\n\t5: MoveLoc[0](Arg0: &Table<I32, TickInfo>)\n\t6: Pop\n\t7: LdU128(0)\n\t8: LdU128(0)\n\t9: VecPack(5, 0)\n\t10: StLoc[4](loc2: vector<u128>)\n\t11: StLoc[3](loc1: u128)\n\t12: StLoc[2](loc0: u128)\n\t13: Branch(30)\nB2:\n\t14: MoveLoc[0](Arg0: &Table<I32, TickInfo>)\n\t15: MoveLoc[1](Arg1: I32)\n\t16: Call table::borrow<I32, TickInfo>(&Table<I32, TickInfo>, I32): &TickInfo\n\t17: StLoc[5](loc3: &TickInfo)\n\t18: CopyLoc[5](loc3: &TickInfo)\n\t19: ImmBorrowField[0](TickInfo.fee_growth_outside_x: u128)\n\t20: ReadRef\n\t21: CopyLoc[5](loc3: &TickInfo)\n\t22: ImmBorrowField[1](TickInfo.fee_growth_outside_y: u128)\n\t23: ReadRef\n\t24: MoveLoc[5](loc3: &TickInfo)\n\t25: ImmBorrowField[2](TickInfo.reward_growths_outside: vector<u128>)\n\t26: ReadRef\n\t27: StLoc[4](loc2: vector<u128>)\n\t28: StLoc[3](loc1: u128)\n\t29: StLoc[2](loc0: u128)\nB3:\n\t30: MoveLoc[2](loc0: u128)\n\t31: MoveLoc[3](loc1: u128)\n\t32: MoveLoc[4](loc2: vector<u128>)\n\t33: Ret\n}\n\npublic get_liquidity_gross(Arg0: &Table<I32, TickInfo>, Arg1: I32): u128 {\nL2:\tloc0: u128\nB0:\n\t0: CopyLoc[0](Arg0: &Table<I32, TickInfo>)\n\t1: CopyLoc[1](Arg1: I32)\n\t2: Call is_initialized(&Table<I32, TickInfo>, I32): bool\n\t3: Not\n\t4: BrFalse(10)\nB1:\n\t5: MoveLoc[0](Arg0: &Table<I32, TickInfo>)\n\t6: Pop\n\t7: LdU128(0)\n\t8: StLoc[2](loc0: u128)\n\t9: Branch(16)\nB2:\n\t10: MoveLoc[0](Arg0: &Table<I32, TickInfo>)\n\t11: MoveLoc[1](Arg1: I32)\n\t12: Call table::borrow<I32, TickInfo>(&Table<I32, TickInfo>, I32): &TickInfo\n\t13: ImmBorrowField[3](TickInfo.liquidity_gross: u128)\n\t14: ReadRef\n\t15: StLoc[2](loc0: u128)\nB3:\n\t16: MoveLoc[2](loc0: u128)\n\t17: Ret\n}\n\npublic get_liquidity_net(Arg0: &Table<I32, TickInfo>, Arg1: I32): I128 {\nL2:\tloc0: I128\nB0:\n\t0: CopyLoc[0](Arg0: &Table<I32, TickInfo>)\n\t1: CopyLoc[1](Arg1: I32)\n\t2: Call is_initialized(&Table<I32, TickInfo>, I32): bool\n\t3: Not\n\t4: BrFalse(10)\nB1:\n\t5: MoveLoc[0](Arg0: &Table<I32, TickInfo>)\n\t6: Pop\n\t7: Call i128::zero(): I128\n\t8: StLoc[2](loc0: I128)\n\t9: Branch(16)\nB2:\n\t10: MoveLoc[0](Arg0: &Table<I32, TickInfo>)\n\t11: MoveLoc[1](Arg1: I32)\n\t12: Call table::borrow<I32, TickInfo>(&Table<I32, TickInfo>, I32): &TickInfo\n\t13: ImmBorrowField[4](TickInfo.liquidity_net: I128)\n\t14: ReadRef\n\t15: StLoc[2](loc0: I128)\nB3:\n\t16: MoveLoc[2](loc0: I128)\n\t17: Ret\n}\n\npublic get_tick_cumulative_out_side(Arg0: &Table<I32, TickInfo>, Arg1: I32): I64 {\nL2:\tloc0: I64\nB0:\n\t0: CopyLoc[0](Arg0: &Table<I32, TickInfo>)\n\t1: CopyLoc[1](Arg1: I32)\n\t2: Call is_initialized(&Table<I32, TickInfo>, I32): bool\n\t3: Not\n\t4: BrFalse(10)\nB1:\n\t5: MoveLoc[0](Arg0: &Table<I32, TickInfo>)\n\t6: Pop\n\t7: Call i64::zero(): I64\n\t8: StLoc[2](loc0: I64)\n\t9: Branch(16)\nB2:\n\t10: MoveLoc[0](Arg0: &Table<I32, TickInfo>)\n\t11: MoveLoc[1](Arg1: I32)\n\t12: Call table::borrow<I32, TickInfo>(&Table<I32, TickInfo>, I32): &TickInfo\n\t13: ImmBorrowField[5](TickInfo.tick_cumulative_out_side: I64)\n\t14: ReadRef\n\t15: StLoc[2](loc0: I64)\nB3:\n\t16: MoveLoc[2](loc0: I64)\n\t17: Ret\n}\n\npublic get_seconds_per_liquidity_out_side(Arg0: &Table<I32, TickInfo>, Arg1: I32): u256 {\nL2:\tloc0: u256\nB0:\n\t0: CopyLoc[0](Arg0: &Table<I32, TickInfo>)\n\t1: CopyLoc[1](Arg1: I32)\n\t2: Call is_initialized(&Table<I32, TickInfo>, I32): bool\n\t3: Not\n\t4: BrFalse(10)\nB1:\n\t5: MoveLoc[0](Arg0: &Table<I32, TickInfo>)\n\t6: Pop\n\t7: LdU256(0)\n\t8: StLoc[2](loc0: u256)\n\t9: Branch(16)\nB2:\n\t10: MoveLoc[0](Arg0: &Table<I32, TickInfo>)\n\t11: MoveLoc[1](Arg1: I32)\n\t12: Call table::borrow<I32, TickInfo>(&Table<I32, TickInfo>, I32): &TickInfo\n\t13: ImmBorrowField[6](TickInfo.seconds_per_liquidity_out_side: u256)\n\t14: ReadRef\n\t15: StLoc[2](loc0: u256)\nB3:\n\t16: MoveLoc[2](loc0: u256)\n\t17: Ret\n}\n\npublic get_seconds_out_side(Arg0: &Table<I32, TickInfo>, Arg1: I32): u64 {\nL2:\tloc0: u64\nB0:\n\t0: CopyLoc[0](Arg0: &Table<I32, TickInfo>)\n\t1: CopyLoc[1](Arg1: I32)\n\t2: Call is_initialized(&Table<I32, TickInfo>, I32): bool\n\t3: Not\n\t4: BrFalse(10)\nB1:\n\t5: MoveLoc[0](Arg0: &Table<I32, TickInfo>)\n\t6: Pop\n\t7: LdU64(0)\n\t8: StLoc[2](loc0: u64)\n\t9: Branch(16)\nB2:\n\t10: MoveLoc[0](Arg0: &Table<I32, TickInfo>)\n\t11: MoveLoc[1](Arg1: I32)\n\t12: Call table::borrow<I32, TickInfo>(&Table<I32, TickInfo>, I32): &TickInfo\n\t13: ImmBorrowField[7](TickInfo.seconds_out_side: u64)\n\t14: ReadRef\n\t15: StLoc[2](loc0: u64)\nB3:\n\t16: MoveLoc[2](loc0: u64)\n\t17: Ret\n}\n\ntry_borrow_mut_tick(Arg0: &mut Table<I32, TickInfo>, Arg1: I32): &mut TickInfo {\nL2:\tloc0: I32\nL3:\tloc1: I128\nL4:\tloc2: vector<u128>\nL5:\tloc3: I64\nL6:\tloc4: TickInfo\nB0:\n\t0: CopyLoc[0](Arg0: &mut Table<I32, TickInfo>)\n\t1: CopyLoc[1](Arg1: I32)\n\t2: StLoc[2](loc0: I32)\n\t3: FreezeRef\n\t4: MoveLoc[2](loc0: I32)\n\t5: Call table::contains<I32, TickInfo>(&Table<I32, TickInfo>, I32): bool\n\t6: Not\n\t7: BrFalse(28)\nB1:\n\t8: Call i128::zero(): I128\n\t9: StLoc[3](loc1: I128)\n\t10: VecPack(5, 0)\n\t11: StLoc[4](loc2: vector<u128>)\n\t12: Call i64::zero(): I64\n\t13: StLoc[5](loc3: I64)\n\t14: LdU128(0)\n\t15: MoveLoc[3](loc1: I128)\n\t16: LdU128(0)\n\t17: LdU128(0)\n\t18: MoveLoc[4](loc2: vector<u128>)\n\t19: MoveLoc[5](loc3: I64)\n\t20: LdU256(0)\n\t21: LdU64(0)\n\t22: Pack[0](TickInfo)\n\t23: StLoc[6](loc4: TickInfo)\n\t24: CopyLoc[0](Arg0: &mut Table<I32, TickInfo>)\n\t25: CopyLoc[1](Arg1: I32)\n\t26: MoveLoc[6](loc4: TickInfo)\n\t27: Call table::add<I32, TickInfo>(&mut Table<I32, TickInfo>, I32, TickInfo)\nB2:\n\t28: MoveLoc[0](Arg0: &mut Table<I32, TickInfo>)\n\t29: MoveLoc[1](Arg1: I32)\n\t30: Call table::borrow_mut<I32, TickInfo>(&mut Table<I32, TickInfo>, I32): &mut TickInfo\n\t31: Ret\n}\n\npublic tick_spacing_to_max_liquidity_per_tick(Arg0: u32): u128 {\nL1:\tloc0: I32\nL2:\tloc1: u32\nL3:\tloc2: I32\nB0:\n\t0: MoveLoc[0](Arg0: u32)\n\t1: Call i32::from(u32): I32\n\t2: StLoc[3](loc2: I32)\n\t3: Call tick_math::min_tick(): I32\n\t4: CopyLoc[3](loc2: I32)\n\t5: Call i32::div(I32, I32): I32\n\t6: CopyLoc[3](loc2: I32)\n\t7: Call i32::mul(I32, I32): I32\n\t8: StLoc[1](loc0: I32)\n\t9: Call tick_math::max_tick(): I32\n\t10: CopyLoc[3](loc2: I32)\n\t11: Call i32::div(I32, I32): I32\n\t12: CopyLoc[3](loc2: I32)\n\t13: Call i32::mul(I32, I32): I32\n\t14: MoveLoc[1](loc0: I32)\n\t15: Call i32::sub(I32, I32): I32\n\t16: MoveLoc[3](loc2: I32)\n\t17: Call i32::div(I32, I32): I32\n\t18: Call i32::as_u32(I32): u32\n\t19: LdU32(1)\n\t20: Add\n\t21: StLoc[2](loc1: u32)\n\t22: Call constants::get_max_u128(): u128\n\t23: MoveLoc[2](loc1: u32)\n\t24: CastU128\n\t25: Div\n\t26: Ret\n}\n\npublic get_fee_and_reward_growths_inside(Arg0: &Table<I32, TickInfo>, Arg1: I32, Arg2: I32, Arg3: I32, Arg4: u128, Arg5: u128, Arg6: vector<u128>): u128 * u128 * vector<u128> {\nL7:\tloc0: u128\nL8:\tloc1: u128\nL9:\tloc2: vector<u128>\nL10:\tloc3: u128\nL11:\tloc4: u128\nL12:\tloc5: vector<u128>\nL13:\tloc6: u128\nL14:\tloc7: u128\nL15:\tloc8: u128\nL16:\tloc9: u128\nL17:\tloc10: u128\nL18:\tloc11: u128\nL19:\tloc12: vector<u128>\nL20:\tloc13: vector<u128>\nL21:\tloc14: vector<u128>\nL22:\tloc15: u128\nL23:\tloc16: u128\nL24:\tloc17: vector<u128>\nB0:\n\t0: CopyLoc[0](Arg0: &Table<I32, TickInfo>)\n\t1: CopyLoc[1](Arg1: I32)\n\t2: Call get_fee_and_reward_growths_outside(&Table<I32, TickInfo>, I32): u128 * u128 * vector<u128>\n\t3: StLoc[19](loc12: vector<u128>)\n\t4: StLoc[18](loc11: u128)\n\t5: StLoc[17](loc10: u128)\n\t6: MoveLoc[0](Arg0: &Table<I32, TickInfo>)\n\t7: CopyLoc[2](Arg2: I32)\n\t8: Call get_fee_and_reward_growths_outside(&Table<I32, TickInfo>, I32): u128 * u128 * vector<u128>\n\t9: StLoc[24](loc17: vector<u128>)\n\t10: StLoc[23](loc16: u128)\n\t11: StLoc[22](loc15: u128)\n\t12: CopyLoc[3](Arg3: I32)\n\t13: MoveLoc[1](Arg1: I32)\n\t14: Call i32::gte(I32, I32): bool\n\t15: BrFalse(23)\nB1:\n\t16: MoveLoc[17](loc10: u128)\n\t17: MoveLoc[18](loc11: u128)\n\t18: MoveLoc[19](loc12: vector<u128>)\n\t19: StLoc[9](loc2: vector<u128>)\n\t20: StLoc[8](loc1: u128)\n\t21: StLoc[7](loc0: u128)\n\t22: Branch(35)\nB2:\n\t23: CopyLoc[4](Arg4: u128)\n\t24: MoveLoc[17](loc10: u128)\n\t25: Call full_math_u128::wrapping_sub(u128, u128): u128\n\t26: CopyLoc[5](Arg5: u128)\n\t27: MoveLoc[18](loc11: u128)\n\t28: Call full_math_u128::wrapping_sub(u128, u128): u128\n\t29: CopyLoc[6](Arg6: vector<u128>)\n\t30: MoveLoc[19](loc12: vector<u128>)\n\t31: Call compute_reward_growths(vector<u128>, vector<u128>): vector<u128>\n\t32: StLoc[9](loc2: vector<u128>)\n\t33: StLoc[8](loc1: u128)\n\t34: StLoc[7](loc0: u128)\nB3:\n\t35: MoveLoc[7](loc0: u128)\n\t36: MoveLoc[8](loc1: u128)\n\t37: MoveLoc[9](loc2: vector<u128>)\n\t38: StLoc[21](loc14: vector<u128>)\n\t39: StLoc[16](loc9: u128)\n\t40: StLoc[15](loc8: u128)\n\t41: MoveLoc[3](Arg3: I32)\n\t42: MoveLoc[2](Arg2: I32)\n\t43: Call i32::lt(I32, I32): bool\n\t44: BrFalse(52)\nB4:\n\t45: MoveLoc[22](loc15: u128)\n\t46: MoveLoc[23](loc16: u128)\n\t47: MoveLoc[24](loc17: vector<u128>)\n\t48: StLoc[12](loc5: vector<u128>)\n\t49: StLoc[11](loc4: u128)\n\t50: StLoc[10](loc3: u128)\n\t51: Branch(64)\nB5:\n\t52: CopyLoc[4](Arg4: u128)\n\t53: MoveLoc[22](loc15: u128)\n\t54: Call full_math_u128::wrapping_sub(u128, u128): u128\n\t55: CopyLoc[5](Arg5: u128)\n\t56: MoveLoc[23](loc16: u128)\n\t57: Call full_math_u128::wrapping_sub(u128, u128): u128\n\t58: CopyLoc[6](Arg6: vector<u128>)\n\t59: MoveLoc[24](loc17: vector<u128>)\n\t60: Call compute_reward_growths(vector<u128>, vector<u128>): vector<u128>\n\t61: StLoc[12](loc5: vector<u128>)\n\t62: StLoc[11](loc4: u128)\n\t63: StLoc[10](loc3: u128)\nB6:\n\t64: MoveLoc[10](loc3: u128)\n\t65: MoveLoc[11](loc4: u128)\n\t66: MoveLoc[12](loc5: vector<u128>)\n\t67: StLoc[20](loc13: vector<u128>)\n\t68: StLoc[14](loc7: u128)\n\t69: StLoc[13](loc6: u128)\n\t70: MoveLoc[4](Arg4: u128)\n\t71: MoveLoc[15](loc8: u128)\n\t72: Call full_math_u128::wrapping_sub(u128, u128): u128\n\t73: MoveLoc[13](loc6: u128)\n\t74: Call full_math_u128::wrapping_sub(u128, u128): u128\n\t75: MoveLoc[5](Arg5: u128)\n\t76: MoveLoc[16](loc9: u128)\n\t77: Call full_math_u128::wrapping_sub(u128, u128): u128\n\t78: MoveLoc[14](loc7: u128)\n\t79: Call full_math_u128::wrapping_sub(u128, u128): u128\n\t80: MoveLoc[6](Arg6: vector<u128>)\n\t81: MoveLoc[21](loc14: vector<u128>)\n\t82: Call compute_reward_growths(vector<u128>, vector<u128>): vector<u128>\n\t83: MoveLoc[20](loc13: vector<u128>)\n\t84: Call compute_reward_growths(vector<u128>, vector<u128>): vector<u128>\n\t85: Ret\n}\n\npublic(friend) update(Arg0: &mut Table<I32, TickInfo>, Arg1: I32, Arg2: I32, Arg3: I128, Arg4: u128, Arg5: u128, Arg6: vector<u128>, Arg7: u256, Arg8: I64, Arg9: u64, Arg10: bool, Arg11: u128): bool {\nL12:\tloc0: I128\nL13:\tloc1: bool\nL14:\tloc2: u64\nL15:\tloc3: u64\nL16:\tloc4: u128\nL17:\tloc5: u128\nL18:\tloc6: &mut TickInfo\nB0:\n\t0: MoveLoc[0](Arg0: &mut Table<I32, TickInfo>)\n\t1: CopyLoc[1](Arg1: I32)\n\t2: Call try_borrow_mut_tick(&mut Table<I32, TickInfo>, I32): &mut TickInfo\n\t3: StLoc[18](loc6: &mut TickInfo)\n\t4: CopyLoc[18](loc6: &mut TickInfo)\n\t5: ImmBorrowField[3](TickInfo.liquidity_gross: u128)\n\t6: ReadRef\n\t7: StLoc[17](loc5: u128)\n\t8: CopyLoc[17](loc5: u128)\n\t9: CopyLoc[3](Arg3: I128)\n\t10: Call liquidity_math::add_delta(u128, I128): u128\n\t11: StLoc[16](loc4: u128)\n\t12: CopyLoc[16](loc4: u128)\n\t13: MoveLoc[11](Arg11: u128)\n\t14: Gt\n\t15: BrFalse(20)\nB1:\n\t16: MoveLoc[18](loc6: &mut TickInfo)\n\t17: Pop\n\t18: LdConst[0](u64: 0)\n\t19: Abort\nB2:\n\t20: CopyLoc[16](loc4: u128)\n\t21: LdU128(0)\n\t22: Eq\n\t23: CopyLoc[17](loc5: u128)\n\t24: LdU128(0)\n\t25: Eq\n\t26: Neq\n\t27: StLoc[13](loc1: bool)\n\t28: MoveLoc[17](loc5: u128)\n\t29: LdU128(0)\n\t30: Eq\n\t31: BrFalse(80)\nB3:\n\t32: MoveLoc[1](Arg1: I32)\n\t33: MoveLoc[2](Arg2: I32)\n\t34: Call i32::lte(I32, I32): bool\n\t35: BrFalse(61)\nB4:\n\t36: MoveLoc[4](Arg4: u128)\n\t37: CopyLoc[18](loc6: &mut TickInfo)\n\t38: MutBorrowField[0](TickInfo.fee_growth_outside_x: u128)\n\t39: WriteRef\n\t40: MoveLoc[5](Arg5: u128)\n\t41: CopyLoc[18](loc6: &mut TickInfo)\n\t42: MutBorrowField[1](TickInfo.fee_growth_outside_y: u128)\n\t43: WriteRef\n\t44: MoveLoc[7](Arg7: u256)\n\t45: CopyLoc[18](loc6: &mut TickInfo)\n\t46: MutBorrowField[6](TickInfo.seconds_per_liquidity_out_side: u256)\n\t47: WriteRef\n\t48: MoveLoc[8](Arg8: I64)\n\t49: CopyLoc[18](loc6: &mut TickInfo)\n\t50: MutBorrowField[5](TickInfo.tick_cumulative_out_side: I64)\n\t51: WriteRef\n\t52: MoveLoc[9](Arg9: u64)\n\t53: CopyLoc[18](loc6: &mut TickInfo)\n\t54: MutBorrowField[7](TickInfo.seconds_out_side: u64)\n\t55: WriteRef\n\t56: MoveLoc[6](Arg6: vector<u128>)\n\t57: CopyLoc[18](loc6: &mut TickInfo)\n\t58: MutBorrowField[2](TickInfo.reward_growths_outside: vector<u128>)\n\t59: WriteRef\n\t60: Branch(80)\nB5:\n\t61: LdU64(0)\n\t62: ImmBorrowLoc[6](Arg6: vector<u128>)\n\t63: VecLen(5)\n\t64: StLoc[15](loc3: u64)\n\t65: StLoc[14](loc2: u64)\nB6:\n\t66: CopyLoc[14](loc2: u64)\n\t67: CopyLoc[15](loc3: u64)\n\t68: Lt\n\t69: BrFalse(80)\nB7:\n\t70: Branch(71)\nB8:\n\t71: CopyLoc[18](loc6: &mut TickInfo)\n\t72: MutBorrowField[2](TickInfo.reward_growths_outside: vector<u128>)\n\t73: LdU128(0)\n\t74: VecPushBack(5)\n\t75: MoveLoc[14](loc2: u64)\n\t76: LdU64(1)\n\t77: Add\n\t78: StLoc[14](loc2: u64)\n\t79: Branch(66)\nB9:\n\t80: MoveLoc[16](loc4: u128)\n\t81: CopyLoc[18](loc6: &mut TickInfo)\n\t82: MutBorrowField[3](TickInfo.liquidity_gross: u128)\n\t83: WriteRef\n\t84: MoveLoc[10](Arg10: bool)\n\t85: BrFalse(93)\nB10:\n\t86: CopyLoc[18](loc6: &mut TickInfo)\n\t87: ImmBorrowField[4](TickInfo.liquidity_net: I128)\n\t88: ReadRef\n\t89: MoveLoc[3](Arg3: I128)\n\t90: Call i128::sub(I128, I128): I128\n\t91: StLoc[12](loc0: I128)\n\t92: Branch(99)\nB11:\n\t93: CopyLoc[18](loc6: &mut TickInfo)\n\t94: ImmBorrowField[4](TickInfo.liquidity_net: I128)\n\t95: ReadRef\n\t96: MoveLoc[3](Arg3: I128)\n\t97: Call i128::add(I128, I128): I128\n\t98: StLoc[12](loc0: I128)\nB12:\n\t99: MoveLoc[12](loc0: I128)\n\t100: MoveLoc[18](loc6: &mut TickInfo)\n\t101: MutBorrowField[4](TickInfo.liquidity_net: I128)\n\t102: WriteRef\n\t103: MoveLoc[13](loc1: bool)\n\t104: Ret\n}\n\npublic(friend) clear(Arg0: &mut Table<I32, TickInfo>, Arg1: I32) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut Table<I32, TickInfo>)\n\t1: MoveLoc[1](Arg1: I32)\n\t2: Call table::remove<I32, TickInfo>(&mut Table<I32, TickInfo>, I32): TickInfo\n\t3: Pop\n\t4: Ret\n}\n\npublic(friend) cross(Arg0: &mut Table<I32, TickInfo>, Arg1: I32, Arg2: u128, Arg3: u128, Arg4: vector<u128>, Arg5: u256, Arg6: I64, Arg7: u64): I128 {\nL8:\tloc0: &mut TickInfo\nB0:\n\t0: MoveLoc[0](Arg0: &mut Table<I32, TickInfo>)\n\t1: MoveLoc[1](Arg1: I32)\n\t2: Call try_borrow_mut_tick(&mut Table<I32, TickInfo>, I32): &mut TickInfo\n\t3: StLoc[8](loc0: &mut TickInfo)\n\t4: MoveLoc[2](Arg2: u128)\n\t5: CopyLoc[8](loc0: &mut TickInfo)\n\t6: ImmBorrowField[0](TickInfo.fee_growth_outside_x: u128)\n\t7: ReadRef\n\t8: Call full_math_u128::wrapping_sub(u128, u128): u128\n\t9: CopyLoc[8](loc0: &mut TickInfo)\n\t10: MutBorrowField[0](TickInfo.fee_growth_outside_x: u128)\n\t11: WriteRef\n\t12: MoveLoc[3](Arg3: u128)\n\t13: CopyLoc[8](loc0: &mut TickInfo)\n\t14: ImmBorrowField[1](TickInfo.fee_growth_outside_y: u128)\n\t15: ReadRef\n\t16: Call full_math_u128::wrapping_sub(u128, u128): u128\n\t17: CopyLoc[8](loc0: &mut TickInfo)\n\t18: MutBorrowField[1](TickInfo.fee_growth_outside_y: u128)\n\t19: WriteRef\n\t20: MoveLoc[4](Arg4: vector<u128>)\n\t21: CopyLoc[8](loc0: &mut TickInfo)\n\t22: ImmBorrowField[2](TickInfo.reward_growths_outside: vector<u128>)\n\t23: ReadRef\n\t24: Call compute_reward_growths(vector<u128>, vector<u128>): vector<u128>\n\t25: CopyLoc[8](loc0: &mut TickInfo)\n\t26: MutBorrowField[2](TickInfo.reward_growths_outside: vector<u128>)\n\t27: WriteRef\n\t28: MoveLoc[5](Arg5: u256)\n\t29: CopyLoc[8](loc0: &mut TickInfo)\n\t30: ImmBorrowField[6](TickInfo.seconds_per_liquidity_out_side: u256)\n\t31: ReadRef\n\t32: Sub\n\t33: CopyLoc[8](loc0: &mut TickInfo)\n\t34: MutBorrowField[6](TickInfo.seconds_per_liquidity_out_side: u256)\n\t35: WriteRef\n\t36: MoveLoc[6](Arg6: I64)\n\t37: CopyLoc[8](loc0: &mut TickInfo)\n\t38: ImmBorrowField[5](TickInfo.tick_cumulative_out_side: I64)\n\t39: ReadRef\n\t40: Call i64::sub(I64, I64): I64\n\t41: CopyLoc[8](loc0: &mut TickInfo)\n\t42: MutBorrowField[5](TickInfo.tick_cumulative_out_side: I64)\n\t43: WriteRef\n\t44: MoveLoc[7](Arg7: u64)\n\t45: CopyLoc[8](loc0: &mut TickInfo)\n\t46: ImmBorrowField[7](TickInfo.seconds_out_side: u64)\n\t47: ReadRef\n\t48: Sub\n\t49: CopyLoc[8](loc0: &mut TickInfo)\n\t50: MutBorrowField[7](TickInfo.seconds_out_side: u64)\n\t51: WriteRef\n\t52: MoveLoc[8](loc0: &mut TickInfo)\n\t53: ImmBorrowField[4](TickInfo.liquidity_net: I128)\n\t54: ReadRef\n\t55: Ret\n}\n\ncompute_reward_growths(Arg0: vector<u128>, Arg1: vector<u128>): vector<u128> {\nL2:\tloc0: u128\nL3:\tloc1: u64\nL4:\tloc2: u64\nL5:\tloc3: vector<u128>\nL6:\tloc4: u128\nB0:\n\t0: LdU64(0)\n\t1: ImmBorrowLoc[0](Arg0: vector<u128>)\n\t2: VecLen(5)\n\t3: StLoc[4](loc2: u64)\n\t4: StLoc[3](loc1: u64)\n\t5: VecPack(5, 0)\n\t6: StLoc[5](loc3: vector<u128>)\nB1:\n\t7: CopyLoc[3](loc1: u64)\n\t8: CopyLoc[4](loc2: u64)\n\t9: Lt\n\t10: BrFalse(40)\nB2:\n\t11: Branch(12)\nB3:\n\t12: CopyLoc[3](loc1: u64)\n\t13: ImmBorrowLoc[1](Arg1: vector<u128>)\n\t14: VecLen(5)\n\t15: Ge\n\t16: BrFalse(20)\nB4:\n\t17: LdU128(0)\n\t18: StLoc[2](loc0: u128)\n\t19: Branch(25)\nB5:\n\t20: ImmBorrowLoc[1](Arg1: vector<u128>)\n\t21: CopyLoc[3](loc1: u64)\n\t22: VecImmBorrow(5)\n\t23: ReadRef\n\t24: StLoc[2](loc0: u128)\nB6:\n\t25: MoveLoc[2](loc0: u128)\n\t26: StLoc[6](loc4: u128)\n\t27: MutBorrowLoc[5](loc3: vector<u128>)\n\t28: ImmBorrowLoc[0](Arg0: vector<u128>)\n\t29: CopyLoc[3](loc1: u64)\n\t30: VecImmBorrow(5)\n\t31: ReadRef\n\t32: MoveLoc[6](loc4: u128)\n\t33: Call full_math_u128::wrapping_sub(u128, u128): u128\n\t34: VecPushBack(5)\n\t35: MoveLoc[3](loc1: u64)\n\t36: LdU64(1)\n\t37: Add\n\t38: StLoc[3](loc1: u64)\n\t39: Branch(7)\nB7:\n\t40: MoveLoc[5](loc3: vector<u128>)\n\t41: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n\t3 => u64: 3\n\t4 => u64: 4\n]\n}\n",
      "tick_bitmap": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.tick_bitmap {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::bit_math;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::caster;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::constants;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i32;\nuse 0000000000000000000000000000000000000000000000000000000000000002::table;\n\nposition(Arg0: I32): I32 * u8 {\nL1:\tloc0: u8\nL2:\tloc1: I32\nB0:\n\t0: CopyLoc[0](Arg0: I32)\n\t1: LdU8(8)\n\t2: Call i32::shr(I32, u8): I32\n\t3: StLoc[2](loc1: I32)\n\t4: MoveLoc[0](Arg0: I32)\n\t5: LdU32(256)\n\t6: Call i32::from(u32): I32\n\t7: Call i32::mod(I32, I32): I32\n\t8: Call caster::cast_to_u8(I32): u8\n\t9: StLoc[1](loc0: u8)\n\t10: MoveLoc[2](loc1: I32)\n\t11: MoveLoc[1](loc0: u8)\n\t12: Ret\n}\n\ntry_get_tick_word(Arg0: &Table<I32, u256>, Arg1: I32): u256 {\nL2:\tloc0: u256\nB0:\n\t0: CopyLoc[0](Arg0: &Table<I32, u256>)\n\t1: CopyLoc[1](Arg1: I32)\n\t2: Call table::contains<I32, u256>(&Table<I32, u256>, I32): bool\n\t3: Not\n\t4: BrFalse(10)\nB1:\n\t5: MoveLoc[0](Arg0: &Table<I32, u256>)\n\t6: Pop\n\t7: LdU256(0)\n\t8: StLoc[2](loc0: u256)\n\t9: Branch(15)\nB2:\n\t10: MoveLoc[0](Arg0: &Table<I32, u256>)\n\t11: MoveLoc[1](Arg1: I32)\n\t12: Call table::borrow<I32, u256>(&Table<I32, u256>, I32): &u256\n\t13: ReadRef\n\t14: StLoc[2](loc0: u256)\nB3:\n\t15: MoveLoc[2](loc0: u256)\n\t16: Ret\n}\n\ntry_borrow_mut_tick_word(Arg0: &mut Table<I32, u256>, Arg1: I32): &mut u256 {\nL2:\tloc0: I32\nB0:\n\t0: CopyLoc[0](Arg0: &mut Table<I32, u256>)\n\t1: CopyLoc[1](Arg1: I32)\n\t2: StLoc[2](loc0: I32)\n\t3: FreezeRef\n\t4: MoveLoc[2](loc0: I32)\n\t5: Call table::contains<I32, u256>(&Table<I32, u256>, I32): bool\n\t6: Not\n\t7: BrFalse(12)\nB1:\n\t8: CopyLoc[0](Arg0: &mut Table<I32, u256>)\n\t9: CopyLoc[1](Arg1: I32)\n\t10: LdU256(0)\n\t11: Call table::add<I32, u256>(&mut Table<I32, u256>, I32, u256)\nB2:\n\t12: MoveLoc[0](Arg0: &mut Table<I32, u256>)\n\t13: MoveLoc[1](Arg1: I32)\n\t14: Call table::borrow_mut<I32, u256>(&mut Table<I32, u256>, I32): &mut u256\n\t15: Ret\n}\n\npublic(friend) flip_tick(Arg0: &mut Table<I32, u256>, Arg1: I32, Arg2: u32) {\nL3:\tloc0: u8\nL4:\tloc1: u256\nL5:\tloc2: &mut u256\nL6:\tloc3: I32\nB0:\n\t0: CopyLoc[1](Arg1: I32)\n\t1: Call i32::abs_u32(I32): u32\n\t2: CopyLoc[2](Arg2: u32)\n\t3: Mod\n\t4: LdU32(0)\n\t5: Eq\n\t6: BrFalse(8)\nB1:\n\t7: Branch(12)\nB2:\n\t8: MoveLoc[0](Arg0: &mut Table<I32, u256>)\n\t9: Pop\n\t10: LdConst[0](u64: 0)\n\t11: Abort\nB3:\n\t12: MoveLoc[1](Arg1: I32)\n\t13: MoveLoc[2](Arg2: u32)\n\t14: Call i32::from(u32): I32\n\t15: Call i32::div(I32, I32): I32\n\t16: Call position(I32): I32 * u8\n\t17: StLoc[3](loc0: u8)\n\t18: StLoc[6](loc3: I32)\n\t19: LdU256(1)\n\t20: MoveLoc[3](loc0: u8)\n\t21: Shl\n\t22: StLoc[4](loc1: u256)\n\t23: MoveLoc[0](Arg0: &mut Table<I32, u256>)\n\t24: MoveLoc[6](loc3: I32)\n\t25: Call try_borrow_mut_tick_word(&mut Table<I32, u256>, I32): &mut u256\n\t26: StLoc[5](loc2: &mut u256)\n\t27: CopyLoc[5](loc2: &mut u256)\n\t28: ReadRef\n\t29: MoveLoc[4](loc1: u256)\n\t30: Xor\n\t31: MoveLoc[5](loc2: &mut u256)\n\t32: WriteRef\n\t33: Ret\n}\n\npublic next_initialized_tick_within_one_word(Arg0: &Table<I32, u256>, Arg1: I32, Arg2: u32, Arg3: bool): I32 * bool {\nL4:\tloc0: bool\nL5:\tloc1: I32\nL6:\tloc2: I32\nL7:\tloc3: I32\nL8:\tloc4: bool\nL9:\tloc5: bool\nL10:\tloc6: bool\nL11:\tloc7: u8\nL12:\tloc8: u8\nL13:\tloc9: I32\nL14:\tloc10: u256\nL15:\tloc11: u256\nL16:\tloc12: u256\nL17:\tloc13: u256\nL18:\tloc14: I32\nL19:\tloc15: I32\nL20:\tloc16: I32\nB0:\n\t0: CopyLoc[2](Arg2: u32)\n\t1: Call i32::from(u32): I32\n\t2: StLoc[18](loc14: I32)\n\t3: CopyLoc[1](Arg1: I32)\n\t4: CopyLoc[18](loc14: I32)\n\t5: Call i32::div(I32, I32): I32\n\t6: StLoc[13](loc9: I32)\n\t7: CopyLoc[1](Arg1: I32)\n\t8: Call i32::is_neg(I32): bool\n\t9: BrFalse(18)\nB1:\n\t10: MoveLoc[1](Arg1: I32)\n\t11: Call i32::abs_u32(I32): u32\n\t12: MoveLoc[2](Arg2: u32)\n\t13: Mod\n\t14: LdU32(0)\n\t15: Neq\n\t16: StLoc[4](loc0: bool)\n\t17: Branch(20)\nB2:\n\t18: LdFalse\n\t19: StLoc[4](loc0: bool)\nB3:\n\t20: MoveLoc[4](loc0: bool)\n\t21: BrFalse(27)\nB4:\n\t22: MoveLoc[13](loc9: I32)\n\t23: LdU32(1)\n\t24: Call i32::from(u32): I32\n\t25: Call i32::sub(I32, I32): I32\n\t26: StLoc[13](loc9: I32)\nB5:\n\t27: MoveLoc[3](Arg3: bool)\n\t28: BrFalse(82)\nB6:\n\t29: CopyLoc[13](loc9: I32)\n\t30: Call position(I32): I32 * u8\n\t31: StLoc[11](loc7: u8)\n\t32: StLoc[19](loc15: I32)\n\t33: LdU256(1)\n\t34: CopyLoc[11](loc7: u8)\n\t35: Shl\n\t36: LdU256(1)\n\t37: Sub\n\t38: LdU256(1)\n\t39: CopyLoc[11](loc7: u8)\n\t40: Shl\n\t41: Add\n\t42: StLoc[14](loc10: u256)\n\t43: MoveLoc[0](Arg0: &Table<I32, u256>)\n\t44: MoveLoc[19](loc15: I32)\n\t45: Call try_get_tick_word(&Table<I32, u256>, I32): u256\n\t46: MoveLoc[14](loc10: u256)\n\t47: BitAnd\n\t48: StLoc[16](loc12: u256)\n\t49: CopyLoc[16](loc12: u256)\n\t50: LdU256(0)\n\t51: Neq\n\t52: StLoc[9](loc5: bool)\n\t53: CopyLoc[9](loc5: bool)\n\t54: BrFalse(69)\nB7:\n\t55: MoveLoc[13](loc9: I32)\n\t56: MoveLoc[11](loc7: u8)\n\t57: CastU32\n\t58: Call i32::from(u32): I32\n\t59: MoveLoc[16](loc12: u256)\n\t60: Call bit_math::get_most_significant_bit(u256): u8\n\t61: CastU32\n\t62: Call i32::from(u32): I32\n\t63: Call i32::sub(I32, I32): I32\n\t64: Call i32::sub(I32, I32): I32\n\t65: MoveLoc[18](loc14: I32)\n\t66: Call i32::mul(I32, I32): I32\n\t67: StLoc[5](loc1: I32)\n\t68: Branch(77)\nB8:\n\t69: MoveLoc[13](loc9: I32)\n\t70: MoveLoc[11](loc7: u8)\n\t71: CastU32\n\t72: Call i32::from(u32): I32\n\t73: Call i32::sub(I32, I32): I32\n\t74: MoveLoc[18](loc14: I32)\n\t75: Call i32::mul(I32, I32): I32\n\t76: StLoc[5](loc1: I32)\nB9:\n\t77: MoveLoc[5](loc1: I32)\n\t78: MoveLoc[9](loc5: bool)\n\t79: StLoc[8](loc4: bool)\n\t80: StLoc[7](loc3: I32)\n\t81: Branch(145)\nB10:\n\t82: CopyLoc[13](loc9: I32)\n\t83: LdU32(1)\n\t84: Call i32::from(u32): I32\n\t85: Call i32::add(I32, I32): I32\n\t86: Call position(I32): I32 * u8\n\t87: StLoc[12](loc8: u8)\n\t88: StLoc[20](loc16: I32)\n\t89: LdU256(1)\n\t90: CopyLoc[12](loc8: u8)\n\t91: Shl\n\t92: LdU256(1)\n\t93: Sub\n\t94: Call constants::get_max_u256(): u256\n\t95: Xor\n\t96: StLoc[15](loc11: u256)\n\t97: MoveLoc[0](Arg0: &Table<I32, u256>)\n\t98: MoveLoc[20](loc16: I32)\n\t99: Call try_get_tick_word(&Table<I32, u256>, I32): u256\n\t100: MoveLoc[15](loc11: u256)\n\t101: BitAnd\n\t102: StLoc[17](loc13: u256)\n\t103: CopyLoc[17](loc13: u256)\n\t104: LdU256(0)\n\t105: Neq\n\t106: StLoc[10](loc6: bool)\n\t107: CopyLoc[10](loc6: bool)\n\t108: BrFalse(126)\nB11:\n\t109: MoveLoc[13](loc9: I32)\n\t110: LdU32(1)\n\t111: Call i32::from(u32): I32\n\t112: Call i32::add(I32, I32): I32\n\t113: MoveLoc[17](loc13: u256)\n\t114: Call bit_math::get_least_significant_bit(u256): u8\n\t115: CastU32\n\t116: Call i32::from(u32): I32\n\t117: MoveLoc[12](loc8: u8)\n\t118: CastU32\n\t119: Call i32::from(u32): I32\n\t120: Call i32::sub(I32, I32): I32\n\t121: Call i32::add(I32, I32): I32\n\t122: MoveLoc[18](loc14: I32)\n\t123: Call i32::mul(I32, I32): I32\n\t124: StLoc[6](loc2: I32)\n\t125: Branch(141)\nB12:\n\t126: MoveLoc[13](loc9: I32)\n\t127: LdU32(1)\n\t128: Call i32::from(u32): I32\n\t129: Call i32::add(I32, I32): I32\n\t130: Call constants::get_max_u8(): u8\n\t131: CastU32\n\t132: Call i32::from(u32): I32\n\t133: MoveLoc[12](loc8: u8)\n\t134: CastU32\n\t135: Call i32::from(u32): I32\n\t136: Call i32::sub(I32, I32): I32\n\t137: Call i32::add(I32, I32): I32\n\t138: MoveLoc[18](loc14: I32)\n\t139: Call i32::mul(I32, I32): I32\n\t140: StLoc[6](loc2: I32)\nB13:\n\t141: MoveLoc[6](loc2: I32)\n\t142: MoveLoc[10](loc6: bool)\n\t143: StLoc[8](loc4: bool)\n\t144: StLoc[7](loc3: I32)\nB14:\n\t145: MoveLoc[7](loc3: I32)\n\t146: MoveLoc[8](loc4: bool)\n\t147: Ret\n}\n\nConstants [\n\t0 => u64: 0\n]\n}\n",
      "tick_math": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.tick_math {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::full_math_u128;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i128;\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::i32;\n\npublic max_sqrt_price(): u128 {\nB0:\n\t0: LdConst[1](u128: 7922..)\n\t1: Ret\n}\n\npublic min_sqrt_price(): u128 {\nB0:\n\t0: LdConst[2](u128: 4295..)\n\t1: Ret\n}\n\npublic max_tick(): I32 {\nB0:\n\t0: LdConst[0](u32: 443636)\n\t1: Call i32::from(u32): I32\n\t2: Ret\n}\n\npublic min_tick(): I32 {\nB0:\n\t0: LdConst[0](u32: 443636)\n\t1: Call i32::neg_from(u32): I32\n\t2: Ret\n}\n\npublic tick_bound(): u32 {\nB0:\n\t0: LdConst[0](u32: 443636)\n\t1: Ret\n}\n\npublic get_sqrt_price_at_tick(Arg0: I32): u128 {\nL1:\tloc0: bool\nL2:\tloc1: u128\nB0:\n\t0: CopyLoc[0](Arg0: I32)\n\t1: Call min_tick(): I32\n\t2: Call i32::gte(I32, I32): bool\n\t3: BrFalse(9)\nB1:\n\t4: CopyLoc[0](Arg0: I32)\n\t5: Call max_tick(): I32\n\t6: Call i32::lte(I32, I32): bool\n\t7: StLoc[1](loc0: bool)\n\t8: Branch(11)\nB2:\n\t9: LdFalse\n\t10: StLoc[1](loc0: bool)\nB3:\n\t11: MoveLoc[1](loc0: bool)\n\t12: BrFalse(14)\nB4:\n\t13: Branch(16)\nB5:\n\t14: LdConst[3](u64: 1)\n\t15: Abort\nB6:\n\t16: CopyLoc[0](Arg0: I32)\n\t17: Call i32::is_neg(I32): bool\n\t18: BrFalse(23)\nB7:\n\t19: MoveLoc[0](Arg0: I32)\n\t20: Call get_sqrt_price_at_negative_tick(I32): u128\n\t21: StLoc[2](loc1: u128)\n\t22: Branch(26)\nB8:\n\t23: MoveLoc[0](Arg0: I32)\n\t24: Call get_sqrt_price_at_positive_tick(I32): u128\n\t25: StLoc[2](loc1: u128)\nB9:\n\t26: MoveLoc[2](loc1: u128)\n\t27: Ret\n}\n\npublic is_valid_index(Arg0: I32, Arg1: u32): bool {\nL2:\tloc0: bool\nL3:\tloc1: bool\nB0:\n\t0: CopyLoc[0](Arg0: I32)\n\t1: Call min_tick(): I32\n\t2: Call i32::gte(I32, I32): bool\n\t3: BrFalse(9)\nB1:\n\t4: CopyLoc[0](Arg0: I32)\n\t5: Call max_tick(): I32\n\t6: Call i32::lte(I32, I32): bool\n\t7: StLoc[2](loc0: bool)\n\t8: Branch(11)\nB2:\n\t9: LdFalse\n\t10: StLoc[2](loc0: bool)\nB3:\n\t11: MoveLoc[2](loc0: bool)\n\t12: BrFalse(22)\nB4:\n\t13: MoveLoc[0](Arg0: I32)\n\t14: MoveLoc[1](Arg1: u32)\n\t15: Call i32::from(u32): I32\n\t16: Call i32::mod(I32, I32): I32\n\t17: LdU32(0)\n\t18: Call i32::from(u32): I32\n\t19: Eq\n\t20: StLoc[3](loc1: bool)\n\t21: Branch(24)\nB5:\n\t22: LdFalse\n\t23: StLoc[3](loc1: bool)\nB6:\n\t24: MoveLoc[3](loc1: bool)\n\t25: Ret\n}\n\npublic get_tick_at_sqrt_price(Arg0: u128): I32 {\nL1:\tloc0: bool\nL2:\tloc1: u128\nL3:\tloc2: u8\nL4:\tloc3: I128\nL5:\tloc4: I128\nL6:\tloc5: u8\nL7:\tloc6: u128\nL8:\tloc7: u8\nL9:\tloc8: I32\nL10:\tloc9: I32\nB0:\n\t0: CopyLoc[0](Arg0: u128)\n\t1: LdConst[2](u128: 4295..)\n\t2: Ge\n\t3: BrFalse(9)\nB1:\n\t4: CopyLoc[0](Arg0: u128)\n\t5: LdConst[1](u128: 7922..)\n\t6: Le\n\t7: StLoc[1](loc0: bool)\n\t8: Branch(11)\nB2:\n\t9: LdFalse\n\t10: StLoc[1](loc0: bool)\nB3:\n\t11: MoveLoc[1](loc0: bool)\n\t12: BrFalse(14)\nB4:\n\t13: Branch(16)\nB5:\n\t14: LdConst[4](u64: 2)\n\t15: Abort\nB6:\n\t16: CopyLoc[0](Arg0: u128)\n\t17: StLoc[7](loc6: u128)\n\t18: LdU8(0)\n\t19: StLoc[6](loc5: u8)\n\t20: CopyLoc[7](loc6: u128)\n\t21: LdU128(18446744073709551616)\n\t22: Ge\n\t23: Call as_u8(bool): u8\n\t24: LdU8(6)\n\t25: Shl\n\t26: StLoc[3](loc2: u8)\n\t27: MoveLoc[6](loc5: u8)\n\t28: CopyLoc[3](loc2: u8)\n\t29: BitOr\n\t30: StLoc[6](loc5: u8)\n\t31: MoveLoc[7](loc6: u128)\n\t32: MoveLoc[3](loc2: u8)\n\t33: Shr\n\t34: StLoc[7](loc6: u128)\n\t35: CopyLoc[7](loc6: u128)\n\t36: LdU128(4294967296)\n\t37: Ge\n\t38: Call as_u8(bool): u8\n\t39: LdU8(5)\n\t40: Shl\n\t41: StLoc[3](loc2: u8)\n\t42: MoveLoc[6](loc5: u8)\n\t43: CopyLoc[3](loc2: u8)\n\t44: BitOr\n\t45: StLoc[6](loc5: u8)\n\t46: MoveLoc[7](loc6: u128)\n\t47: MoveLoc[3](loc2: u8)\n\t48: Shr\n\t49: StLoc[7](loc6: u128)\n\t50: CopyLoc[7](loc6: u128)\n\t51: LdU128(65536)\n\t52: Ge\n\t53: Call as_u8(bool): u8\n\t54: LdU8(4)\n\t55: Shl\n\t56: StLoc[3](loc2: u8)\n\t57: MoveLoc[6](loc5: u8)\n\t58: CopyLoc[3](loc2: u8)\n\t59: BitOr\n\t60: StLoc[6](loc5: u8)\n\t61: MoveLoc[7](loc6: u128)\n\t62: MoveLoc[3](loc2: u8)\n\t63: Shr\n\t64: StLoc[7](loc6: u128)\n\t65: CopyLoc[7](loc6: u128)\n\t66: LdU128(256)\n\t67: Ge\n\t68: Call as_u8(bool): u8\n\t69: LdU8(3)\n\t70: Shl\n\t71: StLoc[3](loc2: u8)\n\t72: MoveLoc[6](loc5: u8)\n\t73: CopyLoc[3](loc2: u8)\n\t74: BitOr\n\t75: StLoc[6](loc5: u8)\n\t76: MoveLoc[7](loc6: u128)\n\t77: MoveLoc[3](loc2: u8)\n\t78: Shr\n\t79: StLoc[7](loc6: u128)\n\t80: CopyLoc[7](loc6: u128)\n\t81: LdU128(16)\n\t82: Ge\n\t83: Call as_u8(bool): u8\n\t84: LdU8(2)\n\t85: Shl\n\t86: StLoc[3](loc2: u8)\n\t87: MoveLoc[6](loc5: u8)\n\t88: CopyLoc[3](loc2: u8)\n\t89: BitOr\n\t90: StLoc[6](loc5: u8)\n\t91: MoveLoc[7](loc6: u128)\n\t92: MoveLoc[3](loc2: u8)\n\t93: Shr\n\t94: StLoc[7](loc6: u128)\n\t95: CopyLoc[7](loc6: u128)\n\t96: LdU128(4)\n\t97: Ge\n\t98: Call as_u8(bool): u8\n\t99: LdU8(1)\n\t100: Shl\n\t101: StLoc[3](loc2: u8)\n\t102: MoveLoc[6](loc5: u8)\n\t103: CopyLoc[3](loc2: u8)\n\t104: BitOr\n\t105: StLoc[6](loc5: u8)\n\t106: MoveLoc[7](loc6: u128)\n\t107: MoveLoc[3](loc2: u8)\n\t108: Shr\n\t109: LdU128(2)\n\t110: Ge\n\t111: Call as_u8(bool): u8\n\t112: LdU8(0)\n\t113: Shl\n\t114: StLoc[3](loc2: u8)\n\t115: MoveLoc[6](loc5: u8)\n\t116: MoveLoc[3](loc2: u8)\n\t117: BitOr\n\t118: StLoc[6](loc5: u8)\n\t119: CopyLoc[6](loc5: u8)\n\t120: CastU128\n\t121: Call i128::from(u128): I128\n\t122: LdU128(64)\n\t123: Call i128::from(u128): I128\n\t124: Call i128::sub(I128, I128): I128\n\t125: LdU8(32)\n\t126: Call i128::shl(I128, u8): I128\n\t127: StLoc[4](loc3: I128)\n\t128: CopyLoc[6](loc5: u8)\n\t129: LdU8(64)\n\t130: Ge\n\t131: BrFalse(139)\nB7:\n\t132: CopyLoc[0](Arg0: u128)\n\t133: MoveLoc[6](loc5: u8)\n\t134: LdU8(63)\n\t135: Sub\n\t136: Shr\n\t137: StLoc[2](loc1: u128)\n\t138: Branch(145)\nB8:\n\t139: CopyLoc[0](Arg0: u128)\n\t140: LdU8(63)\n\t141: MoveLoc[6](loc5: u8)\n\t142: Sub\n\t143: Shl\n\t144: StLoc[2](loc1: u128)\nB9:\n\t145: MoveLoc[2](loc1: u128)\n\t146: StLoc[7](loc6: u128)\n\t147: LdU8(31)\n\t148: StLoc[8](loc7: u8)\nB10:\n\t149: CopyLoc[8](loc7: u8)\n\t150: LdU8(18)\n\t151: Ge\n\t152: BrFalse(182)\nB11:\n\t153: Branch(154)\nB12:\n\t154: CopyLoc[7](loc6: u128)\n\t155: MoveLoc[7](loc6: u128)\n\t156: Mul\n\t157: LdU8(63)\n\t158: Shr\n\t159: StLoc[7](loc6: u128)\n\t160: CopyLoc[7](loc6: u128)\n\t161: LdU8(64)\n\t162: Shr\n\t163: CastU8\n\t164: StLoc[3](loc2: u8)\n\t165: MoveLoc[4](loc3: I128)\n\t166: CopyLoc[3](loc2: u8)\n\t167: CastU128\n\t168: Call i128::from(u128): I128\n\t169: CopyLoc[8](loc7: u8)\n\t170: Call i128::shl(I128, u8): I128\n\t171: Call i128::or(I128, I128): I128\n\t172: StLoc[4](loc3: I128)\n\t173: MoveLoc[7](loc6: u128)\n\t174: MoveLoc[3](loc2: u8)\n\t175: Shr\n\t176: StLoc[7](loc6: u128)\n\t177: MoveLoc[8](loc7: u8)\n\t178: LdU8(1)\n\t179: Sub\n\t180: StLoc[8](loc7: u8)\n\t181: Branch(149)\nB13:\n\t182: MoveLoc[4](loc3: I128)\n\t183: LdU128(59543866431366)\n\t184: Call i128::from(u128): I128\n\t185: Call i128::mul(I128, I128): I128\n\t186: StLoc[5](loc4: I128)\n\t187: CopyLoc[5](loc4: I128)\n\t188: LdU128(184467440737095516)\n\t189: Call i128::from(u128): I128\n\t190: Call i128::sub(I128, I128): I128\n\t191: LdU8(64)\n\t192: Call i128::shr(I128, u8): I128\n\t193: Call i128::as_i32(I128): I32\n\t194: StLoc[10](loc9: I32)\n\t195: MoveLoc[5](loc4: I128)\n\t196: LdU128(15793534762490258745)\n\t197: Call i128::from(u128): I128\n\t198: Call i128::add(I128, I128): I128\n\t199: LdU8(64)\n\t200: Call i128::shr(I128, u8): I128\n\t201: Call i128::as_i32(I128): I32\n\t202: StLoc[9](loc8: I32)\n\t203: CopyLoc[10](loc9: I32)\n\t204: CopyLoc[9](loc8: I32)\n\t205: Call i32::eq(I32, I32): bool\n\t206: BrFalse(209)\nB14:\n\t207: MoveLoc[10](loc9: I32)\n\t208: Ret\nB15:\n\t209: CopyLoc[9](loc8: I32)\n\t210: Call get_sqrt_price_at_tick(I32): u128\n\t211: MoveLoc[0](Arg0: u128)\n\t212: Le\n\t213: BrFalse(216)\nB16:\n\t214: MoveLoc[9](loc8: I32)\n\t215: Ret\nB17:\n\t216: MoveLoc[10](loc9: I32)\n\t217: Ret\n}\n\nas_u8(Arg0: bool): u8 {\nL1:\tloc0: u8\nB0:\n\t0: MoveLoc[0](Arg0: bool)\n\t1: BrFalse(5)\nB1:\n\t2: LdU8(1)\n\t3: StLoc[1](loc0: u8)\n\t4: Branch(7)\nB2:\n\t5: LdU8(0)\n\t6: StLoc[1](loc0: u8)\nB3:\n\t7: MoveLoc[1](loc0: u8)\n\t8: Ret\n}\n\nget_sqrt_price_at_negative_tick(Arg0: I32): u128 {\nL1:\tloc0: u128\nL2:\tloc1: u32\nL3:\tloc2: u128\nB0:\n\t0: MoveLoc[0](Arg0: I32)\n\t1: Call i32::abs(I32): I32\n\t2: Call i32::as_u32(I32): u32\n\t3: StLoc[2](loc1: u32)\n\t4: CopyLoc[2](loc1: u32)\n\t5: LdU32(1)\n\t6: BitAnd\n\t7: LdU32(0)\n\t8: Neq\n\t9: BrFalse(13)\nB1:\n\t10: LdU128(18445821805675392311)\n\t11: StLoc[1](loc0: u128)\n\t12: Branch(15)\nB2:\n\t13: LdU128(18446744073709551616)\n\t14: StLoc[1](loc0: u128)\nB3:\n\t15: MoveLoc[1](loc0: u128)\n\t16: StLoc[3](loc2: u128)\n\t17: CopyLoc[2](loc1: u32)\n\t18: LdU32(2)\n\t19: BitAnd\n\t20: LdU32(0)\n\t21: Neq\n\t22: BrFalse(28)\nB4:\n\t23: MoveLoc[3](loc2: u128)\n\t24: LdU128(18444899583751176498)\n\t25: LdU8(64)\n\t26: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t27: StLoc[3](loc2: u128)\nB5:\n\t28: CopyLoc[2](loc1: u32)\n\t29: LdU32(4)\n\t30: BitAnd\n\t31: LdU32(0)\n\t32: Neq\n\t33: BrFalse(39)\nB6:\n\t34: MoveLoc[3](loc2: u128)\n\t35: LdU128(18443055278223354162)\n\t36: LdU8(64)\n\t37: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t38: StLoc[3](loc2: u128)\nB7:\n\t39: CopyLoc[2](loc1: u32)\n\t40: LdU32(8)\n\t41: BitAnd\n\t42: LdU32(0)\n\t43: Neq\n\t44: BrFalse(50)\nB8:\n\t45: MoveLoc[3](loc2: u128)\n\t46: LdU128(18439367220385604838)\n\t47: LdU8(64)\n\t48: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t49: StLoc[3](loc2: u128)\nB9:\n\t50: CopyLoc[2](loc1: u32)\n\t51: LdU32(16)\n\t52: BitAnd\n\t53: LdU32(0)\n\t54: Neq\n\t55: BrFalse(61)\nB10:\n\t56: MoveLoc[3](loc2: u128)\n\t57: LdU128(18431993317065449817)\n\t58: LdU8(64)\n\t59: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t60: StLoc[3](loc2: u128)\nB11:\n\t61: CopyLoc[2](loc1: u32)\n\t62: LdU32(32)\n\t63: BitAnd\n\t64: LdU32(0)\n\t65: Neq\n\t66: BrFalse(72)\nB12:\n\t67: MoveLoc[3](loc2: u128)\n\t68: LdU128(18417254355718160513)\n\t69: LdU8(64)\n\t70: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t71: StLoc[3](loc2: u128)\nB13:\n\t72: CopyLoc[2](loc1: u32)\n\t73: LdU32(64)\n\t74: BitAnd\n\t75: LdU32(0)\n\t76: Neq\n\t77: BrFalse(83)\nB14:\n\t78: MoveLoc[3](loc2: u128)\n\t79: LdU128(18387811781193591352)\n\t80: LdU8(64)\n\t81: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t82: StLoc[3](loc2: u128)\nB15:\n\t83: CopyLoc[2](loc1: u32)\n\t84: LdU32(128)\n\t85: BitAnd\n\t86: LdU32(0)\n\t87: Neq\n\t88: BrFalse(94)\nB16:\n\t89: MoveLoc[3](loc2: u128)\n\t90: LdU128(18329067761203520168)\n\t91: LdU8(64)\n\t92: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t93: StLoc[3](loc2: u128)\nB17:\n\t94: CopyLoc[2](loc1: u32)\n\t95: LdU32(256)\n\t96: BitAnd\n\t97: LdU32(0)\n\t98: Neq\n\t99: BrFalse(105)\nB18:\n\t100: MoveLoc[3](loc2: u128)\n\t101: LdU128(18212142134806087854)\n\t102: LdU8(64)\n\t103: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t104: StLoc[3](loc2: u128)\nB19:\n\t105: CopyLoc[2](loc1: u32)\n\t106: LdU32(512)\n\t107: BitAnd\n\t108: LdU32(0)\n\t109: Neq\n\t110: BrFalse(116)\nB20:\n\t111: MoveLoc[3](loc2: u128)\n\t112: LdU128(17980523815641551639)\n\t113: LdU8(64)\n\t114: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t115: StLoc[3](loc2: u128)\nB21:\n\t116: CopyLoc[2](loc1: u32)\n\t117: LdU32(1024)\n\t118: BitAnd\n\t119: LdU32(0)\n\t120: Neq\n\t121: BrFalse(127)\nB22:\n\t122: MoveLoc[3](loc2: u128)\n\t123: LdU128(17526086738831147013)\n\t124: LdU8(64)\n\t125: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t126: StLoc[3](loc2: u128)\nB23:\n\t127: CopyLoc[2](loc1: u32)\n\t128: LdU32(2048)\n\t129: BitAnd\n\t130: LdU32(0)\n\t131: Neq\n\t132: BrFalse(138)\nB24:\n\t133: MoveLoc[3](loc2: u128)\n\t134: LdU128(16651378430235024244)\n\t135: LdU8(64)\n\t136: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t137: StLoc[3](loc2: u128)\nB25:\n\t138: CopyLoc[2](loc1: u32)\n\t139: LdU32(4096)\n\t140: BitAnd\n\t141: LdU32(0)\n\t142: Neq\n\t143: BrFalse(149)\nB26:\n\t144: MoveLoc[3](loc2: u128)\n\t145: LdU128(15030750278693429944)\n\t146: LdU8(64)\n\t147: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t148: StLoc[3](loc2: u128)\nB27:\n\t149: CopyLoc[2](loc1: u32)\n\t150: LdU32(8192)\n\t151: BitAnd\n\t152: LdU32(0)\n\t153: Neq\n\t154: BrFalse(160)\nB28:\n\t155: MoveLoc[3](loc2: u128)\n\t156: LdU128(12247334978882834399)\n\t157: LdU8(64)\n\t158: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t159: StLoc[3](loc2: u128)\nB29:\n\t160: CopyLoc[2](loc1: u32)\n\t161: LdU32(16384)\n\t162: BitAnd\n\t163: LdU32(0)\n\t164: Neq\n\t165: BrFalse(171)\nB30:\n\t166: MoveLoc[3](loc2: u128)\n\t167: LdU128(8131365268884726200)\n\t168: LdU8(64)\n\t169: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t170: StLoc[3](loc2: u128)\nB31:\n\t171: CopyLoc[2](loc1: u32)\n\t172: LdU32(32768)\n\t173: BitAnd\n\t174: LdU32(0)\n\t175: Neq\n\t176: BrFalse(182)\nB32:\n\t177: MoveLoc[3](loc2: u128)\n\t178: LdU128(3584323654723342297)\n\t179: LdU8(64)\n\t180: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t181: StLoc[3](loc2: u128)\nB33:\n\t182: CopyLoc[2](loc1: u32)\n\t183: LdU32(65536)\n\t184: BitAnd\n\t185: LdU32(0)\n\t186: Neq\n\t187: BrFalse(193)\nB34:\n\t188: MoveLoc[3](loc2: u128)\n\t189: LdU128(696457651847595233)\n\t190: LdU8(64)\n\t191: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t192: StLoc[3](loc2: u128)\nB35:\n\t193: CopyLoc[2](loc1: u32)\n\t194: LdU32(131072)\n\t195: BitAnd\n\t196: LdU32(0)\n\t197: Neq\n\t198: BrFalse(204)\nB36:\n\t199: MoveLoc[3](loc2: u128)\n\t200: LdU128(26294789957452057)\n\t201: LdU8(64)\n\t202: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t203: StLoc[3](loc2: u128)\nB37:\n\t204: MoveLoc[2](loc1: u32)\n\t205: LdU32(262144)\n\t206: BitAnd\n\t207: LdU32(0)\n\t208: Neq\n\t209: BrFalse(215)\nB38:\n\t210: MoveLoc[3](loc2: u128)\n\t211: LdU128(37481735321082)\n\t212: LdU8(64)\n\t213: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t214: StLoc[3](loc2: u128)\nB39:\n\t215: MoveLoc[3](loc2: u128)\n\t216: Ret\n}\n\nget_sqrt_price_at_positive_tick(Arg0: I32): u128 {\nL1:\tloc0: u128\nL2:\tloc1: u32\nL3:\tloc2: u128\nB0:\n\t0: MoveLoc[0](Arg0: I32)\n\t1: Call i32::abs(I32): I32\n\t2: Call i32::as_u32(I32): u32\n\t3: StLoc[2](loc1: u32)\n\t4: CopyLoc[2](loc1: u32)\n\t5: LdU32(1)\n\t6: BitAnd\n\t7: LdU32(0)\n\t8: Neq\n\t9: BrFalse(13)\nB1:\n\t10: LdU128(79232123823359799118286999567)\n\t11: StLoc[1](loc0: u128)\n\t12: Branch(15)\nB2:\n\t13: LdU128(79228162514264337593543950336)\n\t14: StLoc[1](loc0: u128)\nB3:\n\t15: MoveLoc[1](loc0: u128)\n\t16: StLoc[3](loc2: u128)\n\t17: CopyLoc[2](loc1: u32)\n\t18: LdU32(2)\n\t19: BitAnd\n\t20: LdU32(0)\n\t21: Neq\n\t22: BrFalse(28)\nB4:\n\t23: MoveLoc[3](loc2: u128)\n\t24: LdU128(79236085330515764027303304731)\n\t25: LdU8(96)\n\t26: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t27: StLoc[3](loc2: u128)\nB5:\n\t28: CopyLoc[2](loc1: u32)\n\t29: LdU32(4)\n\t30: BitAnd\n\t31: LdU32(0)\n\t32: Neq\n\t33: BrFalse(39)\nB6:\n\t34: MoveLoc[3](loc2: u128)\n\t35: LdU128(79244008939048815603706035061)\n\t36: LdU8(96)\n\t37: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t38: StLoc[3](loc2: u128)\nB7:\n\t39: CopyLoc[2](loc1: u32)\n\t40: LdU32(8)\n\t41: BitAnd\n\t42: LdU32(0)\n\t43: Neq\n\t44: BrFalse(50)\nB8:\n\t45: MoveLoc[3](loc2: u128)\n\t46: LdU128(79259858533276714757314932305)\n\t47: LdU8(96)\n\t48: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t49: StLoc[3](loc2: u128)\nB9:\n\t50: CopyLoc[2](loc1: u32)\n\t51: LdU32(16)\n\t52: BitAnd\n\t53: LdU32(0)\n\t54: Neq\n\t55: BrFalse(61)\nB10:\n\t56: MoveLoc[3](loc2: u128)\n\t57: LdU128(79291567232598584799939703904)\n\t58: LdU8(96)\n\t59: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t60: StLoc[3](loc2: u128)\nB11:\n\t61: CopyLoc[2](loc1: u32)\n\t62: LdU32(32)\n\t63: BitAnd\n\t64: LdU32(0)\n\t65: Neq\n\t66: BrFalse(72)\nB12:\n\t67: MoveLoc[3](loc2: u128)\n\t68: LdU128(79355022692464371645785046466)\n\t69: LdU8(96)\n\t70: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t71: StLoc[3](loc2: u128)\nB13:\n\t72: CopyLoc[2](loc1: u32)\n\t73: LdU32(64)\n\t74: BitAnd\n\t75: LdU32(0)\n\t76: Neq\n\t77: BrFalse(83)\nB14:\n\t78: MoveLoc[3](loc2: u128)\n\t79: LdU128(79482085999252804386437311141)\n\t80: LdU8(96)\n\t81: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t82: StLoc[3](loc2: u128)\nB15:\n\t83: CopyLoc[2](loc1: u32)\n\t84: LdU32(128)\n\t85: BitAnd\n\t86: LdU32(0)\n\t87: Neq\n\t88: BrFalse(94)\nB16:\n\t89: MoveLoc[3](loc2: u128)\n\t90: LdU128(79736823300114093921829183326)\n\t91: LdU8(96)\n\t92: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t93: StLoc[3](loc2: u128)\nB17:\n\t94: CopyLoc[2](loc1: u32)\n\t95: LdU32(256)\n\t96: BitAnd\n\t97: LdU32(0)\n\t98: Neq\n\t99: BrFalse(105)\nB18:\n\t100: MoveLoc[3](loc2: u128)\n\t101: LdU128(80248749790819932309965073892)\n\t102: LdU8(96)\n\t103: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t104: StLoc[3](loc2: u128)\nB19:\n\t105: CopyLoc[2](loc1: u32)\n\t106: LdU32(512)\n\t107: BitAnd\n\t108: LdU32(0)\n\t109: Neq\n\t110: BrFalse(116)\nB20:\n\t111: MoveLoc[3](loc2: u128)\n\t112: LdU128(81282483887344747381513967011)\n\t113: LdU8(96)\n\t114: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t115: StLoc[3](loc2: u128)\nB21:\n\t116: CopyLoc[2](loc1: u32)\n\t117: LdU32(1024)\n\t118: BitAnd\n\t119: LdU32(0)\n\t120: Neq\n\t121: BrFalse(127)\nB22:\n\t122: MoveLoc[3](loc2: u128)\n\t123: LdU128(83390072131320151908154831281)\n\t124: LdU8(96)\n\t125: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t126: StLoc[3](loc2: u128)\nB23:\n\t127: CopyLoc[2](loc1: u32)\n\t128: LdU32(2048)\n\t129: BitAnd\n\t130: LdU32(0)\n\t131: Neq\n\t132: BrFalse(138)\nB24:\n\t133: MoveLoc[3](loc2: u128)\n\t134: LdU128(87770609709833776024991924138)\n\t135: LdU8(96)\n\t136: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t137: StLoc[3](loc2: u128)\nB25:\n\t138: CopyLoc[2](loc1: u32)\n\t139: LdU32(4096)\n\t140: BitAnd\n\t141: LdU32(0)\n\t142: Neq\n\t143: BrFalse(149)\nB26:\n\t144: MoveLoc[3](loc2: u128)\n\t145: LdU128(97234110755111693312479820773)\n\t146: LdU8(96)\n\t147: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t148: StLoc[3](loc2: u128)\nB27:\n\t149: CopyLoc[2](loc1: u32)\n\t150: LdU32(8192)\n\t151: BitAnd\n\t152: LdU32(0)\n\t153: Neq\n\t154: BrFalse(160)\nB28:\n\t155: MoveLoc[3](loc2: u128)\n\t156: LdU128(119332217159966728226237229890)\n\t157: LdU8(96)\n\t158: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t159: StLoc[3](loc2: u128)\nB29:\n\t160: CopyLoc[2](loc1: u32)\n\t161: LdU32(16384)\n\t162: BitAnd\n\t163: LdU32(0)\n\t164: Neq\n\t165: BrFalse(171)\nB30:\n\t166: MoveLoc[3](loc2: u128)\n\t167: LdU128(179736315981702064433883588727)\n\t168: LdU8(96)\n\t169: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t170: StLoc[3](loc2: u128)\nB31:\n\t171: CopyLoc[2](loc1: u32)\n\t172: LdU32(32768)\n\t173: BitAnd\n\t174: LdU32(0)\n\t175: Neq\n\t176: BrFalse(182)\nB32:\n\t177: MoveLoc[3](loc2: u128)\n\t178: LdU128(407748233172238350107850275304)\n\t179: LdU8(96)\n\t180: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t181: StLoc[3](loc2: u128)\nB33:\n\t182: CopyLoc[2](loc1: u32)\n\t183: LdU32(65536)\n\t184: BitAnd\n\t185: LdU32(0)\n\t186: Neq\n\t187: BrFalse(193)\nB34:\n\t188: MoveLoc[3](loc2: u128)\n\t189: LdU128(2098478828474011932436660412517)\n\t190: LdU8(96)\n\t191: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t192: StLoc[3](loc2: u128)\nB35:\n\t193: CopyLoc[2](loc1: u32)\n\t194: LdU32(131072)\n\t195: BitAnd\n\t196: LdU32(0)\n\t197: Neq\n\t198: BrFalse(204)\nB36:\n\t199: MoveLoc[3](loc2: u128)\n\t200: LdU128(55581415166113811149459800483533)\n\t201: LdU8(96)\n\t202: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t203: StLoc[3](loc2: u128)\nB37:\n\t204: MoveLoc[2](loc1: u32)\n\t205: LdU32(262144)\n\t206: BitAnd\n\t207: LdU32(0)\n\t208: Neq\n\t209: BrFalse(215)\nB38:\n\t210: MoveLoc[3](loc2: u128)\n\t211: LdU128(38992368544603139932233054999993551)\n\t212: LdU8(96)\n\t213: Call full_math_u128::mul_shr(u128, u128, u8): u128\n\t214: StLoc[3](loc2: u128)\nB39:\n\t215: MoveLoc[3](loc2: u128)\n\t216: LdU8(32)\n\t217: Shr\n\t218: Ret\n}\n\nConstants [\n\t0 => u32: 443636\n\t1 => u128: 79226673515401279992447579055\n\t2 => u128: 4295048016\n\t3 => u64: 1\n\t4 => u64: 2\n]\n}\n",
      "utils": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.utils {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::comparator;\nuse 0000000000000000000000000000000000000000000000000000000000000001::ascii;\nuse 0000000000000000000000000000000000000000000000000000000000000001::type_name;\nuse 0000000000000000000000000000000000000000000000000000000000000002::clock;\nuse 0000000000000000000000000000000000000000000000000000000000000002::coin;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\n\npublic check_deadline(Arg0: &Clock, Arg1: u64) {\nB0:\n\t0: MoveLoc[1](Arg1: u64)\n\t1: MoveLoc[0](Arg0: &Clock)\n\t2: Call clock::timestamp_ms(&Clock): u64\n\t3: Lt\n\t4: BrFalse(7)\nB1:\n\t5: LdConst[0](u64: 0)\n\t6: Abort\nB2:\n\t7: Ret\n}\n\npublic is_ordered<Ty0, Ty1>(): bool {\nL0:\tloc0: Result\nL1:\tloc1: String\nL2:\tloc2: String\nB0:\n\t0: Call type_name::get<Ty0>(): TypeName\n\t1: Call type_name::into_string(TypeName): String\n\t2: StLoc[1](loc1: String)\n\t3: Call type_name::get<Ty1>(): TypeName\n\t4: Call type_name::into_string(TypeName): String\n\t5: StLoc[2](loc2: String)\n\t6: MoveLoc[1](loc1: String)\n\t7: Call ascii::into_bytes(String): vector<u8>\n\t8: MoveLoc[2](loc2: String)\n\t9: Call ascii::into_bytes(String): vector<u8>\n\t10: Call comparator::compare_u8_vector(vector<u8>, vector<u8>): Result\n\t11: StLoc[0](loc0: Result)\n\t12: ImmBorrowLoc[0](loc0: Result)\n\t13: Call comparator::is_equal(&Result): bool\n\t14: Not\n\t15: BrFalse(17)\nB1:\n\t16: Branch(19)\nB2:\n\t17: LdConst[1](u64: 1)\n\t18: Abort\nB3:\n\t19: ImmBorrowLoc[0](loc0: Result)\n\t20: Call comparator::is_smaller_than(&Result): bool\n\t21: Ret\n}\n\npublic check_order<Ty0, Ty1>() {\nB0:\n\t0: Call is_ordered<Ty0, Ty1>(): bool\n\t1: Not\n\t2: BrFalse(5)\nB1:\n\t3: LdConst[2](u64: 2)\n\t4: Abort\nB2:\n\t5: Ret\n}\n\npublic to_seconds(Arg0: u64): u64 {\nB0:\n\t0: MoveLoc[0](Arg0: u64)\n\t1: LdU64(1000)\n\t2: Div\n\t3: Ret\n}\n\npublic refund<Ty0>(Arg0: Coin<Ty0>, Arg1: address) {\nB0:\n\t0: ImmBorrowLoc[0](Arg0: Coin<Ty0>)\n\t1: Call coin::value<Ty0>(&Coin<Ty0>): u64\n\t2: LdU64(0)\n\t3: Gt\n\t4: BrFalse(9)\nB1:\n\t5: MoveLoc[0](Arg0: Coin<Ty0>)\n\t6: MoveLoc[1](Arg1: address)\n\t7: Call transfer::public_transfer<Coin<Ty0>>(Coin<Ty0>, address)\n\t8: Branch(11)\nB2:\n\t9: MoveLoc[0](Arg0: Coin<Ty0>)\n\t10: Call coin::destroy_zero<Ty0>(Coin<Ty0>)\nB3:\n\t11: Ret\n}\n\nConstants [\n\t0 => u64: 0\n\t1 => u64: 1\n\t2 => u64: 2\n]\n}\n",
      "versioned": "// Move bytecode v6\nmodule 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d.versioned {\nuse 25929e7f29e0a30eb4e692952ba1b5b65a3a4d65ab5f2a32e1ba3edcb587f26d::admin_cap;\nuse 0000000000000000000000000000000000000000000000000000000000000002::event;\nuse 0000000000000000000000000000000000000000000000000000000000000002::object;\nuse 0000000000000000000000000000000000000000000000000000000000000002::transfer;\nuse 0000000000000000000000000000000000000000000000000000000000000002::tx_context;\n\nstruct Versioned has store, key {\n\tid: UID,\n\tversion: u64\n}\n\nstruct Upgraded has copy, drop, store {\n\tprevious_version: u64,\n\tnew_version: u64\n}\n\ninit(Arg0: &mut TxContext) {\nB0:\n\t0: MoveLoc[0](Arg0: &mut TxContext)\n\t1: Call object::new(&mut TxContext): UID\n\t2: LdConst[0](u64: 1)\n\t3: Pack[0](Versioned)\n\t4: Call transfer::share_object<Versioned>(Versioned)\n\t5: Ret\n}\n\npublic check_version(Arg0: &Versioned) {\nB0:\n\t0: MoveLoc[0](Arg0: &Versioned)\n\t1: ImmBorrowField[0](Versioned.version: u64)\n\t2: ReadRef\n\t3: LdConst[0](u64: 1)\n\t4: Neq\n\t5: BrFalse(8)\nB1:\n\t6: LdConst[1](u64: 999)\n\t7: Abort\nB2:\n\t8: Ret\n}\n\npublic upgrade(Arg0: &AdminCap, Arg1: &mut Versioned) {\nB0:\n\t0: CopyLoc[1](Arg1: &mut Versioned)\n\t1: ImmBorrowField[0](Versioned.version: u64)\n\t2: ReadRef\n\t3: LdConst[0](u64: 1)\n\t4: Lt\n\t5: BrFalse(7)\nB1:\n\t6: Branch(11)\nB2:\n\t7: MoveLoc[1](Arg1: &mut Versioned)\n\t8: Pop\n\t9: LdConst[2](u64: 1000)\n\t10: Abort\nB3:\n\t11: MoveLoc[1](Arg1: &mut Versioned)\n\t12: Call ugrade_internal(&mut Versioned)\n\t13: Ret\n}\n\nugrade_internal(Arg0: &mut Versioned) {\nB0:\n\t0: CopyLoc[0](Arg0: &mut Versioned)\n\t1: ImmBorrowField[0](Versioned.version: u64)\n\t2: ReadRef\n\t3: LdConst[0](u64: 1)\n\t4: Pack[1](Upgraded)\n\t5: Call event::emit<Upgraded>(Upgraded)\n\t6: LdConst[0](u64: 1)\n\t7: MoveLoc[0](Arg0: &mut Versioned)\n\t8: MutBorrowField[0](Versioned.version: u64)\n\t9: WriteRef\n\t10: Ret\n}\n\nConstants [\n\t0 => u64: 1\n\t1 => u64: 999\n\t2 => u64: 1000\n]\n}\n"
    }
  }
}
